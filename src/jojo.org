#+property: tangle jojo.js
#+title: jojo

* [todo-stack]

*** clone_exp_t

*** *finish the semantic*

*** read sexp

*** write data out in a standard way

*** interpret

*** test

*** ffi to js

* [note]

*** as prototype

    - without optimizing the searches
      involved in :
      - name_dict
      - scope
      - data field
      - sig to gene
      - gene to disp
      this implementation can only be a prototype.

    - to do the optimizations well,
      a compiler is needed.

* prolog

*** utility

***** print

      #+begin_src js
      let print = console.log;
      #+end_src

***** vect_eq_p

      #+begin_src js
      function vect_eq_p (v1, v2)
      {
          if (v1.length !== v2.length)
              return false;
          let index = 0;
          while (index < v1.length) {
              if (v1[index] !== v2[index])
                  return false;
              index = index + 1;
          }
          return true;
      }
      #+end_src

***** error

      #+begin_src js
      function error ()
      {
          assert (false);
      }
      #+end_src

* env -- environment

*** env_t

    #+begin_src js
    class env_t
    {
        constructor ()
        {
            this.name_dict = new name_dict_t ();
            this.data_stack = [];
            this.frame_stack = [];
            this.scope_stack = [];
        }
    }
    #+end_src

*** name_dict

***** name_dict_t -- name to den

      #+begin_src js
      class name_dict_t
      {
          constructor ()
          {
              this.dict = new Map ();
          }

          get (name)
          {
              return this.dict.get (name);
          }

          set (name, den)
          {
              this.dict.set (name, den);
          }
      }
      #+end_src

***** name_dict_get

      #+begin_src js
      function name_dict_get (env, name)
      {
          return env.name_dict.get (name);
      }
      #+end_src

***** name_dict_set

      #+begin_src js
      function name_dict_set (env, name, den)
      {
          env.name_dict.set (name, den);
      }
      #+end_src

*** data_stack

***** data_stack_push

      #+begin_src js
      function data_stack_push (env, obj)
      {
          env.data_stack.push (obj);
      }
      #+end_src

***** data_stack_pop

      #+begin_src js
      function data_stack_pop (env)
      {
          return env.data_stack.pop ();
      }
      #+end_src

***** data_stack_tos

      #+begin_src js
      function data_stack_tos (env)
      {
          let length = data_stack_length (env);
          return env.data_stack[length - 1];
      }
      #+end_src

***** data_stack_drop

      #+begin_src js
      function data_stack_drop (env)
      {
          data_stack_pop (env);
      }
      #+end_src

***** data_stack_peek

      #+begin_src js
      function data_stack_peek (env, index)
      {
          // index start from 1
          let length = data_stack_length (env);
          return env.data_stack[length - index];
      }
      #+end_src

***** data_stack_length

      #+begin_src js
      function data_stack_length (env)
      {
          return env.data_stack.length;
      }
      #+end_src

*** frame_stack

***** frame_stack_push

      #+begin_src js
      function frame_stack_push (env, frame)
      {
          env.frame_stack.push (frame);
      }
      #+end_src

***** frame_stack_pop

      #+begin_src js
      function frame_stack_pop (env)
      {
          return env.frame_stack.pop ();
      }
      #+end_src

***** frame_stack_tos

      #+begin_src js
      function frame_stack_tos (env)
      {
          let length = frame_stack_length (env);
          return env.frame_stack[length - 1];
      }
      #+end_src

***** frame_stack_drop

      #+begin_src js
      function frame_stack_drop (env)
      {
          frame_stack_pop (env);
      }
      #+end_src

***** frame_stack_length

      #+begin_src js
      function frame_stack_length (env)
      {
          return env.frame_stack.length;
      }
      #+end_src

*** frame

***** scoping_frame_t

      #+begin_src js
      class scoping_frame_t
      {
          constructor (exp_vect)
          {
              this.exp_vect = exp_vect;
              this.length = exp_vect.length;
              this.index = 0;
          }
      }
      #+end_src

***** simple_frame_t

      #+begin_src js
      class simple_frame_t
      {
          constructor (exp_vect)
          {
              this.exp_vect = exp_vect;
              this.length = exp_vect.length;
              this.index = 0;
          }
      }
      #+end_src

***** frame_end_p

      #+begin_src js
      function frame_end_p (frame)
      {
          return frame.index === frame.length;
      }
      #+end_src

***** frame_next_exp

      #+begin_src js
      function frame_next_exp (frame)
      {
          let exp = frame.exp_vect[frame.index];
          frame.index = frame.index + 1;
          return exp;
      }
      #+end_src

*** scope_stack

***** scope_stack_push

      #+begin_src js
      function scope_stack_push (env, scope)
      {
          env.scope_stack.push (scope);
      }
      #+end_src

***** scope_stack_pop

      #+begin_src js
      function scope_stack_pop (env)
      {
          return env.scope_stack.pop ();
      }
      #+end_src

***** scope_stack_tos

      #+begin_src js
      function scope_stack_tos (env)
      {
          let length = scope_stack_length (env);
          return env.scope_stack[length - 1];
      }
      #+end_src

***** scope_stack_drop

      #+begin_src js
      function scope_stack_drop (env)
      {
          scope_stack_pop (env);
      }
      #+end_src

***** scope_stack_length

      #+begin_src js
      function scope_stack_length (env)
      {
          return env.scope_stack.length;
      }
      #+end_src

*** scope

***** scope_t

      #+begin_src js
      class scope_t
      {
          constructor ()
          {
              this.dict = new Map ();
          }

          get (name)
          {
              return this.dict.get (name);
          }

          set (name, obj)
          {
              this.dict.set (name, obj);
          }

          clone ()
          {
              let scope = new scope_t ();
              for (let [name, obj] of this.dict) {
                  scope.set (name, obj);
              }
          }
      }
      #+end_src

* eval

*** exp_vect_eval

    #+begin_src js
    function exp_vect_eval (env, exp_vect)
    {
        let base = frame_stack_length (env);
        let frame = new simple_frame_t (exp_vect);
        frame_stack_push (env, frame);
        eval_with_base (env, base);
    }
    #+end_src

*** eval_with_base

    #+begin_src js
    function eval_with_base (env, base)
    {
        while (frame_stack_length (env) > base)
            eval_one_step (env);
    }
    #+end_src

*** eval_one_step

    #+begin_src js
    function eval_one_step (env)
    {
        let frame = frame_stack_tos (env);
        let scope = scope_stack_tos (env);
        let exp = frame_next_exp (frame);
        if (frame_end_p (frame)) {
            // proper tail call
            frame_stack_drop (env);
            if (frame instanceof scoping_frame_t)
                scope_stack_drop (env);
        }
        // {
        //     print ("- eval_one_step");
        //     print ("  env :", env);
        //     print ("  exp :", exp);
        //     print ("  scope :", scope);
        // }
        exp.exe (env, scope);
    }
    #+end_src

* collect

*** exp_vect_to_obj_vect

    #+begin_src js
    function exp_vect_to_obj_vect (env, exp_vect)
    {
        let mark = data_stack_length (env);
        exp_vect_eval (env, exp_vect);
        let length = data_stack_length (env);
        let obj_vect = [];
        while (length > mark) {
           let obj = data_stack_pop (env);
           obj_vect.unshift (obj);
           length = length - 1;
        }
        return obj_vect;

    }
    #+end_src

*** exp_vect_to_obj

    #+begin_src js
    function exp_vect_to_obj (env, exp_vect)
    {
        let obj_vect = exp_vect_to_obj_vect (env, exp_vect);
        assert (obj_vect.length === 1);
        return obj_vect[0];
    }
    #+end_src

*** exp_to_obj

    #+begin_src js
    function exp_to_obj (env, exp)
    {
        return exp_vect_to_obj (env, [exp]);
    }
    #+end_src

* exp -- expression

*** call_exp_t

    #+begin_src js
    class call_exp_t
    {
        constructor (name)
        {
            this.name = name;
        }

        exe (env, scope)
        {
            let den = name_dict_get (env, this.name);
            den.den_exe (env);
        }
    }
    #+end_src

*** get_exp_t

    #+begin_src js
    class get_exp_t
    {
        constructor (local_name)
        {
            this.local_name = local_name;
        }

        exe (env, scope)
        {
            let obj = scope.get (this.local_name);
            obj.apply (env);
        }
    }
    #+end_src

*** set_exp_t

    #+begin_src js
    class set_exp_t
    {
        constructor (local_name)
        {
            this.local_name = local_name;
        }

        exe (env, scope)
        {
            let obj = data_stack_pop (env);
            scope.set (this.local_name, obj);
        }
    }
    #+end_src

*** clo_exp_t

    #+begin_src js
    class clo_exp_t
    {
        constructor (exp_vect)
        {
            this.exp_vect = exp_vect;
        }

        exe (env, scope)
        {
            let clo_obj = new clo_obj_t (this.exp_vect, scope.clone ());
            data_stack_push (env, clo_obj);
        }
    }
    #+end_src

*** apply_exp_t

    #+begin_src js
    class apply_exp_t
    {
        constructor () { }

        exe (env, scope)
        {
            let clo_obj = data_stack_pop (env);
            let frame = new scoping_frame_t (clo_obj.exp_vect);
            frame_stack_push (env, frame);
            scope_stack_push (env, clo_obj.scope);
        }
    }
    #+end_src

*** case_exp_t

    #+begin_src js
    class case_exp_t
    {
        constructor (exp_vect, case_clause_dict)
        {
            this.exp_vect = exp_vect;
            this.case_clause_dict = case_clause_dict;
        }

        exe (env, scope)
        {
            let obj = exp_vect_to_obj (env, exp_vect);
            assert (obj instanceof data_obj_t);
            let exp_vect = this.case_clause_dict.get (obj.type_name);
            if (exp_vect) {
                let frame = new simple_frame_t (exp_vect);
                frame_stack_push (env, frame);
            }
            else {
                let exp_vect = this.case_clause_dict.get ("else");
                if (exp_vect) {
                    let frame = new simple_frame_t (exp_vect);
                    frame_stack_push (env, frame);
                }
                else {
                    error ();
                }
            }
        }
    }
    #+end_src

*** case_clause_dict_t -- type_name to exp_vect

    #+begin_src js
    class case_clause_dict_t
    {
        constructor ()
        {
            this.dict = new Map ();
        }

        get (type_name)
        {
            return this.dict.get (type_name);
        }

        set (type_name, exp_vect)
        {
            this.dict.set (type_name, exp_vect);
        }
    }
    #+end_src

*** cons_exp_t

    #+begin_src js
    class cons_exp_t
    {
        constructor (type_name)
        {
            this.type_name = type_name;
        }

        exe (env, scope)
        {
            let type_name = this.type_name;
            let type_den = name_dict_get (type_name);
            assert (type_den instanceof type_den_t);
            let field_dict = new field_dict_t ();
            for (let field_name of type_den.reversed_field_name_vect) {
                let obj = data_stack_pop (env);
                field_dict.set (field_name, obj)
            }
            let data_obj = new data_obj_t (type_name, field_dict);
            data_stack_push (env, data_obj);
        }
    }
    #+end_src

*** field_dict_t -- field_name to obj

    #+begin_src js
    class field_dict_t
    {
        constructor ()
        {
            this.dict = new Map ();
        }

        get (field_name)
        {
            return this.dict.get (field_name);
        }

        set (field_name, obj)
        {
            this.dict.set (field_name, obj);
        }
    }
    #+end_src

*** field_exp_t

    #+begin_src js
    class field_exp_t
    {
        constructor (field_name)
        {
            this.field_name = field_name;
        }

        exe (env, scope)
        {
            let data_obj = data_stack_pop (env);
            assert (data_obj instanceof data_obj_t);
            let obj = data_obj.field_dict.get (field_name);
            obj.apply (env);
        }
    }
    #+end_src

*** dot_exp_t

    #+begin_src js
    class dot_exp_t
    {
        constructor (reversed_field_name_vect,
                     dot_clause_map)
        {
            this.reversed_field_name_vect
                = reversed_field_name_vect;
            this.dot_clause_map
                = dot_clause_map;
        }

        exe (env, scope)
        {
            let field_dict = new field_dict_t ();
            for (let field_name of this.reversed_field_name_vect) {
                let obj = data_stack_pop (env);
                field_dict.set (field_name, obj)
            }
            for (let [field_name, exp_vect] of this.dot_clause_map) {
                let obj = exp_vect_to_obj (exp_vect);
                field_dict.set (field_name, obj)
            }
            let dot_obj = new dot_obj_t (field_dict);
            data_stack_push (env, dot_obj);
        }
    }
    #+end_src

*** create_exp_t

    #+begin_src js
    class create_exp_t
    {
        constructor (type_name)
        {
            this.type_name = type_name;
        }

        exe (env, scope)
        {
            let dot_obj = data_stack_pop (env);
            assert (dot_obj instanceof dot_obj_t);
            let data_obj =
                new data_obj_t (this.type_name, dot_obj.field_dict);
            data_stack_push (env, data_obj);
        }
    }
    #+end_src

*** >< clone_exp_t

    #+begin_src js
    class clone_exp_t
    {
        constructor () { }

        exe (env, scope)
        {

        }
    }
    #+end_src

* obj -- object

*** data_obj_t

    #+begin_src js
    class data_obj_t
    {
        constructor (type_name, field_dict)
        {
            this.type_name = type_name;
            this.field_dict = field_dict;
        }

        apply (env)
        {
            data_stack_push (env, this);
        }
    }
    #+end_src

*** dot_obj_t

    #+begin_src js
    class dot_obj_t
    {
        constructor (field_dict)
        {
            this.field_dict = field_dict;
        }

        apply (env)
        {
            data_stack_push (env, this);
        }
    }
    #+end_src

*** clo_obj_t

    #+begin_src js
    class clo_obj_t
    {
        constructor (exp_vect, scope)
        {
            this.type_name = "$arrow-t";
            this.exp_vect = exp_vect;
            this.scope = scope;
        }

        apply (env)
        {
            let frame = new scoping_frame_t (this.exp_vect);
            frame_stack_push (env, frame);
            scope_stack_push (env, this.scope);
        }
    }
    #+end_src

* den -- denotation

*** union_den_t

    #+begin_src js
    class union_den_t
    {
        constructor (union_vect)
        {
            this.union_vect = union_vect;
        }

        den_exe (env)
        {
            error ();
        }
    }
    #+end_src

*** type_den_t

    #+begin_src js
    class type_den_t
    {
        constructor (reversed_field_name_vect)
        {
            this.reversed_field_name_vect
                = reversed_field_name_vect;
        }

        den_exe (env)
        {
            error ();
        }
    }
    #+end_src

*** fun_den_t

    #+begin_src js
    class fun_den_t
    {
        constructor (exp_vect)
        {
            this.exp_vect = exp_vect;
        }

        den_exe (env)
        {
            let frame = new scoping_frame_t (this.exp_vect);
            let scope = new scope_t ();
            frame_stack_push (env, frame);
            scope_stack_push (env, scope);
        }
    }
    #+end_src

*** sig_den_t

    #+begin_src js
    class sig_den_t
    {
        constructor (input_arity, output_arity)
        {
            this.input_arity = input_arity;
            this.output_arity = output_arity;
            this.gene_dict = new gene_dict_t ();
        }

        den_exe (env)
        {
            let type_name_vect = [];
            let counter = 0;
            while (counter < this.input_arity) {
                let obj = data_stack_peek (env, counter);
                type_name_vect.unshift (obj.type_name);
                counter = counter + 1;
            }
            let gene_den = this.gene_dict.get (type_name_vect);
            assert (gene_den);
            gene_den.gene_den_exe (env, type_name_vect);
        }
    }
    #+end_src

*** gene_dict_t -- type_name_vect to gene_den

    #+begin_src js
    class gene_dict_t
    {
        constructor ()
        {
            this.dict = new Map ();
        }

        get (type_name_vect)
        {
            for (let [key, value] of this.dict) {
                if (type_name_vect_lteq_p
                    (env, type_name_vect, key))
                    return value;
            }
            return undefined;
        }

        set (type_name_vect, gene_den)
        {
            for (let key of this.dict.keys ()) {
                if (vect_eq_p (key, type_name_vect)) {
                    this.dict.set (key, gene_den);
                    return;
                }
            }
            this.dict.set (type_name_vect, gene_den)
        }
    }
    #+end_src

*** type_name_vect_lteq_p

    #+begin_src js
    function type_name_vect_lteq_p (env, v1, v2)
    {
        for (let [t1, t2] of [v1, v2]) {
            if (type_name_lteq_p (env, t1, t2))
                return false;
        }
        return true;
    }
    #+end_src

*** type_name_lteq_p

    #+begin_src js
    function type_name_lteq_p (env, t1, t2)
    {
        if (t1 === t2)
            return true;
        let union_den = name_dict_get (env, t2);
        if (! union_den instanceof union_den_t)
            return false;
        if (t1 in union_den.union_vect)
            return true;
        else
            return false;
    }
    #+end_src

*** gene_den_t

    #+begin_src js
    class gene_den_t
    {
        constructor (default_fun_den)
        {
            this.default_fun_den = default_fun_den;
            this.disp_dict = new disp_dict_t ();
        }

        gene_den_exe (env, type_name_vect)
        {
            let fun_den = this.disp_dict.get (type_name_vect);
            if (fun_den)
                fun_den.den_exe (env);
            else
                this.default_fun_den.den_exe (env);
        }
    }
    #+end_src

*** disp_dict_t -- type_name_vect to fun_den

    #+begin_src js
    class disp_dict_t
    {
        constructor ()
        {
            this.dict = new Map ();
        }

        get (type_name_vect)
        {
            for (let [key, value] of this.dict) {
                if (vect_equal_p (type_name_vect, key))
                    return value;
            }
            return undefined;
        }

        set (type_name_vect, fun_den)
        {
            for (let key of this.dict.keys ()) {
                if (vect_equal_p (key, type_name_vect)) {
                    this.dict.set (key, fun_den);
                    return;
                }
            }
            this.dict.set (type_name_vect, fun_den)
        }
    }
    #+end_src

* >< sexp -- string expression

*** ><

* >< prim -- primitive

*** string_t

* >< interpret

*** >< interpret_code

    #+begin_src js
    function interpret_code (env, code)
    {

    }
    #+end_src

*** >< interpret_sexp_vect

    #+begin_src js
    function interpret_sexp_vect (env, sexp_vect)
    {

    }
    #+end_src

*** >< interpret_sexp

    #+begin_src js
    function interpret_sexp (env, sexp)
    {

    }
    #+end_src

* epilog

*** main

*** test

    #+begin_src js
    function test ()
    {
        let env = new env_t ();

        let fun_den = new fun_den_t (
            [
                new set_exp_t ("x"),
                new get_exp_t ("x"),
                new get_exp_t ("x"),
            ]
        );

        data_stack_push (env, new data_obj_t ("nat", "><><><"));
        scope_stack_push (env, new scope_t ());
        name_dict_set (env, "dup", fun_den);
        exp_vect_eval (env, [
            new call_exp_t ("dup"),
        ]);
        print (env);
    }

    test ();

    function test_many ()
    {
        let counter = 0;
        while (counter < 1000000) {
            test ();
            counter = counter + 1;
        }
    }

    // test_many ();
    #+end_src
