#+property: tangle cicada.cn
#+title: cicada

* [todo-stack]

*** the kind of trunks

    - kind of trunks must close under exe

    - we also need the following [at least] :
      - field-trunk-obj-t
      - apply-trunk-obj-t

*** type constructor can occur in function body

    - type constructor need field_name too

*** eq-p in unification

*** about return value of unification and error report

*** unification digraph

    - what is its property ?
      [note that only hypo can be bound to]

    - what is its interface ?

*** need gc on proxies

* [note]

*** mutual recursive

    - exe call infer through ante-prepare
    - infer call cut on closure-obj-t
    - cut call infer on non den-u

    ------

    - thus it is hard to incrementally test this implementation

*** hypothetically constructed object

    - in oop,
      when you ask for a new object of a class,
      the init function of the class is used
      to form an object of that class.
      [the init function might takes arguments]

    - in cicada,
      when you ask for a new object of a type,

      1. the type might has many data-constructors,
         we do not know
         which data-constructors should be used,
         thus a hypo will be created.

      2. the type might has only one data-constructor.
         but it takes arguments,
         we do not have the arguments yet,
         thus a hypo will be created.

*** todo-case-t to done-case-t

    - every time we amend a hypo-obj-t's value

    - then, every time we see a todo-case-t
      we know we can not change it to a done-case-t yet
      because we already tried

*** ffi

    - to handle ffi,
      primitive function must can be applied to hypo-obj,
      and return new proxy obj.

      thus I do not implement this feature for now.

* prolog

*** bool

***** bool-u

      #+begin_src cicada
      (+union bool-u
        true-t
        false-t)
      #+end_src

***** true-t

      #+begin_src cicada
      (+data true-t)
      #+end_src

***** false-t

      #+begin_src cicada
      (+data false-t)
      #+end_src

*** nat

***** nat-u

      #+begin_src cicada
      (+union nat-u
        zero-t
        succ-t)
      #+end_src

***** zero-t

      #+begin_src cicada
      (+data zero-t)
      #+end_src

***** succ-t

      #+begin_src cicada
      (+data succ-t
        prev : nat-u)
      #+end_src

*** >< list

***** list-u

      #+begin_src cicada

      #+end_src

***** null-u

      #+begin_src cicada

      #+end_src

***** cons-u

      #+begin_src cicada

      #+end_src

*** >< dict

***** dict-t

      #+begin_src cicada

      #+end_src

* env -- environment

*** env-t

    #+begin_src cicada
    (+data env-t
      name-dict : [string-t den-u dict-t]
      data-stack : [obj-u list-u]
      frame-stack : [frame-u list-u]
      scope-stack : [string-t obj-u dict-t list-u]
      goal-stack : [goal-t list-u]
      hypo-dict : [string-t obj-u dict-t]
      case-trunk-dict : [string-t case-trunk-u dict-t])
    #+end_src

*** name-dict

***** name-dict/get

      #+begin_src cicada
      (+fun name-dict/get
        : (-> env-t (: name string-t) -- env-t den-u)
        dup .name-dict name dict/get)
      #+end_src

*** data-stack

***** data-stack/push

      #+begin_src cicada
      (+fun data-stack/push
        : (-> (: env env-t) (: obj obj-u) -- env-t)
        (. data-stack = [obj env.data-stack cons])
        env clone)
      #+end_src

***** data-stack/pop

      #+begin_src cicada
      (+fun data-stack/pop
        : (-> (: env env-t) -- env-t obj-u)
        (. data-stack = [env.data-stack.cdr])
        env clone
        env.data-stack.car)
      #+end_src

***** data-stack/drop

      #+begin_src cicada
      (+fun data-stack/drop
        : (-> env-t -- env-t)
        data-stack/pop drop)
      #+end_src

***** data-stack/tos

      #+begin_src cicada
      (+fun data-stack/tos
        : (-> env-t -- env-t obj-u)
        dup .data-stack.car)
      #+end_src

*** frame-stack

***** frame-stack/push

      #+begin_src cicada
      (+fun frame-stack/push
        : (-> (: env env-t) (: frame frame-u) -- env-t)
        (. frame-stack = [frame env.frame-stack cons])
        env clone)
      #+end_src

***** frame-stack/pop

      #+begin_src cicada
      (+fun frame-stack/pop
        : (-> (: env env-t) -- env-t frame-u)
        (. frame-stack = [env.frame-stack.cdr])
        env clone
        env.frame-stack.car)
      #+end_src

***** frame-stack/drop

      #+begin_src cicada
      (+fun frame-stack/drop
        : (-> env-t -- env-t)
        frame-stack/pop drop)
      #+end_src

***** frame-stack/tos

      #+begin_src cicada
      (+fun frame-stack/tos
        : (-> env-t -- env-t frame-u)
        dup .frame-stack.car)
      #+end_src

*** frame

***** frame-u

      #+begin_src cicada
      (+union frame-u
        scoping-frame-t
        simple-frame-t)
      #+end_src

***** scoping-frame-t

      #+begin_src cicada
      (+data scoping-frame-t
        body-exp-list : [exp-u list-u]
        index : nat-u)
      #+end_src

***** new/scoping-frame

      #+begin_src cicada
      (+fun new/scoping-frame
        : (-> (: body-exp-list exp-u list-u) -- scoping-frame-t)
        (. body-exp-list = body-exp-list
           index = 0)
        scoping-frame-cr)
      #+end_src

***** simple-frame-t

      #+begin_src cicada
      (+data simple-frame-t
        body-exp-list : [exp-u list-u]
        index : nat-u)
      #+end_src

***** new/simple-frame

      #+begin_src cicada
      (+fun new/simple-frame
        : (-> (: body-exp-list exp-u list-u) -- simple-frame-t)
        (. body-exp-list = body-exp-list
           index = 0)
        simple-frame-cr)
      #+end_src

*** scope-stack

***** >< scope-stack/push

***** >< scope-stack/pop

***** >< scope-stack/drop

***** >< scope-stack/tos

***** scope/get

      #+begin_src cicada
      (+fun scope/get dict/get)
      #+end_src

***** scope/set

      #+begin_src cicada
      (+fun scope/set
        : (-> string-t obj-u dict-t
              (: local-name string-t)
              (: obj obj-u)
           -- string-t obj-u dict-t)
        (dict local-name obj)
        dict-update)
      #+end_src

*** scope

***** new/scope

      #+begin_src cicada
      (+fun new/scope
        : (-> -- string-t obj-u dict-t)
        (dict))
      #+end_src

*** goal-stack

*** hypo-dict

*** case-trunk-dict

* exp

*** exp-u

    #+begin_src cicada
    (+union exp-u
      call-exp-t
      let-exp-t
      closure-exp-t
      arrow-exp-t
      apply-exp-t
      case-exp-t
      sum-exp-t
      construct-exp-t
      field-exp-t
      colon-exp-t
      double-colon-exp-t)
    #+end_src

*** call-exp-t

    #+begin_src cicada
    (+data call-exp-t
      name : string-t)
    #+end_src

*** let-exp-t

    #+begin_src cicada
    (+data let-exp-t
      local-name-list : [string-t list-u])
    #+end_src

*** closure-exp-t

    #+begin_src cicada
    (+data closure-exp-t
      body-exp-list : [exp-u list-u])
    #+end_src

*** arrow-exp-t

    #+begin_src cicada
    (+data arrow-exp-t
      ante-exp-list : [exp-u list-u]
      succ-exp-list : [exp-u list-u])
    #+end_src

*** apply-exp-t

    #+begin_src cicada
    (+data apply-exp-t)
    #+end_src

*** case-exp-t

    #+begin_src cicada
    (+data case-exp-t
      arg-exp-list : [exp-u list-u]
      closure-exp-dict : [string-t closure-exp-t dict-t])
    #+end_src

*** sum-exp-t

    #+begin_src cicada
    (+data sum-exp-t
      sub-exp-list-list : [exp-u list-u list-u])
    #+end_src

*** construct-exp-t

    #+begin_src cicada
    (+data construct-exp-t
      type-name : string-t)
    #+end_src

*** field-exp-t

    #+begin_src cicada
    (+data field-exp-t
      field-name : string-t)
    #+end_src

*** colon-exp-t

    #+begin_src cicada
    (+data colon-exp-t
      local-name : string-t
      type-exp-list : [exp-u list-u])
    #+end_src

*** double-colon-exp-t

    #+begin_src cicada
    (+data double-colon-exp-t
      local-name : string-t
      type-exp-list : [exp-u list-u])
    #+end_src

* den

*** den-u

    #+begin_src cicada
    (+union den-u
      fun-den-t
      type-den-t
      union-den-t)
    #+end_src

*** fun-den-t

    #+begin_src cicada
    (+data fun-den-t
      type-arrow-exp : arrow-exp-t
      body-exp-list : [exp-u list-u])
    #+end_src

*** type-den-t

    #+begin_src cicada
    (+data type-den-t
      type-arrow-exp : arrow-exp-t
      cons-arrow-exp : arrow-exp-t)
    #+end_src

*** union-den-t

    #+begin_src cicada
    (+data union-den-t
      type-arrow-exp : arrow-exp-t
      type-name-list : [string-t list-u])
    #+end_src

* obj

*** obj-u

    #+begin_src cicada
    (+union obj-u
      #:with type-u
      data-obj-t
      closure-obj-t
      hypo-obj-t
      case-trunk-obj-t)
    #+end_src

*** data-obj-t

    #+begin_src cicada
    (+data data-obj-t
      type : type-u
      field-obj-dict : [string-t obj-u dict-t])
    #+end_src

*** closure-obj-t

    #+begin_src cicada
    (+data closure-obj-t
      scope : [string-t obj-u dict-t]
      body-exp-list : [exp-u list-u])
    #+end_src

*** hypo-obj-t

    #+begin_src cicada
    (+data hypo-obj-t
      hypo-id : string-t
      hypo-type : hypo-type-t)
    #+end_src

*** case-trunk-obj-t

    #+begin_src cicada
    (+data case-trunk-obj-t
      case-trunk-id : string-t)
    #+end_src

*** case-trunk-u

    #+begin_src cicada
    (+union case-trunk-u
      todo-case-trunk-t
      done-case-trunk-t)

    (+data todo-case-trunk-t
      sum-type : sum-type-t
      arg-obj : obj-u
      closure-obj-dict : [string-t closure-obj-t dict-t])

    (+data done-case-trunk-t
      type : type-u
      result-obj : obj-u)
    #+end_src

* type

*** type-u

    #+begin_src cicada
    (+union type-u
      data-type-t
      type-type-t
      hypo-type-t
      arrow-type-t
      sum-type-t)
    #+end_src

*** data-type-t

    #+begin_src cicada
    (+data data-type-t
      type-name : string-t
      field-obj-dict : [string-t obj-u dict-t])
    #+end_src

*** type-type-t

    #+begin_src cicada
    (+data type-type-t
      level : nat-u)
    #+end_src

*** hypo-type-t

    #+begin_src cicada
    (+data hypo-type-t
      hypo-id : string-t
      type : type-u)
    #+end_src

*** arrow-type-t

    #+begin_src cicada
    (+data arrow-type-t
      ante-type-list : [type-u list-u]
      succ-type-list : [type-u list-u])
    #+end_src

*** sum-type-t

    #+begin_src cicada
    (+data sum-type-t
      sub-type-list : [type-u list-u])
    #+end_src

* exe

*** exe

    #+begin_src cicada
    (+fun exe
      : (-> env-t exp-u -- env-t)
      ;; ><><><
      ;; must handle :
      ;;   hypo-obj-t
      ;;   case-trunk-obj-t
      ;;   sum-type-t
      (case dup
        (call-exp-t call-exp/exe)
        (let-exp-t let-exp/exe)
        (closure-exp-t closure-exp/exe)
        (arrow-exp-t arrow-exp/exe)
        (apply-exp-t apply-exp/exe)
        (case-exp-t case-exp/exe)
        (sum-exp-t sum-exp/exe)
        (construct-exp-t construct-exp/exe)
        (field-exp-t field-exp/exe)
        (colon-exp-t colon-exp/exe)
        (double-colon-exp-t double-colon-exp/exe)))
    #+end_src

*** call-exp/exe

    #+begin_src cicada
    (+fun call-exp/exe
      : (-> env-t (: exp call-exp-t) -- env-t)
      exp.name name-dict/get den-exe)
    #+end_src

*** let-exp/exe

    #+begin_src cicada
    (+fun let-exp/exe
      : (-> env-t (: exp let-exp-t) -- env-t)
      exp.local-name-list list-reverse
      let-exp/exe/loop)
    #+end_src

*** let-exp/exe/loop

    #+begin_src cicada
    (+fun let-exp/exe/loop
      : (-> env-t (: local-name-list string-t list-u) -- env-t)
      (case local-name-list
        (null-t)
        (cons-t
          data-stack/pop (let obj)
          scope-stack/pop
          local-name-list.car obj scope/set
          scope-stack/push
          local-name-list.cdr recur)))
    #+end_src

*** closure-exp/exe

    #+begin_src cicada
    (+fun closure-exp/exe
      : (-> env-t (: exp closure-exp-t) -- env-t)
      (. scope = scope-stack/tos
         body-exp-list = [exp.body-exp-list])
      closure-obj-cr
      data-stack/push)
    #+end_src

*** arrow-exp/exe

    #+begin_src cicada
    (+data arrow-exp/exe
      : (-> env-t (: exp arrow-exp-t) -- env-t)
      ;; calling collect-list
      ;;   might effect current scope
      (. ante-type-list = [exp.ante-exp-list collect-list]
         succ-type-list = [exp.succ-exp-list collect-list])
      arrow-type-cr
      data-stack/push)
    #+end_src

*** apply-exp/exe

    #+begin_src cicada
    (+data apply-exp/exe
      : (-> env-t (: exp apply-exp-t) -- env-t)
      data-stack/pop (let obj)
      (case obj
        (closure-obj-t
          obj.scope scope-stack/push
          obj.body-exp-list new/scoping-frame frame-stack/push)
        ;; ><><><
        ;; no apply-trunk for now
        ;;   thus case-trunk-obj-t and hypo-obj-t
        ;;   are not handled
        (else obj data-stack/push)))
    #+end_src

*** ><><>< case-exp/exe

    #+begin_src cicada
    (+data case-exp/exe
      : (-> env-t (: exp case-exp-t) -- env-t)
      ;; calling collect
      ;;   might effect current scope
      exp.arg-exp-list collect (let obj)
      obj infer (let type)
      ;; exp.closure-exp-dict
      (case type
        (data-type-t)
        (sum-type-t)
        (hypo-type-t)
        (type-type-t error)
        (arrow-type-t error)))
    #+end_src

*** sum-exp/exe

    #+begin_src cicada
    (+fun sum-exp/exe
      : (-> env-t (: exp sum-exp-t) -- env-t)
      )
    #+end_src

*** construct-exp/exe

    #+begin_src cicada
    (+data construct-exp/exe
      : (-> env-t (: exp construct-exp-t) -- env-t)
      )
    #+end_src

*** field-exp/exe

    #+begin_src cicada
    (+data field-exp/exe
      : (-> env-t (: exp field-exp-t) -- env-t)
      )
    #+end_src

*** colon-exp/exe

    #+begin_src cicada
    (+data colon-exp/exe
      : (-> env-t (: exp colon-exp-t) -- env-t)
      )
    #+end_src

*** double-colon-exp/exe

    #+begin_src cicada
    (+data double-colon-exp/exe
      : (-> env-t (: exp double-colon-exp-t) -- env-t)
      )
    #+end_src

* run

* collect

*** collect-list

    #+begin_src cicada
    (+fun collect-list
      : (-> env-t (: exp-list exp-u list-u)
         -- env-t obj-u list-u)
      )
    #+end_src

*** collect

    #+begin_src cicada
    (+fun collect
      : (-> env-t (: exp-list exp-u list-u)
         -- env-t obj-u)
      )
    #+end_src

* cut

*** cut

    #+begin_src cicada
    (+fun cut
      : (-> env-t exp-u -- env-t)
      ;; ><><><
      ;; must handle :
      ;;   hypo-obj-t
      ;;   case-trunk-obj-t
      ;;   sum-type-t
      (case dup
        (call-exp-t call-exp/cut)
        (let-exp-t let-exp/cut)
        (closure-exp-t closure-exp/cut)
        (arrow-exp-t arrow-exp/cut)
        (apply-exp-t apply-exp/cut)
        (case-exp-t case-exp/cut)
        (sum-exp-t sum-exp/cut)
        (construct-exp-t construct-exp/cut)
        (field-exp-t field-exp/cut)
        (colon-exp-t colon-exp/cut)
        (double-colon-exp-t double-colon-exp/cut)))
    #+end_src

*** call-exp/cut

*** let-exp/cut

*** closure-exp/cut

*** arrow-exp/cut

*** apply-exp/cut

*** case-exp/cut

*** sum-exp/cut

*** construct-exp/cut

*** field-exp/cut

*** colon-exp/cut

*** double-colon-exp/cut

* den-exe

*** den-exe

    #+begin_src cicada
    (+fun den-exe
      : (-> env-t den-u -- env-t)
      (case dup
        (fun-den-t fun-den/den-exe)
        (type-den-t type-den/den-exe)
        (union-den-t union-den/den-exe)))
    #+end_src

*** fun-den/den-exe

    #+begin_src cicada
    (+fun fun-den/den-exe
      : (-> env-t (: den fun-den-t) -- env-t)
      new/scope scope-stack/push
      den.type-arrow-exp collect (let arrow-type)
      arrow-type.ante-type-list ante-type-list/prepare
      arrow-type.ante-type-list ante-type-list/correspond
      den.body-exp-list new/scoping-frame frame-stack/push)
    #+end_src

*** >< ante-type-list/prepare

    #+begin_src cicada
    (+fun ante-type-list/prepare
      : (-> env-t (: ante-type-list type-u list-u) -- env-t)
      )
    #+end_src

*** >< ante-type-list/correspond

    #+begin_src cicada
    (+fun ante-type-list/correspond
      : (-> env-t (: ante-type-list type-u list-u) -- env-t)
      )
    #+end_src

*** type-den/den-exe

    #+begin_src cicada
    (+fun type-den/den-exe
      : (-> env-t (: den type-den-t) -- env-t)
      )
    #+end_src

*** >< union-den/den-exe

    #+begin_src cicada
    (+fun union-den/den-exe
      : (-> env-t (: den union-den-t) -- env-t)
      )
    #+end_src

* den-cut

*** den-cut

    #+begin_src cicada
    (+fun den-cut
      : (-> env-t den-u -- env-t)
      (case dup
        (fun-den-t fun-den/den-cut)
        (type-den-t type-den/den-cut)
        (union-den-t union-den/den-cut)))
    #+end_src

*** fun-den/den-cut

    #+begin_src cicada
    (+fun fun-den/den-cut
      : (-> env-t (: den fun-den-t) -- env-t)
      ;; must create a new scope
      ;;   before creating an arrow-type
      ;; because creating an arrow-type
      ;;   might effect current scope
      )
    #+end_src

*** >< type-den/den-cut

    #+begin_src cicada
    (+fun type-den/den-cut
      : (-> env-t (: den type-den-t) -- env-t)
      )
    #+end_src

*** >< union-den/den-cut

    #+begin_src cicada
    (+fun union-den/den-cut
      : (-> env-t (: den union-den-t) -- env-t)
      )
    #+end_src

* infer

* unfiy

* cover

* check
