#+property: tangle cicada-script.cs
#+title: cicada-language

* [todo-stack]

*** scope-t

*** parse

*** interface to cicada-script by macro

*** test exe

*** fix exp-list/let-colon

    - for binding not at tail

* [todo-list]

*** eq-p in unification

*** about return value of unification and error report

*** unification digraph

    - what is its property ?
      [note that only var can be bound to]

    - what is its interface ?

*** need gc on proxies

* [note]

*** type constructor

    - type constructors can not occur in function body

*** (case)

    - bad points :
      1. (case) can only occur at tail
      2. can not cut case-exp-t
         case-exp-t is handled by checker
      3. can not infer closure with (case)

    - good points :
      1. (case) can return multiple values

*** mutual recursive

    - exe call infer through ante-prepare
    - infer call cut on closure-obj-t
    - cut call infer on non den-u

    ------

    - thus it is hard to incrementally test this implementation

*** hypothetically constructed object

    - in oop,
      when you ask for a new object of a class,
      the init function of the class is used
      to form an object of that class.
      [the init function might takes arguments]

    - in cicada,
      when you ask for a new object of a type,

      1. the type might has many data-constructors,
         we do not know
         which data-constructors should be used,
         thus a hypo will be created.

      2. the type might has only one data-constructor.
         but it takes arguments,
         we do not have the arguments yet,
         thus a hypo will be created.

*** todo to done

    - every time we change a hypo

    - then, every time we see a todo-case-t
      we know we can not change it to a done-case-t yet
      because we already tried

*** ffi

    - to handle ffi,
      primitive function must can be applied to trunks,
      and return new todo obj.

      thus I do not implement this feature for now.

* prolog

*** dummy :

    #+begin_src cicada
    (+fun :)
    #+end_src

*** dummy (+alias)

    #+begin_src cicada
    (+macro +alias note)
    #+end_src

*** (->) to (let)

    #+begin_src cicada
    (+macro -> (let body)
      body {'-- eq-p} list/ante
      {', eq-p bool/not} list/filter
      sexp/filter-colon (let new-body)
      `(let (@ new-body list/spread)))
    #+end_src

*** sexp/filter-colon

    #+begin_src cicada
    (+fun sexp/filter-colon (let ante)
      (case ante
        (null-t null-c)
        (cons-t
          (case ante.cdr
            (null-t null-c)
            (cons-t
              (if [ante.cdr.car ': eq-p]
                [ante.car ante.cdr.cdr.cdr recur cons-c]
                [ante.cdr recur]))))))
    #+end_src

*** (+type) to (+data)

    #+begin_src cicada
    (+macro +type (let body)
       body.car (let name)
       body.cdr (let rest)
      `(+data (@ name) (@ rest sexp/filter-colon list/spread)))
    #+end_src

* env

*** env-t

    #+begin_src cicada
    (+type env-t
      name-dict : [string-t den-u dict-t]
      data-stack : [obj-u list-u]
      frame-stack : [frame-u list-u]
      scope-stack : [string-t obj-u dict-t list-u]
      goal-stack : [goal-t list-u]
      data-bind-dict : [hypo-id-t obj-u dict-t]
      type-bind-dict : [hypo-id-t obj-u dict-t])
    #+end_src

*** new/env

    #+begin_src cicada
    (+fun new/env
      : (-> -- env-t)
      (lit/dict)
      (lit/list)
      (lit/list)
      (lit/list)
      (lit/list)
      (lit/dict)
      (lit/dict)
      (. name-dict
         data-stack
         frame-stack
         scope-stack
         goal-stack
         data-bind-dict
         type-bind-dict)
      env-cr)
    #+end_src

*** name-dict

***** name-dict/get

      #+begin_src cicada
      (+fun name-dict/get
        : (-> env-t, name : string-t -- env-t den-u)
        dup .name-dict name dict/get)
      #+end_src

***** name-dict/insert

      #+begin_src cicada
      (+fun name-dict/insert
        : (-> env : env-t, name : string-t, den : den-u -- env-t)
        env.name-dict name den dict/insert
        (. name-dict)
        env clone)
      #+end_src

*** data-stack

***** data-stack/push

      #+begin_src cicada
      (+fun data-stack/push
        : (-> env : env-t, obj : obj-u -- env-t)
        obj env.data-stack cons-c
        (. data-stack)
        env clone)
      #+end_src

***** data-stack/pop

      #+begin_src cicada
      (+fun data-stack/pop
        : (-> env : env-t -- env-t obj-u)
        env.data-stack.cdr
        (. data-stack)
        env clone
        env.data-stack.car)
      #+end_src

***** data-stack/drop

      #+begin_src cicada
      (+fun data-stack/drop
        : (-> env-t -- env-t)
        data-stack/pop drop)
      #+end_src

***** data-stack/tos

      #+begin_src cicada
      (+fun data-stack/tos
        : (-> env-t -- env-t obj-u)
        dup .data-stack.car)
      #+end_src

***** data-stack/n-pop

      #+begin_src cicada
      (+fun data-stack/n-pop
        : (-> env-t, number-t
           -- env-t, obj-u list-u)
        null-c data-stack/n-pop-to-list)

      (+fun data-stack/n-pop-to-list
        : (-> env-t, n : number-t, list : [obj-u list-u]
           -- env-t, obj-u list-u)
        (if [n 0 lteq-p]
          list
          [data-stack/pop list cons-c
           n dec swap recur]))
      #+end_src

***** data-stack/list-push

      #+begin_src cicada
      (+fun data-stack/list-push
        : (-> env-t, list : [obj-u list-u]
           -- env-t)
        (case list
          (null-t)
          (cons-t
            list.car data-stack/push
            list.cdr recur)))
      #+end_src

*** frame-stack

***** frame-stack/push

      #+begin_src cicada
      (+fun frame-stack/push
        : (-> env : env-t, frame : frame-u -- env-t)
        frame env.frame-stack cons-c
        (. frame-stack)
        env clone)
      #+end_src

***** frame-stack/pop

      #+begin_src cicada
      (+fun frame-stack/pop
        : (-> env : env-t -- env-t frame-u)
        env.frame-stack.cdr
        (. frame-stack)
        env clone
        env.frame-stack.car)
      #+end_src

***** frame-stack/drop

      #+begin_src cicada
      (+fun frame-stack/drop
        : (-> env-t -- env-t)
        frame-stack/pop drop)
      #+end_src

***** frame-stack/tos

      #+begin_src cicada
      (+fun frame-stack/tos
        : (-> env-t -- env-t frame-u)
        dup .frame-stack.car)
      #+end_src

*** frame

***** frame-u

      #+begin_src cicada
      (+union frame-u
        scoping-frame-t
        simple-frame-t)
      #+end_src

***** scoping-frame-t

      #+begin_src cicada
      (+type scoping-frame-t
        body-exp-list : [exp-u list-u]
        index : number-t)
      #+end_src

***** new/scoping-frame

      #+begin_src cicada
      (+fun new/scoping-frame
        : (-> body-exp-list : [exp-u list-u] -- scoping-frame-t)
        body-exp-list 0
        (. body-exp-list index)
        scoping-frame-cr)
      #+end_src

***** simple-frame-t

      #+begin_src cicada
      (+type simple-frame-t
        body-exp-list : [exp-u list-u]
        index : number-t)
      #+end_src

***** new/simple-frame

      #+begin_src cicada
      (+fun new/simple-frame
        : (-> body-exp-list : [exp-u list-u] -- simple-frame-t)
        body-exp-list 0
        (. body-exp-list index)
        simple-frame-cr)
      #+end_src

***** top-frame-finished-p

      #+begin_src cicada
      (+fun top-frame-finished-p
        : (-> env-t -- env-t bool-u)
        frame-stack-tos (let frame)
        frame.index frame.body-exp-list list-length eq-p)
      #+end_src

***** top-frame-next-exp

      #+begin_src cicada
      (+fun top-frame-next-exp
        : (-> env-t -- env-t exp-u)
        frame-stack-pop (let frame)
        frame.index number-inc
        (. index)
        frame clone
        frame-stack-push
        frame.body-exp-list frame.index list-ref)
      #+end_src

*** scope-stack

***** scope-stack/push

      #+begin_src cicada
      (+fun scope-stack/push
        : (-> env : env-t
              scope : [string-t obj-u dict-t]
           -- env-t)
        scope env.scope-stack cons-c
        (. scope-stack)
        env clone)
      #+end_src

***** scope-stack/pop

      #+begin_src cicada
      (+fun scope-stack/pop
        : (-> env : env-t -- env-t [string-t obj-u dict-t])
        env.scope-stack.cdr
        (. scope-stack)
        env clone
        env.scope-stack.car)
      #+end_src

***** scope-stack/drop

      #+begin_src cicada
      (+fun scope-stack/drop
        : (-> env-t -- env-t)
        scope-stack/pop drop)
      #+end_src

***** scope-stack/tos

      #+begin_src cicada
      (+fun scope-stack/tos
        : (-> env-t -- env-t [string-t obj-u dict-t])
        dup .scope-stack.car)
      #+end_src

***** scope/get

      #+begin_src cicada
      (+fun scope/get dict/get)
      #+end_src

***** scope/insert

      #+begin_src cicada
      (+fun scope/insert
        : (-> string-t obj-u dict-t
              local-name : string-t
              obj : obj-u
           -- string-t obj-u dict-t)
        (lit/dict local-name obj)
        dict-update)
      #+end_src

***** current-scope/insert

      #+begin_src cicada
      (+fun current-scope/insert
        : (-> env-t
              local-name : string-t
              obj : obj-u
           -- env-t)
      scope-stack/pop
      local-name obj scope/insert
      scope-stack/push)
      #+end_src

*** scope

***** new/scope

      #+begin_src cicada
      (+fun new/scope
        : (-> -- string-t obj-u dict-t)
        (lit/dict))
      #+end_src

*** >< goal-stack

*** data-bind-dict

***** data-bind-dict/find

      #+begin_src cicada
      (+fun data-bind-dict/find
        : (-> env-t, hypo-id : hypo-id-t
           -- env-t (| false-t
                       [obj-u true-t]))
        dup .data-bind-dict hypo-id dict/find)
      #+end_src

***** data-bind-dict/insert

      #+begin_src cicada
      (+fun data-bind-dict/insert
        : (-> env : env-t
              hypo-id : hypo-id-t
              obj : obj-u
           -- env-t)
        env.data-bind-dict hypo-id obj dict/insert
        (. data-bind-dict)
        env clone)
      #+end_src

*** type-bind-dict

***** type-bind-dict/find

      #+begin_src cicada
      (+fun type-bind-dict/find
        : (-> env-t, hypo-id : hypo-id-t
           -- env-t (| false-t
                       [obj-u true-t]))
        dup .type-bind-dict hypo-id dict/find)
      #+end_src

***** type-bind-dict/insert

      #+begin_src cicada
      (+fun type-bind-dict/insert
        : (-> env : env-t
              hypo-id : hypo-id-t
              obj : obj-u
           -- env-t)
        env.type-bind-dict hypo-id obj dict/insert
        (. type-bind-dict)
        env clone)
      #+end_src

* exp

*** exp-u

    #+begin_src cicada
    (+union exp-u
      call-exp-t
      let-exp-t
      closure-exp-t
      arrow-exp-t
      apply-exp-t
      case-exp-t
      construct-exp-t
      field-exp-t
      colon-exp-t
      double-colon-exp-t)
    #+end_src

*** call-exp-t

    #+begin_src cicada
    (+type call-exp-t
      name : string-t)
    #+end_src

*** let-exp-t

    #+begin_src cicada
    (+type let-exp-t
      local-name-list : [string-t list-u])
    #+end_src

*** closure-exp-t

    #+begin_src cicada
    (+type closure-exp-t
      body-exp-list : [exp-u list-u])
    #+end_src

*** arrow-exp-t

    #+begin_src cicada
    (+type arrow-exp-t
      ante-exp-list : [exp-u list-u]
      succ-exp-list : [exp-u list-u])
    #+end_src

*** apply-exp-t

    #+begin_src cicada
    (+type apply-exp-t)
    #+end_src

*** case-exp-t

    #+begin_src cicada
    (+type case-exp-t
      arg-exp-list : [exp-u list-u]
      closure-exp-dict : [string-t closure-exp-t dict-t])
    #+end_src

*** construct-exp-t

    #+begin_src cicada
    (+type construct-exp-t
      type-name : string-t)
    #+end_src

*** field-exp-t

    #+begin_src cicada
    (+type field-exp-t
      field-name : string-t)
    #+end_src

*** colon-exp-t

    #+begin_src cicada
    (+type colon-exp-t
      local-name : string-t
      type-exp-list : [exp-u list-u])
    #+end_src

*** double-colon-exp-t

    #+begin_src cicada
    (+type double-colon-exp-t
      local-name : string-t
      type-exp-list : [exp-u list-u])
    #+end_src

* den

*** den-u

    #+begin_src cicada
    (+union den-u
      fun-den-t
      type-den-t
      union-den-t)
    #+end_src

*** fun-den-t

    #+begin_src cicada
    (+type fun-den-t
      fun-name : string-t
      type-arrow-exp : arrow-exp-t
      body-exp-list : [exp-u list-u])
    #+end_src

*** type-den-t

    #+begin_src cicada
    (+type type-den-t
      type-name : string-t
      type-arrow-exp : arrow-exp-t
      cons-arrow-exp : arrow-exp-t)
    #+end_src

*** union-den-t

    #+begin_src cicada
    (+type union-den-t
      union-name : string-t
      type-arrow-exp : arrow-exp-t
      type-name-list : [string-t list-u])
    #+end_src

* obj

*** obj-u

    #+begin_src cicada
    (+union obj-u
      data-obj-t data-type-t
      union-type-t
      type-type-t
      closure-obj-t arrow-type-t
      data-hypo-t type-hypo-t)
    #+end_src

*** data-obj-t

    #+begin_src cicada
    (+type data-obj-t
      data-type : data-type-t
      field-obj-dict : [string-t obj-u dict-t])
    #+end_src

*** data-type-t

    #+begin_src cicada
    (+type data-type-t
      type-name : string-t
      field-obj-dict : [string-t obj-u dict-t])
    #+end_src

*** union-type-t

    #+begin_src cicada
    (+type union-type-t
      union-name : string-t
      field-obj-dict : [string-t obj-u dict-t])
    #+end_src

*** type-type-t

    #+begin_src cicada
    (+type type-type-t
      level : number-t)
    #+end_src

*** closure-obj-t

    #+begin_src cicada
    (+type closure-obj-t
      scope : [string-t obj-u dict-t]
      body-exp-list : [exp-u list-u])
    #+end_src

*** arrow-type-t

    #+begin_src cicada
    (+type arrow-type-t
      ante-type-list : [obj-u list-u]
      succ-type-list : [obj-u list-u])
    #+end_src

*** data-hypo-t

    #+begin_src cicada
    (+type data-hypo-t
      id : hypo-id-t)
    #+end_src

*** type-hypo-t

    #+begin_src cicada
    (+type type-hypo-t
      id : hypo-id-t)
    #+end_src

*** hypo-id-t

    #+begin_src cicada
    (+type hypo-id-t
      string : string-t)
    #+end_src

* exe

*** exe

    #+begin_src cicada
    (+fun exe
      : (-> env-t exp-u -- env-t)
      (case dup
        (call-exp-t call-exp/exe)
        (let-exp-t let-exp/exe)
        (closure-exp-t closure-exp/exe)
        (arrow-exp-t arrow-exp/exe)
        (apply-exp-t apply-exp/exe)
        (case-exp-t case-exp/exe)
        (construct-exp-t construct-exp/exe)
        (field-exp-t field-exp/exe)
        (colon-exp-t colon-exp/exe)
        (double-colon-exp-t double-colon-exp/exe)))
    #+end_src

*** call-exp/exe

    #+begin_src cicada
    (+fun call-exp/exe
      : (-> env-t, exp : call-exp-t -- env-t)
      exp.name name-dict/get den-exe)
    #+end_src

*** den-exe

***** den-exe

      #+begin_src cicada
      (+fun den-exe
        : (-> env-t den-u -- env-t)
        (case dup
          (fun-den-t fun-den/den-exe)
          (type-den-t type-den/den-exe)
          (union-den-t union-den/den-exe)))
      #+end_src

***** fun-den/den-exe

      #+begin_src cicada
      (+fun fun-den/den-exe
        : (-> env-t, den : fun-den-t -- env-t)
        new/scope scope-stack/push
        den.type-arrow-exp arrow-exp/extend-scope
        den.type-arrow-exp.ante-exp-list exp-list/let-colon
        den.body-exp-list new/scoping-frame frame-stack/push)
      #+end_src

***** arrow-exp/extend-scope

      #+begin_src cicada
      (+fun arrow-exp/extend-scope
        : (-> env-t, arrow-exp-t -- env-t)
        collect-one drop)
      #+end_src

***** exp-list/let-colon

      #+begin_src cicada
      (+fun exp-list/let-colon
        : (-> env : env-t
              exp-list : [exp-u list-u]
           -- env-t)
        exp-list
        {(let exp)
         (or [exp colon-exp-p]
             [exp colon-exp-p])}
        list/filter
        list/reverse
        {env swap exp/let-colon} list/for-each
        env)
      #+end_src

***** exp/let-colon

      #+begin_src cicada
      (+fun exp/let-colon
        : (-> env-t
              exp : exp-u
           -- env-t)
        data-stack/pop
        exp.local-name swap
        current-scope/insert)
      #+end_src

***** type-den/den-exe

      #+begin_src cicada
      (+fun type-den/den-exe
        : (-> env-t, den : type-den-t -- env-t)
        den.type-arrow-exp.ante-exp-list new/field-obj-dict
        den.type-name
        (. field-obj-dict type-name)
        data-type-cr data-stack/push)
      #+end_src

***** union-den/den-exe

      #+begin_src cicada
      (+fun union-den/den-exe
        : (-> env-t, den : union-den-t -- env-t)
        den.type-arrow-exp.ante-exp-list new/field-obj-dict
        den.union-name
        (. field-obj-dict union-name)
        union-type-cr data-stack/push)
      #+end_src

***** new/field-obj-dict

      #+begin_src cicada
      (+fun new/field-obj-dict
        : (-> env-t
              ante-exp-list : [exp-u list-u]
           -- env-t, string-t obj-u dict-t)
        new/dict ante-exp-list
        ante-exp-list/merge-fields)
      #+end_src

***** ante-exp-list/merge-fields

      #+begin_src cicada
      (+fun ante-exp-list/merge-fields
        : (-> env-t
              field-obj-dict : [string-t obj-u dict-t]
              ante-exp-list : [exp-u list-u]
           -- env-t, string-t obj-u dict-t)
        (case ante-exp-list
          (null-t)
          (cons-t
            (case ante-exp-list.car
              (colon-exp-t
                field-obj-dict
                ante-exp-list.car.local-name
                data-stack/pop dict/insert
                ante-exp-list.cdr recur)
              (else
                field-obj-dict
                ante-exp-list.cdr recur)))))
      #+end_src

*** let-exp/exe

    #+begin_src cicada
    (+fun let-exp/exe
      : (-> env-t, exp : let-exp-t -- env-t)
      exp.local-name-list list-reverse
      let-exp/exe/loop)
    #+end_src

*** let-exp/exe/loop

    #+begin_src cicada
    (+fun let-exp/exe/loop
      : (-> env-t, local-name-list : [string-t list-u] -- env-t)
      (case local-name-list
        (null-t)
        (cons-t
          data-stack/pop (let obj)
          scope-stack/pop
          local-name-list.car obj scope/insert
          scope-stack/push
          local-name-list.cdr recur)))
    #+end_src

*** closure-exp/exe

    #+begin_src cicada
    (+fun closure-exp/exe
      : (-> env-t, exp : closure-exp-t -- env-t)
      scope-stack/tos
      exp.body-exp-list
      (. scope body-exp-list)
      closure-obj-cr
      data-stack/push)
    #+end_src

*** arrow-exp/exe

    #+begin_src cicada
    (+fun arrow-exp/exe
      : (-> env-t, exp : arrow-exp-t -- env-t)
      ;; calling collect-list
      ;;   might effect current scope
      exp.ante-exp-list collect-list (let ante-type-list)
      exp.succ-exp-list collect-list (let succ-type-list)
      (. ante-type-list succ-type-list)
      arrow-type-cr
      data-stack/push)
    #+end_src

*** apply-exp/exe

    #+begin_src cicada
    (+fun apply-exp/exe
      : (-> env-t, exp : apply-exp-t -- env-t)
      data-stack/pop (let obj)
      (case obj
        (closure-obj-t
          obj.scope scope-stack/push
          obj.body-exp-list new/scoping-frame frame-stack/push)))
    #+end_src

*** case-exp/exe

    #+begin_src cicada
    (+fun case-exp/exe
      : (-> env-t, exp : case-exp-t -- env-t)
      ;; calling collect-one
      ;;   might effect current scope
      exp.arg-exp-list collect-one (let obj)
      (case obj
        (data-obj-t
          exp.closure-exp-dict
          obj.data-type.type-name dict/get
          closure-exp/exe
          apply-exp/exe)))
    #+end_src

*** construct-exp/exe

    #+begin_src cicada
    (+fun construct-exp/exe
      : (-> env-t, exp : construct-exp-t -- env-t)
      exp.type-name name-dict/get (let den)
      den.type-arrow-exp arrow-exp/extend-scope
      den.cons-arrow-exp.succ-exp-list collect-one (let return-type)
      den.cons-arrow-exp.ante-exp-list new/field-obj-dict
      return-type
      (. field-obj-dict type)
      data-obj-cr data-stack/push)
    #+end_src

*** field-exp/exe

    #+begin_src cicada
    (+fun field-exp/exe
      : (-> env-t, exp : field-exp-t -- env-t)
      data-stack/pop (let obj)
      (case obj
        (data-obj-t
          obj.field-obj-dict
          exp.field-name dict/get)))
    #+end_src

*** colon-exp/exe

    #+begin_src cicada
    (+fun colon-exp/exe
      : (-> env-t, exp : colon-exp-t -- env-t)
      exp.type-exp-list collect-one (let type)
      exp.local-name generate/hypo-id (let hypo-id)
      hypo-id type-hypo-c
      type type-hypo/insert
      exp.local-name hypo-id data-hypo-c current-scope/insert
      type data-stack/push)
    #+end_src

*** double-colon-exp/exe

    #+begin_src cicada
    (+fun double-colon-exp/exe
      : (-> env-t double-colon-exp-t -- env-t)
      colon-exp/exe
      data-stack/drop)
    #+end_src

*** counter-t

    #+begin_src cicada
    (+type counter-t
      .number : number-t)
    #+end_src

*** new/counter

    #+begin_src cicada
    (+fun new/counter
      : (-> -- counter-t)
      0 counter-c)
    #+end_src

*** counter/inc

    #+begin_src cicada
    (+fun counter/inc
      : (-> counter-t --)
      swap .number!)
    #+end_src

*** counter/number

    #+begin_src cicada
    (+fun counter/number
      : (-> counter-t -- number-t)
      .number)
    #+end_src

*** generate/hypo-id

    #+begin_src cicada
    (+var hypo-id/counter new/counter)

    (+fun generate/hypo-id
      : (-> env-t, base-name : string-t
         -- env-t, hypo-id-t)
      hypo-id/counter counter/number repr (let postfix)
      hypo-id/counter counter/inc
      base-name postfix string-append hypo-id-c)
    #+end_src

* run

*** run-one-step

    #+begin_src cicada
    (+fun run-one-step
      : (-> env-t -- env-t)
      (if top-frame-finished-p
        (case frame-stack-pop
          (scoping-frame-t scope-stack-drop)
          (simple-frame-t))
        [top-frame-next-exp exe]))
    #+end_src

*** run-with-base

    #+begin_src cicada
    (+fun run-with-base
      : (-> env-t, base : number-t -- env-t)
      (unless [dup .frame-stack list-length base eq-p]
        run-one-step base recur))
    #+end_src

*** exp-list/run

    #+begin_src cicada
    (+fun exp-list/run
      : (-> env-t, exp-list : [exp-u list-u] -- env-t)
      dup .frame-stack list-length (let base)
      exp-list new/simple-frame frame-stack/push
      base run-with-base)
    #+end_src

* collect-one

*** collect-list

    #+begin_src cicada
    (+fun collect-list
      : (-> env-t, exp-list : [exp-u list-u]
         -- env-t, obj-u list-u)
      dup .data-stack list-length (let old)
      exp-list exp-list/run
      dup .data-stack list-length (let new)
      new old number-sub data-stack/n-pop)
    #+end_src

*** collect-one

    #+begin_src cicada
    (+fun collect-one
      : (-> env-t, exp-list : [exp-u list-u]
         -- env-t, obj-u)
      exp-list exp-list/run
      data-stack/pop)
    #+end_src

* cut

*** cut

    #+begin_src cicada
    (+fun cut
      : (-> env-t exp-u -- env-t)
      (case dup
        (call-exp-t call-exp/cut)
        (let-exp-t let-exp/cut)
        (closure-exp-t closure-exp/cut)
        (arrow-exp-t arrow-exp/cut)
        (apply-exp-t apply-exp/cut)
        (case-exp-t case-exp/cut)
        (construct-exp-t construct-exp/cut)
        (field-exp-t field-exp/cut)
        (colon-exp-t colon-exp/cut)
        (double-colon-exp-t double-colon-exp/cut)))
    #+end_src

*** call-exp/cut

    #+begin_src cicada
    (+fun call-exp/cut
      : (-> env-t, exp : call-exp-t -- env-t)
      exp.name name-dict/get den-cut)
    #+end_src

*** den-cut

***** den-cut

      #+begin_src cicada
      (+fun den-cut
        : (-> env-t den-u -- env-t)
        (case dup
          (fun-den-t fun-den/den-cut)
          (type-den-t type-den/den-cut)
          (union-den-t union-den/den-cut)))
      #+end_src

***** fun-den/den-cut

      #+begin_src cicada
      (+fun fun-den/den-cut
        : (-> env-t, den : fun-den-t -- env-t)
        den.type-arrow-exp arrow-exp/cut-apply)
      #+end_src

***** arrow-exp/cut-apply

      #+begin_src cicada
      (+fun arrow-exp/cut-apply
        : (-> env-t, arrow-exp : arrow-exp-t -- env-t)
        ;; must create a new scope
        ;;   before creating an arrow-type
        ;; because creating an arrow-type
        ;;   might effect current scope
        new/scope scope-stack/push
        arrow-exp collect-one (let arrow-type)
        arrow-type.ante-type-list ante-type-list/unify
        arrow-type.succ-type-list data-stack/list-push
        scope-stack/drop)
      #+end_src

***** >< ante-type-list/unify

      #+begin_src cicada
      (+fun ante-type-list/unify
        : (-> env-t, ante-type-list : [obj-u list-u] -- env-t)
        )
      #+end_src

***** ><><>< type-den/den-cut

      #+begin_src cicada
      (+fun type-den/den-cut
        : (-> env-t, den : type-den-t -- env-t)
        )
      #+end_src

***** ><><>< union-den/den-cut

      #+begin_src cicada
      (+fun union-den/den-cut
        : (-> env-t, den : union-den-t -- env-t)
        )
      #+end_src

*** let-exp/cut

*** closure-exp/cut

*** arrow-exp/cut

*** apply-exp/cut

*** case-exp/cut

*** construct-exp/cut

*** field-exp/cut

*** colon-exp/cut

*** double-colon-exp/cut

* infer

*** infer

    #+begin_src cicada
    (+fun infer
      : (-> env-t obj-u -- obj-u env-t)
      (case dup
        (data-obj-t data-obj/infer)
        (closure-obj-t closure-obj/infer)
        ;; ><><><
        (obj-u type-infer)))
    #+end_src

*** data-obj/infer

*** closure-obj/infer

*** type-infer

* unfiy

* cover

* check

* pass

* sexp

*** sexp-u

    #+begin_src cicada
    (+alias sexp-u [string-t list-u])
    #+end_src

* parse

*** parse/den

*** parse/exp

    #+begin_src cicada
    (+fun parse/exp
      : (-> sexp-u -- ))
    #+end_src

*** parse/exp-list

* eval

*** >< top-sexp/eval

    #+begin_src cicada
    (+fun top-sexp/eval
      : (-> env-t, sexp : sexp-u -- env-t)
      (case sexp
        ))
    #+end_src

* test

*** (->)

    #+begin_src cicada
    (assert
      1 2
      : (-> num0 : number-t, num1 : number-t -- number-t)
      num0 num1 add
      3 eq-p)
    #+end_src

*** name-dict

    #+begin_src cicada
    (begin
      new/env
      "1" 1 name-dict/insert
      "2" 2 name-dict/insert
      "1" name-dict/get 1 eq-p bool/assert
      "1" name-dict/get 1 eq-p bool/assert
      "2" name-dict/get 2 eq-p bool/assert
      "2" name-dict/get 2 eq-p bool/assert
      drop)
    #+end_src

*** >< data-stack

    #+begin_src cicada
    (begin
      new/env
      0 data-stack/push
      1 data-stack/push
      2 data-stack/push
      3 data-stack/push
      data-stack/pop 3 eq-p bool/assert
      data-stack/pop 2 eq-p bool/assert
      data-stack/tos 1 eq-p bool/assert
      data-stack/tos 1 eq-p bool/assert
      data-stack/tos 1 eq-p bool/assert
      data-stack/drop
      data-stack/pop 0 eq-p bool/assert
      drop)

    (begin
      new/env
      0 data-stack/push
      1 data-stack/push
      2 data-stack/push
      3 data-stack/push
      3 data-stack/n-pop
      (lit/list 1 2 3) eq-p bool/assert
      data-stack/pop 0 eq-p bool/assert
      drop)

    (begin
      new/env
      (lit/list 1 2 3) data-stack/list-push
      data-stack/pop 3 eq-p bool/assert
      data-stack/pop 2 eq-p bool/assert
      data-stack/pop 1 eq-p bool/assert
      drop)
    #+end_src

*** >< frame-stack

*** >< frame

*** scope-stack

    #+begin_src cicada
    (begin
      new/env
      0 scope-stack/push
      1 scope-stack/push
      2 scope-stack/push
      3 scope-stack/push
      scope-stack/pop 3 eq-p bool/assert
      scope-stack/pop 2 eq-p bool/assert
      scope-stack/tos 1 eq-p bool/assert
      scope-stack/tos 1 eq-p bool/assert
      scope-stack/tos 1 eq-p bool/assert
      scope-stack/drop
      scope-stack/pop 0 eq-p bool/assert
      drop)
    #+end_src

*** >< scope

*** data-bind-dict & type-bind-dict

    #+begin_src cicada
    (begin
      new/env
      "1" 1 data-bind-dict/insert
      "2" 2 data-bind-dict/insert
      "1" data-bind-dict/find bool/assert 1 eq-p bool/assert
      "1" data-bind-dict/find bool/assert 1 eq-p bool/assert
      "2" data-bind-dict/find bool/assert 2 eq-p bool/assert
      "2" data-bind-dict/find bool/assert 2 eq-p bool/assert
      drop)

    (begin
      new/env
      "1" 1 type-bind-dict/insert
      "2" 2 type-bind-dict/insert
      "1" type-bind-dict/find bool/assert 1 eq-p bool/assert
      "1" type-bind-dict/find bool/assert 1 eq-p bool/assert
      "2" type-bind-dict/find bool/assert 2 eq-p bool/assert
      "2" type-bind-dict/find bool/assert 2 eq-p bool/assert
      drop)
    #+end_src

* epilog

*** play

    #+begin_src cicada

    #+end_src

*** main

    #+begin_src cicada

    #+end_src
