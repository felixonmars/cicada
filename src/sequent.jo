(+data <env>
  .name-dict : [String Den Dict]
  .data-stack : [Obj List]
  .mark-stack : [Nat List]
  .return-stack : [Frame List]
  .local-stack : [String Obj Dict List]
  .goal-stack : [<goal> List]
  .hypo-dict : [<hypo-id> Obj Dict]
  .matck-dict : [<match-id> Match Dict])

(+jojo name-dict-getget
  : (-> <env> (: :name String) -- <env> Den)
  dup .name-dict :name dict-get)

(+jojo data-stack-push
  : (-> (: :env <env>) (: :obj Obj) -- <env>)
  (clone :env
    .data-stack [:obj :env.data-stack cons]))

(+jojo data-stack-pop
  : (-> (: :env <env>) -- <env> Obj)
  (clone :env
    .data-stack [:env.data-stack.cdr])
  :env.data-stack.car)

(+jojo data-stack-drop
  : (-> <env> -- <env>)
  data-stack-pop drop)

(+jojo data-stack-tos
  : (-> <env> -- <env> Obj)
  dup .data-stack.car)

(+jojo data-stack-n-pop
  : (-> <env> Nat -- <env> Obj List)
  )

(+jojo data-stack-zip-by-list
  : (-> <env> (: :list Any List) -- <env> Any Obj Dict)
  )

(+jojo mark-stack-push
  : (-> (: :env <env>) (: :x Nat) -- <env>)
  (clone :env
    .mark-stack [:x :env.mark-stack cons]))

(+jojo mark-stack-pop
  : (-> (: :env <env>) -- <env> Nat)
  (clone :env
    .mark-stack [:env.mark-stack.cdr])
  :env.mark-stack.car)

(+jojo mark-stack-mark
  : (-> <env> -- <env>)
  dup .data-stack list-length
  mark-stack-push)

(+jojo mark-stack-collect
  : (-> <env> -- <env> Obj List)
  dup .data-stack list-length mark-stack-pop sub
  data-stack-n-pop)

(+union Frame
  <scoping-frame>
  <simple-frame>)

(+data <scoping-frame>
  .body : [Exp List]
  .index : Nat)

(+data <simple-frame>
  .body : [Exp List]
  .index : Nat)

(+jojo return-stack-push
  : (-> (: :env <env>) (: :frame Frame) -- <env>)
  (clone :env
    .return-stack [:frame :env.return-stack cons]))

(+jojo return-stack-pop
  : (-> (: :env <env>) -- <env> Frame)
  (clone :env
    .return-stack [:env.return-stack.cdr])
  :env.return-stack.car)

(+jojo return-stack-drop
  : (-> <env> -- <env>)
  return-stack-pop drop)

(+jojo return-stack-tos
  : (-> <env> -- <env> Frame)
  dup .return-stack.car)

(+jojo top-frame-finished?
  : (-> <env> -- <env> Bool)
  return-stack-tos :frame!
  :frame.index :frame.body list-length eq?)

(+jojo top-frame-next-exp
  : (-> <env> -- <env> Exp)
  return-stack-pop :frame!
  (clone :frame
    .index [:frame.index inc])
  return-stack-push
  :frame.body :frame.index list-ref)

(+jojo local-get dict-get)

(+jojo local-set
  : (-> String Obj Dict
        (: :local-name String)
        (: :obj Obj)
     -- String Obj Dict)
  (dict :local-name :obj)
  dict-update)

(+jojo new-local-scope
  : (-> <env> -- <env>)
  (dict) local-stack-push)

(+data <goal>
  .lhs : [Obj List]
  .rhs : [Obj List]
  .index : Nat)

(+jojo hypo-dict-find
  : (-> <env> <hypo-obj>
     -- <env> (+ Obj true
               | false))
  ><)

(+jojo matck-dict-get
  : (-> <env> <match-obj>
     -- <env> Match)
 ><)

(+jojo new-match-obj
  : (-> <env>
        (: :obj Obj)
        (: :match-exp <match-exp>)
     -- <env>
        <match-obj>)
  (create <todo-match>
    .type [:obj :match-exp new-sum-obj]
    .arg :obj
    .match-exp :match-exp))

(+jojo new-sum-obj
  : (-> <env>
        (: :obj Obj)
        (: :match-exp <match-exp>)
     -- <env> <sum-obj>)
   )

(+union Exp
  <call-exp>

  <get-local-exp>
  <set-local-exp>

  <clo-exp>
  <arrow-exp>
  <match-exp>

  <suppose-exp>
  <dup-exp>
  <infer-exp>
  <apply-exp>)

(+jojo list-eval
  : (-> (: :env <env>) (: :exp-list Exp List) -- <env>)
  :env .return-stack list-length :base!
  (create <simple-frame>
     .body :exp-list
     .index 0)
  return-stack-push
  :env :base eval-with-base)

(+jojo eval-with-base
  : (-> <env> (: :base Nat) -- <env>)
  (when [dup .return-stack list-length :base equal? not]
    eval-one-step :base eval-with-base))

(note it is assumed that
  there is at least one step to exe)

(+jojo eval-one-step
  : (-> <env> -- <env>)
  (if top-frame-finished?
    (case return-stack-pop
      <scoping-frame> local-stack-drop
      <simple-frame> nop)
    [top-frame-next-exp exe]))

(+jojo collect-obj-list
  : (-> <env> Exp List -- <env> Obj List)
  swap mark-stack-mark
  swap list-eval
  mark-stack-collect)

(+jojo collect-obj
  : (-> <env> List -- <env> Obj)
  null cons
  collect-obj-list
  car)

(+gene exe
  : (-> <env> (: :exp Exp) -- <env>)
  "- exe fail" p nl
  "  :exp = " p :exp p nl
  error)

(+gene cut
  : (-> (: :env <env>) (: :exp Exp) -- <env>)
  error)

(+jojo list-cut
  : (-> <env> (: :exp-list Exp List) -- <env>))

(+data <call-exp>
  .name : String)

(+disp exe : (-> <env> (: :exp <call-exp>) -- <env>)
  :exp.name name-dict-getget den-exe)

(+data <get-local-exp>
  .local-name : String)

(+disp exe
  : (-> <env> (: :exp <get-local-exp>) -- <env>)
  local-stack-tos :exp.local-name local-get
  data-stack-push)

(+data <set-local-exp>
  .local-name : String)

(+disp exe
  : (-> <env> (: :exp <set-local-exp>) -- <env>)
  data-stack-pop :obj!
  local-stack-pop :exp.local-name :obj local-set
  local-stack-push)

(+data <clo-exp>
  .exp : Exp)

(+disp exe
  : (-> <env> (: :exp <clo-exp>) -- <env>)
  :exp.exp clo-obj
  data-stack-push)

(+data <arrow-exp>
  .ante : [Exp List]
  .succ : [Exp List])

(+disp exe
  : (-> <env> (: :exp <arrow-exp>) -- <env>)
  (create <arrow-obj>
    .ante [:exp.ante collect-obj-list]
    .succ [:exp.succ collect-obj-list])
  data-stack-push)

(+data <match-exp>
  .arg : Exp
  .clause-dict : [String Exp Dict])

(+disp exe
  : (-> <env> (: :exp <match-exp>) -- <env>)
  :exp.arg exe :exp obj-match)

(+jojo obj-match
  : (-> <env>
        (: :obj Obj)
        (: :match-exp <match-exp>)
     -- <env>)
  (case :obj
    <data-cons-obj>
    [:obj.data-cons-name
     :match-exp.clause-dict
     dict-get exe]
    <hypo-obj>
    (if [:obj hypo-dict-find]
      [:match-exp obj-match]
      [:obj :match-exp new-match-obj data-stack-push])
    else error))

(note
  (begin
    generate-hypo-id :hypo-id!
    (create <hypo-type-obj>
      .hypo-id :hypo-id
      .type ><><>< <nat>)
    :hypo-type-obj!
    (create <hypo-obj>
      .hypo-id :hypo-id
      .hypo-type :hypo-type-obj)))

(+data <suppose-exp>)

(+disp exe
  : (-> <env> (: :exp <suppose-exp>) -- <env>)
  )

(+union Den
  <fun-den>
  <data-cons-den>
  <type-cons-den>)

(+gene den-exe
  : (-> (: :env <env>) (: :den Den) -- <env>)
  "- den-exe fail" p nl
  "  unknown den : " p :den p nl
  error)

(+gene den-cut
  ><)

(+data <fun-den>
  .type : <apply-exp>
  .body : [List Exp])

(+disp den-exe
  : (-> <env> (: :den <fun-den>) -- <env>)
  new-local-scope
  :den.type collect-obj :type!
  :type.ante ante-prepare
  :type.ante ante-correspond
  (create <scoping-frame>
    .body :den.body
    .index 0)
  return-stack-push)

(+data <data-cons-den>
  .type : Exp
  .data-cons-name : String
  .field-name-list : [String List]
  .type-cons-name : String)

(+disp den-exe
  : (-> <env> (: :den <data-cons-den>)
     -- <env>)
  :den.type collect-obj :type!
  :type.ante ante-prepare
  :den.field-name-list data-stack-zip-by-list :fields!
  (create <data-cons-obj>
    .type :type type->return-type
    .data-cons-name :den.data-cons-name
    .fields :fields)
  data-stack-push)

(+data <type-cons-den>
  .type : Exp
  .type-cons-name : String
  .field-name-list : [String List]
  .data-cons-name-list : [String List])

(+disp den-exe
  : (-> <env> (: :den <type-cons-den>)
     -- <env>)
  :den.type collect-obj :type!
  :type.ante ante-prepare
  :den.field-name-list data-stack-zip-by-list :fields!
  (create <type-cons-obj>
    .type :type type->return-type
    .type-cons-name :den.type-cons-name
    .fields :fields)
  data-stack-push)

(+jojo ante-prepare
  : (-> <env> (: :ante Obj List) -- <env>)
  :ante list-length data-stack-n-pop :obj-list!
  :obj-list {infer} list-map :ante list-unifiy)

(+jojo ante-correspond
  : (-> <env> (: :ante Obj List) -- <env>)
  )

(+jojo type->return-type
  : (-> Obj -- Obj)
  (when [dup arrow-obj?]
    .succ .car))

(+union Obj
  <data-cons-obj> <type-cons-obj>
  <clo-obj> <arrow-obj>
  <hypo-obj> <hypo-type-obj>
  <match-obj> <sum-obj>)

(+gene infer
  : (-> (: :env <env>) (: :obj Obj) -- <env> Obj)
  error)

(+jojo list-unifiy
  : (-> <env> (: :l Obj List) (: :r Obj List) -- <env>)
  )

(+jojo unify-one-step
  : (-> <env> -- <env>)
  )

(+gene unify
  : (-> <env> Obj Obj -- <env>)
  )

(+jojo list-cover
  : (-> <env> Obj List Obj List
     -- <env>))

(+data <data-cons-obj>
  .type : <type-cons-obj>
  .data-cons-name : String
  .fields : [String Obj Dict])

(+disp infer
 : (-> <env> <data-cons-obj>
    -- <env> <type-cons-obj>)
 )

(+data <type-cons-obj>
  .type : <higher-type-obj>
  .type-cons-name : String
  .fields : [String Obj Dict])

(+disp infer
 : (-> <env> <type-cons-obj>
    -- <env> <type-cons-obj>))

(+data <clo-obj>
  .exp : Exp)

(note every time the the type of a closure is asked for,
  we use the body of the closure
  to construct a new arrow object.)

(+disp infer
 : (-> <env> <clo-obj>
    -- <env> <arrow-obj>))

(+data <arrow-obj>
  .ante : [Obj List]
  .succ : [Obj List])

(+disp infer
 : (-> <env> <arrow-obj>
    -- <env> <arrow-obj>))

(+data <hypo-id>
  .id : String)

(+data <hypo-obj>
  .hypo-id : <hypo-id>
  .hypo-type : <hypo-type-obj>)

(+disp infer
  : (-> <env> <hypo-obj>
     -- <env> <hypo-type-obj>))

(+data <hypo-type-obj>
  .hypo-id : <hypo-id>
  .type : Obj)

(+disp infer
  : (-> <env> <hypo-type-obj>
     -- <env> ><><><))

(+jojo hypo-type-obj->hypo-obj
  : (-> <env> <hypo-type-obj>
     -- <env> <hypo-obj>))

(+data <match-id>
  .id : String)

(+data <match-obj>
  .match-id : <match-id>)

(+disp infer
 : (-> <env> <match-obj>
    -- <env> Obj))

(+data <sum-obj>
  .objs : [Obj List])

(+disp infer
 : (-> <env> <sum-obj>
    -- <env> <sum-obj>))

(+union Match
  <todo-match>
  <done-match>)

(+data <todo-match>
  .type : Obj
  .arg : Obj
  .match-exp : <match-exp>)

(+data <done-match>
  .type : Obj
  .result : Obj)

(+jojo fun-den-type-check
  : (-> <env> (: :den <fun-den>))
  mark-stack-mark
  :den.type.ante list-eval
  :den.body list-cut
  mark-stack-collect :results!
  :den.type.succ collect-obj-list
  :results list-cover)
