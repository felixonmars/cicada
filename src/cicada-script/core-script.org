#+property: tangle core-script.cs
#+title: core-script

* [todo-stack]

*** more about list

*** (lit/list)

*** queue-t

*** dict-t

    - maybe use box to design the api

*** (lit/dict)

*** combinators from joy

*** (and)

*** (or)

*** main

* prolog

* stack operation

*** drop

    #+begin_src cicada
    (+fun drop (let x))
    #+end_src

*** dup

    #+begin_src cicada
    (+fun dup (let x) x x)
    #+end_src

*** over

    #+begin_src cicada
    (+fun over (let x y) x y x)
    #+end_src

*** tuck

    #+begin_src cicada
    (+fun tuck (let x y) y x y)
    #+end_src

*** swap

    #+begin_src cicada
    (+fun swap (let x y) y x)
    #+end_src

* common syntax

*** ifte

    #+begin_src cicada
    (+fun ifte
      (let test true-fn false-fn)
      (case test
        (true-t true-fn)
        (false-t false-fn)))
    #+end_src

*** (if)

    #+begin_src cicada
    (+macro if
      (let body)
      body.car (let question)
      body.cdr.car (let on-true)
      body.cdr.cdr.car (let on-false)
      `(case (@ question)
         (true-t (@ on-true))
         (false-t (@ on-false))))
    #+end_src

*** (assert) & (assert!)

    #+begin_src cicada
    (+macro assert (let body)
      `(if [(@ body list/spread)]
         []
         ["- assertion fail : " string/print
          (quote (@ body)) sexp-list/print nl]))

    (+macro assert! (let body)
      `(if [(@ body list/spread)]
         []
         ["- assertion fail : " string/print
          (quote (@ body)) sexp-list/print nl
          error]))
    #+end_src

*** (when) & (unless)

    #+begin_src cicada
    (+macro when (let body)
      `(if (@ body.car)
         (@ 'begin body.cdr cons-c)
         []))

    (+macro unless (let body)
      `(if (@ body.car)
         []
         (@ 'begin body.cdr cons-c)))
    #+end_src

*** >< (and)

    #+begin_src cicada

    #+end_src

*** >< (or)

    #+begin_src cicada

    #+end_src

*** (cond)

    #+begin_src cicada
    (+macro cond (let body)
      (if [body list/length 1 number/lteq-p]
        `(begin
           "- cond mismatch!" string/print nl
           error)
        [body.car (when [dup 'else eq-p] drop 'true-c) (let question)
         body.cdr.car (let answer)
         `(if (@ question)
            (@ answer)
            (@ body.cdr.cdr recur))]))
    #+end_src

* number

* string

* list

*** list/length

    #+begin_src jojo
    (+fun list/length (let list)
      (if [list null-p]
        0
        [list.cdr recur number/inc]))
    #+end_src

*** list/append

    #+begin_src jojo
    (+fun list/append (let ante succ)
      (case ante
        (null-t succ)
        (cons-t ante.car ante.cdr succ recur cons-c)))
    #+end_src

*** tail-cons

    #+begin_src jojo
    (+fun tail-cons null-c cons-c list/append)
    #+end_src

* common gene

*** repr

    #+begin_src cicada
    (+gene repr 1
      default-repr)
    #+end_src

*** repr [string-t]

    #+begin_src cicada
    (+disp repr [string-t]
      doublequote/string swap string/append
      doublequote/string string/append)
    #+end_src

*** repr [number-t]

    #+begin_src cicada
    (+disp repr [number-t]
      number->string)
    #+end_src

*** w

    #+begin_src cicada
    (+gene w 1
      repr string/print)
    #+end_src

*** p

    #+begin_src cicada
    (+gene p 1
      w)
    #+end_src

*** p [string-t]

    #+begin_src cicada
    (+disp p [string-t]
      string/print)
    #+end_src

*** length

    #+begin_src cicada
    (+gene length 1
      error)
    #+end_src

*** empty-p

    #+begin_src cicada
    (+gene empty-p 1
      error)
    #+end_src

* algebric gene

*** >< add

*** >< sub

*** >< mul

* combinator

*** times

    #+begin_src cicada
    (+fun times (let fun n)
      (unless [n 0 number/lteq-p]
        fun
        {fun} n number/dec recur))
    #+end_src

* epilog

*** test

***** bool-u

      #+begin_src cicada
      (assert
        true-c false-c bool/and
        false-c eq-p)

      (assert
        true-c false-c bool/or
        true-c eq-p)

      (assert
        true-c bool/not
        false-c eq-p)

      (assert
        true-c bool/not bool/not
        true-c eq-p)
      #+end_src

***** eq-p

      #+begin_src cicada
      (assert
        1 2 3 null-c cons-c cons-c cons-c
        1 2 3 null-c cons-c cons-c cons-c eq-p)
      #+end_src

***** number-t

******* number/factorial

        #+begin_src cicada
        (+fun number/factorial/case
          (let n)
          (case [n 0 eq-p]
            (true-t 1)
            (false-t n number/dec recur n number/mul)))

        (assert
          5 number/factorial/case
          120 eq-p)

        (+fun number/factorial/ifte
          (let n)
          n 0 eq-p
          {1}
          {n number/dec recur n number/mul}
          ifte)

        (assert
          5 number/factorial/ifte
          120 eq-p)

        (+fun number/factorial
          (let n)
          (if [n 0 eq-p]
            1
            [n number/dec recur n number/mul]))

        (assert
          5 number/factorial
          120 eq-p)
        #+end_src

***** string-t

      #+begin_src cicada
      (assert
        "0123" string/length
        4 eq-p)

      (assert
        "0123" "4567" string/append
        "01234567" eq-p)

      (assert
        "01234567" 3 string/ref
        "3" eq-p)

      (assert
        "01234567" 3 5 string/slice
        "34" eq-p)

      (assert
        123 number->string
        "123" eq-p)
      #+end_src

***** nat-u

      #+begin_src cicada
      (+union nat-u
        zero-t
        succ-t)

      (+data zero-t)

      (+data succ-t
        prev)

      (+fun nat/add
        (let m n)
        (case n
          (zero-t m)
          (succ-t m n.prev recur succ-c)))

      (+fun nat/mul
        (let m n)
        (case n
          (zero-t n)
          (succ-t m n.prev recur m nat/add)))

      (+fun nat/factorial
        (let n)
        (case n
          (zero-t zero-c succ-c)
          (succ-t n.prev recur n nat/mul)))

      (assert
        zero-c succ-c succ-c succ-c succ-c succ-c nat/factorial
        zero-c succ-c succ-c succ-c succ-c succ-c
        zero-c succ-c succ-c succ-c succ-c nat/mul
        zero-c succ-c succ-c succ-c nat/mul
        zero-c succ-c succ-c nat/mul
        zero-c succ-c nat/mul
        eq-p)
      #+end_src

***** (+var)

      #+begin_src cicada
      (+var var/cons 1 null-c cons-c)

      (assert
        2 var/cons.car!
        var/cons 2 null-c cons-c eq-p)

      (+fun nat->number
        (let n)
        (case n
          (zero-t 0)
          (succ-t n.prev recur number/inc)))

      (+var var/nat zero-c succ-c succ-c)

      (assert
        var/nat nat->number 2 eq-p)

      (assert
        zero-c var/nat.prev!
        var/nat nat->number 1 eq-p)
      #+end_src

***** (@)

      #+begin_src cicada
      (assert
        `(1 2 (@ 1 2 number/add number->string))
        '(1 2 3) eq-p)
      #+end_src

***** (+gene) & (+disp)

      #+begin_src cicada
      (+gene gene0 2
        drop drop
        "default gene0")

      (assert 1 2 gene0 "default gene0" eq-p)

      (+disp gene0 [number-t number-t]
        drop drop
        "number-t number-t gene0")

      (assert 1 2 gene0 "number-t number-t gene0" eq-p)
      #+end_src

***** (when) & (unless)

      #+begin_src cicada
      (assert
        (when [1 1 eq-p] 'ok)
        'ok eq-p)

      (assert
        true-c
        (unless [1 1 eq-p] 'ugh))

      (assert
        true-c
        (when [1 2 eq-p] 'ugh))

      (assert
        (unless [1 2 eq-p] 'ok)
        'ok eq-p)
      #+end_src

***** combinator

******* times

        #+begin_src cicada
        (assert
          "" {"*" string/append} 3 times
          "***" eq-p)
        #+end_src

*** play

    #+begin_src cicada
    (cond true-c (begin "123" w nl)
          else (begin "123" p nl))
    #+end_src

*** main

    #+begin_src cicada

    #+end_src
