#+property: tangle cicada-script.js
#+title: cicada-script

* [todo-stack]

*** about number

*** overload -c to (.) in stack, and stop using -cr

    - also overload every function call with (.) in stack

*** about cons and null

*** (+def)

*** (+macro)

*** (+top-macro)

*** data_predicate_den_t

*** union_predicate_den_t

*** (+gene)

*** (+disp)

* [note]

*** as prototype

    - without optimizing the searches
      involved in :
      - name_dict
      - scope
      - data field
      - sig to gene
      - gene to disp
      this implementation can only be a prototype.

    - to do the optimizations well,
      a compiler is needed.

* prolog

*** utility

***** print

      #+begin_src js
      let print = console.log;
      #+end_src

***** vect_eq_p

      #+begin_src js
      function vect_eq_p (v1, v2)
      {
          if (v1.length !== v2.length)
              return false;
          let index = 0;
          while (index < v1.length) {
              if (v1[index] !== v2[index])
                  return false;
              index = index + 1;
          }
          return true;
      }
      #+end_src

***** function_p

      #+begin_src js
      function function_p (x)
      {
          return x instanceof Function;
      }
      #+end_src

***** string_p

      #+begin_src js
      function string_p (x)
      {
          return typeof x === 'string';
      }
      #+end_src
***** vect_p

      #+begin_src js
      function vect_p (x)
      {
          return x instanceof Array;
      }
      #+end_src

***** vect_empty_p

      #+begin_src js
      function vect_empty_p (x)
      {
          assert (x instanceof Array);
          return x.length === 0;
      }
      #+end_src

***** vect_member_p

      #+begin_src js
      function vect_member_p (x, vect)
      {
          assert (vect_p (vect));
          for (let y of vect) {
              if (x === y)
                  return true;
          }
          return false;
      }
      #+end_src

***** dict_length

      #+begin_src js
      function dict_length (dict)
      {
          let length = 0;
          for (let x of dict.keys ())
              length = length +1;
          return length;
      }
      #+end_src

***** assert

      #+begin_src js
      function assert (x) {
          if (! x) {
              throw new Error('assert fail!');
          }
      }
      #+end_src

***** error

      #+begin_src js
      function error ()
      {
          print ("");
          print ("");
          throw new Error('fatal error!');
      }
      #+end_src

* env

*** env_t

    #+begin_src js
    class env_t
    {
        constructor ()
        {
            this.name_dict = new name_dict_t ();
            this.data_stack = [];
            this.frame_stack = [];
            this.scope_stack = [];
        }
    }
    #+end_src

*** name_dict

***** name_dict_t -- name to den

      #+begin_src js
      class name_dict_t
      {
          constructor ()
          {
              this.dict = new Map ();
          }

          get (name)
          {
              return this.dict.get (name);
          }

          set (name, den)
          {
              this.dict.set (name, den);
          }
      }
      #+end_src

***** name_dict_get

      #+begin_src js
      function name_dict_get (env, name)
      {
          return env.name_dict.get (name);
      }
      #+end_src

***** name_dict_set

      #+begin_src js
      function name_dict_set (env, name, den)
      {
          env.name_dict.set (name, den);
      }
      #+end_src

*** data_stack

***** data_stack_push

      #+begin_src js
      function data_stack_push (env, obj)
      {
          env.data_stack.push (obj);
      }
      #+end_src

***** data_stack_pop

      #+begin_src js
      function data_stack_pop (env)
      {
          return env.data_stack.pop ();
      }
      #+end_src

***** data_stack_tos

      #+begin_src js
      function data_stack_tos (env)
      {
          let length = data_stack_length (env);
          return env.data_stack[length - 1];
      }
      #+end_src

***** data_stack_drop

      #+begin_src js
      function data_stack_drop (env)
      {
          data_stack_pop (env);
      }
      #+end_src

***** data_stack_peek

      #+begin_src js
      function data_stack_peek (env, index)
      {
          index = index + 1;
          let length = data_stack_length (env);
          return env.data_stack[length - index];
      }
      #+end_src

***** data_stack_length

      #+begin_src js
      function data_stack_length (env)
      {
          return env.data_stack.length;
      }
      #+end_src

*** frame_stack

***** frame_stack_push

      #+begin_src js
      function frame_stack_push (env, frame)
      {
          env.frame_stack.push (frame);
      }
      #+end_src

***** frame_stack_pop

      #+begin_src js
      function frame_stack_pop (env)
      {
          return env.frame_stack.pop ();
      }
      #+end_src

***** frame_stack_tos

      #+begin_src js
      function frame_stack_tos (env)
      {
          let length = frame_stack_length (env);
          return env.frame_stack[length - 1];
      }
      #+end_src

***** frame_stack_drop

      #+begin_src js
      function frame_stack_drop (env)
      {
          frame_stack_pop (env);
      }
      #+end_src

***** frame_stack_length

      #+begin_src js
      function frame_stack_length (env)
      {
          return env.frame_stack.length;
      }
      #+end_src

*** frame

***** scoping_frame_t

      #+begin_src js
      class scoping_frame_t
      {
          constructor (exp_vect)
          {
              this.exp_vect = exp_vect;
              this.length = exp_vect.length;
              this.index = 0;
          }
      }
      #+end_src

***** simple_frame_t

      #+begin_src js
      class simple_frame_t
      {
          constructor (exp_vect)
          {
              this.exp_vect = exp_vect;
              this.length = exp_vect.length;
              this.index = 0;
          }
      }
      #+end_src

***** frame_end_p

      #+begin_src js
      function frame_end_p (frame)
      {
          return frame.index === frame.length;
      }
      #+end_src

***** frame_next_exp

      #+begin_src js
      function frame_next_exp (frame)
      {
          let exp = frame.exp_vect[frame.index];
          frame.index = frame.index + 1;
          return exp;
      }
      #+end_src

*** scope_stack

***** scope_stack_push

      #+begin_src js
      function scope_stack_push (env, scope)
      {
          env.scope_stack.push (scope);
      }
      #+end_src

***** scope_stack_pop

      #+begin_src js
      function scope_stack_pop (env)
      {
          return env.scope_stack.pop ();
      }
      #+end_src

***** scope_stack_tos

      #+begin_src js
      function scope_stack_tos (env)
      {
          let length = scope_stack_length (env);
          return env.scope_stack[length - 1];
      }
      #+end_src

***** scope_stack_drop

      #+begin_src js
      function scope_stack_drop (env)
      {
          scope_stack_pop (env);
      }
      #+end_src

***** scope_stack_length

      #+begin_src js
      function scope_stack_length (env)
      {
          return env.scope_stack.length;
      }
      #+end_src

*** scope

***** scope_t

      #+begin_src js
      class scope_t
      {
          constructor ()
          {
              this.dict = new Map ();
          }

          get (name)
          {
              return this.dict.get (name);
          }

          set (name, obj)
          {
              this.dict.set (name, obj);
          }

          clone ()
          {
              let scope = new scope_t ();
              for (let [name, obj] of this.dict) {
                  scope.set (name, obj);
              }
              return scope;
          }
      }
      #+end_src

* run

*** run_one_step

    #+begin_src js
    function run_one_step (env)
    {
        let frame = frame_stack_tos (env);
        if (frame_end_p (frame)) {
            frame_stack_drop (env);
            if (frame instanceof scoping_frame_t)
                scope_stack_drop (env);
            return;
        }
        let scope = scope_stack_tos (env);
        let exp = frame_next_exp (frame);
        if (frame_end_p (frame)) {
            // proper tail call
            frame_stack_drop (env);
            if (frame instanceof scoping_frame_t)
                scope_stack_drop (env);
        }
        // {
        //     print ("- run_one_step");
        //     print ("  exp :", exp);
        //     print ("  scope :", scope);
        //     print ("  env :", env);
        //     print ("");
        // }
        exp.exe (env, scope);
    }
    #+end_src

*** run_with_base

    #+begin_src js
    function run_with_base (env, base)
    {
        while (frame_stack_length (env) > base)
            run_one_step (env);
    }
    #+end_src

*** exp_vect_run

    #+begin_src js
    function exp_vect_run (env, exp_vect)
    {
        let base = frame_stack_length (env);
        let frame = new simple_frame_t (exp_vect);
        frame_stack_push (env, frame);
        run_with_base (env, base);
    }
    #+end_src

* apply

*** closure_apply

    #+begin_src js
    function closure_apply (env, closure)
    {
        data_stack_push (env, closure);
        let exp_vect = [new apply_exp_t ()];
        exp_vect_run (env, exp_vect);
    }
    #+end_src

*** closure_to_obj_vect

    #+begin_src js
    function closure_to_obj_vect (env, closure)
    {
        let mark = data_stack_length (env);
        closure_apply (env, closure);
        let length = data_stack_length (env);
        let obj_vect = [];
        while (length > mark) {
           let obj = data_stack_pop (env);
           obj_vect.unshift (obj);
           length = length - 1;
        }
        return obj_vect;

    }
    #+end_src

*** closure_to_obj

    #+begin_src js
    function closure_to_obj (env, closure)
    {
        let obj_vect = closure_to_obj_vect (env, closure);
        assert (obj_vect.length === 1);
        return obj_vect[0];
    }
    #+end_src

* exp

*** call_exp_t

    #+begin_src js
    class call_exp_t
    {
        constructor (name)
        {
            this.name = name;
        }

        exe (env, scope)
        {
            let obj = scope.get (this.name);
            // {
            //     print ("- call_exp");
            //     print (this.name);
            //     print (scope);
            //     print (env);
            //     print ("");
            // }
            if (obj) {
                if (obj instanceof closure_t)
                    closure_apply (env, obj);
                else
                    data_stack_push (env, obj);
            }
            else {
                let den = name_dict_get (env, this.name);
                if (! den) {
                    print ("- exe call_exp_t");
                    print ("  unknown name :", this.name);
                    error ();
                }
                den.den_exe (env);
            }
        }
    }
    #+end_src

*** let_exp_t

    #+begin_src js
    class let_exp_t
    {
        constructor (name_vect)
        {
            this.name_vect = name_vect;
        }

        exe (env, scope)
        {
            let name_vect = this.name_vect.slice ();
            while (name_vect.length > 0) {
                let name = name_vect.pop ();
                let obj = data_stack_pop (env);
                scope.set (name, obj);
            }
        }
    }
    #+end_src

*** closure_exp_t

    #+begin_src js
    class closure_exp_t
    {
        constructor (exp_vect)
        {
            this.exp_vect = exp_vect;
        }

        exe (env, scope)
        {
            let closure =
                new closure_t (
                    this.exp_vect,
                    scope.clone ());
            data_stack_push (env, closure);
        }
    }
    #+end_src

*** apply_exp_t

    #+begin_src js
    class apply_exp_t
    {
        constructor () { }

        exe (env, scope)
        {
            let closure = data_stack_pop (env);
            let frame = new scoping_frame_t (closure.exp_vect);
            frame_stack_push (env, frame);
            scope_stack_push (env, closure.scope);
        }
    }
    #+end_src

*** case_exp_t

    #+begin_src js
    class case_exp_t
    {
        constructor (arg_exp_vect, case_clause_dict)
        {
            this.arg_exp_vect = arg_exp_vect;
            this.case_clause_dict = case_clause_dict;
        }

        exe (env, scope)
        {
            let closure =
                new closure_t (
                    this.arg_exp_vect,
                    scope.clone ());
            let obj = closure_to_obj (env, closure);
            assert (obj instanceof data_t);
            let exp_vect = this.case_clause_dict.get (obj.type_name);
            if (exp_vect) {
                let closure =
                    new closure_t (
                        exp_vect,
                        scope.clone ());
                closure_apply (env, closure);
            }
            else {
                let exp_vect = this.case_clause_dict.get ("else");
                if (exp_vect) {
                    let closure =
                        new closure_t (
                            exp_vect,
                            scope.clone ());
                    closure_apply (env, closure);
                }
                else {
                    print ("- case mismatch!");
                    error ();
                }
            }
        }
    }
    #+end_src

*** case_clause_dict_t -- type_name to exp_vect

    #+begin_src js
    class case_clause_dict_t
    {
        constructor ()
        {
            this.dict = new Map ();
        }

        get (type_name)
        {
            return this.dict.get (type_name);
        }

        set (type_name, exp_vect)
        {
            this.dict.set (type_name, exp_vect);
        }
    }
    #+end_src

*** field_exp_t

    #+begin_src js
    class field_exp_t
    {
        constructor (field_name)
        {
            this.field_name = field_name;
        }

        exe (env, scope)
        {
            let data = data_stack_pop (env);
            assert (data instanceof data_t);
            let obj = data.field_dict.get (this.field_name);
            assert (obj);
            if (obj instanceof closure_t)
                closure_apply (env, obj);
            else
                data_stack_push (env, obj);
        }
    }
    #+end_src

*** dot_exp_t

    #+begin_src js
    class dot_exp_t
    {
        constructor (reversed_field_name_vect)
        {
            this.reversed_field_name_vect
                = reversed_field_name_vect;
        }

        exe (env, scope)
        {
            let field_dict = new field_dict_t ();
            for (let field_name of this.reversed_field_name_vect) {
                let obj = data_stack_pop (env);
                field_dict.set (field_name, obj)
            }
            data_stack_push (env, field_dict);
        }
    }
    #+end_src

*** clone_exp_t

    #+begin_src js
    class clone_exp_t
    {
        constructor () { }

        exe (env, scope)
        {
            let data = data_stack_pop (env);
            assert (data instanceof data_t);
            let field_dict = data_stack_pop (env);
            assert (field_dict instanceof field_dict_t);
            let new_field_dict = new field_dict_t ();
            // .dict of field_dict should be hidden
            //   but I used it here
            for (let [field_name, obj] of data.field_dict.dict) {
                new_field_dict.set (field_name, obj);
            }
            for (let [field_name, obj] of field_dict.dict) {
                new_field_dict.set (field_name, obj);
            }
            let new_data =
                new data_t (
                    data.type_name,
                    new_field_dict);
            data_stack_push (env, new_data);
        }
    }
    #+end_src

*** lit_exp_t

    #+begin_src js
    class lit_exp_t
    {
        constructor (obj)
        {
            this.obj = obj;
        }

        exe (env, scope)
        {
            data_stack_push (env, this.obj);
        }
    }
    #+end_src

* den

*** jojo_den_t

    #+begin_src js
    class jojo_den_t
    {
        constructor (exp_vect)
        {
            this.exp_vect = exp_vect;
        }

        den_exe (env)
        {
            let frame = new scoping_frame_t (this.exp_vect);
            let scope = new scope_t ();
            frame_stack_push (env, frame);
            scope_stack_push (env, scope);
        }
    }
    #+end_src

*** >< def_den_t

    #+begin_src js
    class def_den_t
    {
        constructor ()
        {
        }

        den_exe ()
        {

        }
    }
    #+end_src

*** union_den_t

    #+begin_src js
    class union_den_t
    {
        constructor (sub_type_name_vect)
        {
            this.sub_type_name_vect = sub_type_name_vect;
        }

        den_exe (env)
        {
            error ();
        }
    }
    #+end_src

*** >< union_predicate_den_t

    #+begin_src js

    #+end_src

*** data_den_t

    #+begin_src js
    class data_den_t
    {
        constructor (reversed_field_name_vect)
        {
            this.reversed_field_name_vect
                = reversed_field_name_vect;
        }

        den_exe (env)
        {
            error ();
        }
    }
    #+end_src

*** data_cons_den_t

    #+begin_src js
    class data_cons_den_t
    {
        constructor (type_name)
        {
            this.type_name = type_name;
        }

        den_exe (env)
        {
            let type_name = this.type_name;
            let data_den = name_dict_get (env, type_name);
            assert (data_den instanceof data_den_t);
            let field_dict = new field_dict_t ();
            for (let field_name of data_den.reversed_field_name_vect) {
                let obj = data_stack_pop (env);
                field_dict.set (field_name, obj)
            }
            let data = new data_t (type_name, field_dict);
            data_stack_push (env, data);
        }
    }
    #+end_src

*** data_create_den_t

    #+begin_src js
    class data_create_den_t
    {
        constructor (type_name)
        {
            this.type_name = type_name;
        }

        den_exe (env)
        {
            let field_dict = data_stack_pop (env);
            assert (field_dict instanceof field_dict_t);
            let data
                = new data_t (
                    this.type_name,
                    field_dict);
            data_stack_push (env, data);
        }
    }
    #+end_src

*** >< data_predicate_den_t

*** >< top_macro_den_t

    #+begin_src js
    class top_macro_den_t
    {
        constructor ()
        {
        }

        den_exe (env)
        {
        }
    }
    #+end_src

*** >< macro_den_t

    #+begin_src js
    class macro_den_t
    {
        constructor ()
        {
        }

        den_exe (env)
        {
        }
    }
    #+end_src

*** prim_den_t

    #+begin_src js
    class prim_den_t
    {
        constructor (prim_fn)
        {
            this.prim_fn = prim_fn;
        }

        den_exe (env)
        {
            this.prim_fn (env);
        }
    }
    #+end_src

* obj

*** data_t

    #+begin_src js
    class data_t
    {
        constructor (type_name, field_dict)
        {
            this.type_name = type_name;
            this.field_dict = field_dict;
        }

        eq_p (that)
        {
            if (this.type_name !== that.type_name)
                return false;
            else
                return this.field_dict.eq_p (that.field_dict);
        }
    }
    #+end_src

*** closure_t

    #+begin_src js
    class closure_t
    {
        constructor (exp_vect, scope)
        {
            this.type_name = "closure-t";
            this.exp_vect = exp_vect;
            this.scope = scope;
        }

        eq_p (that)
        {
            if (this.type_name !== that.type_name)
                return false;
            if (this.exp_vect !== that.exp_vect)
                return false;
            if (this.scope !== that.scope)
                return false;
            else
                return true;
        }
    }
    #+end_src

*** field_dict_t -- field_name to obj

    #+begin_src js
    class field_dict_t
    {
        constructor ()
        {
            this.type_name = "field-dict-t";
            this.dict = new Map ();
        }

        eq_p (that)
        {
            if (this.type_name !== that.type_name)
                return false;
            if (dict_length (this.dict) !== dict_length (that.dict))
                return false;
            for (let [field_name, obj] of this.dict) {
                if (! (obj.eq_p (that.dict.get (field_name))))
                    return false;
            }
            return true;
        }

        get (field_name)
        {
            return this.dict.get (field_name);
        }

        set (field_name, obj)
        {
            this.dict.set (field_name, obj);
        }
    }
    #+end_src

* top keyword

*** the_top_keyword_dict -- name to top_keyword_den

    #+begin_src js
    let the_top_keyword_dict = new Map ();
    #+end_src

*** env_merge

    #+begin_src js
    function env_merge (env, den_dict)
    {
        for (let [name, den] of den_dict) {
            name_dict_set (env, name, den);
        }
    }
    #+end_src

*** new_top_keyword

    #+begin_src js
    function new_top_keyword (name, prim_fn)
    {
        the_top_keyword_dict.set (name, prim_fn);
    }
    #+end_src

*** (+union)

    #+begin_src js
    new_top_keyword (
        "+union",
        function (env, sexp_list)
        {
            let name = sexp_list.car;
            let rest_list = sexp_list.cdr;
            let sub_type_name_vect = [];
            let rest_vect = list_to_vect (rest_list);
            for (let type_name of rest_vect) {
                sub_type_name_vect.push (type_name);
            }
            let union_den = new union_den_t (sub_type_name_vect);
            name_dict_set (env, name, union_den);
        }
    );
    #+end_src

*** union_name_p

    #+begin_src js
    function union_name_p (x)
    {
        if (! (string_p (x)))
            return false;
        if (x.length <= 2)
            return false;
        if (x.slice (x.length -2, x.length) === "-u")
            return true;
        else
            return false;
    }
    #+end_src

*** union_name_prefix

    #+begin_src js
    function union_name_prefix (x)
    {
        return x.slice (0, x.length -2);
    }
    #+end_src

*** (+data)

    #+begin_src js
    new_top_keyword (
        "+data",
        function (env, sexp_list)
        {
            let name = sexp_list.car;
            assert (data_name_p (name));
            let rest_list = sexp_list.cdr;
            let rest_vect = list_to_vect (rest_list);
            let reversed_field_name_vect = [];
            let index = 0;
            let length = rest_vect.length;
            while (index < length) {
                let sexp = rest_vect[index];
                reversed_field_name_vect
                    .unshift (sexp);
                index = index + 3;
            }
            name_dict_set (
                env, name,
                new data_den_t (reversed_field_name_vect));
            let prefix = data_name_prefix (name);
            name_dict_set (
                env, prefix.concat ("-c"),
                new data_cons_den_t (name));
            name_dict_set (
                env, prefix.concat ("-cr"),
                new data_create_den_t (name));
        }
    );
    #+end_src

*** data_name_p

    #+begin_src js
    function data_name_p (x)
    {
        if (! (string_p (x)))
            return false;
        if (x.length <= 2)
            return false;
        if (x.slice (x.length -2, x.length) === "-t")
            return true;
        else
            return false;
    }
    #+end_src

*** data_name_prefix

    #+begin_src js
    function data_name_prefix (x)
    {
        return x.slice (0, x.length -2);
    }
    #+end_src

*** (+jojo)

    #+begin_src js
    new_top_keyword (
        "+jojo",
        function (env, sexp_list)
        {
            let name = sexp_list.car;
            let rest_list = sexp_list.cdr;
            let exp_vect = sexp_list_compile (rest_list);
            let jojo_den = new jojo_den_t (exp_vect);
            name_dict_set (env, name, jojo_den);
        }
    );
    #+end_src

*** (main)

    #+begin_src js
    new_top_keyword (
        "main",
        function (env, sexp_list)
        {
            let exp_vect = sexp_list_compile (sexp_list);
            exp_vect_run (env, exp_vect);
        }
    );
    #+end_src

*** (note) -- also works as body level macro

    #+begin_src js
    new_top_keyword (
        "note",
        function (env, sexp_list)
        {
            return [];
        }
    );
    #+end_src

*** >< (+macro)

    #+begin_src js

    #+end_src

*** >< (+top-macro)

    #+begin_src js

    #+end_src

* keyword

*** the_keyword_dict -- name to keyword_den

    #+begin_src js
    let the_keyword_dict = new Map ();
    #+end_src

*** new_keyword

    #+begin_src js
    function new_keyword (name, prim_fn)
    {
        the_keyword_dict.set (name, prim_fn);
    }
    #+end_src

*** (let)

    #+begin_src js
    new_keyword (
        "let",
        function (sexp_list)
        {
            let sexp_vect = list_to_vect (sexp_list);
            return [new let_exp_t (sexp_vect)];
        }
    );
    #+end_src

*** (begin)

    #+begin_src js
    new_keyword (
        "begin",
        function (sexp_list)
        {
            return sexp_list_compile (sexp_list);
        }
    );
    #+end_src

*** (closure)

    #+begin_src js
    new_keyword (
        "closure",
        function (sexp_list)
        {
            let sexp_vect = list_to_vect (sexp_list);
            return [new closure_exp_t (sexp_vect)];
        }
    )
    #+end_src

*** (case)

    #+begin_src js
    new_keyword (
        "case",
        function (sexp_list)
        {
            let case_clause_dict = new case_clause_dict_t ();
            let arg_exp_vect = sexp_compile (sexp_list.car);
            let rest_vect = list_to_vect (sexp_list.cdr);
            for (let sexp of rest_vect) {
                let case_name = sexp.car;
                let exp_vect = sexp_list_compile (sexp.cdr)
                case_clause_dict.set (case_name, exp_vect);
            }
            return [new case_exp_t (arg_exp_vect, case_clause_dict)];
        }
    );
    #+end_src

*** (field)

    #+begin_src js
    new_keyword (
        "field",
        function (sexp_list)
        {
            return [new field_exp_t (sexp_list.car)];
        }
    );
    #+end_src

*** (.)

    #+begin_src js
    new_keyword (
        ".",
        function (sexp_list)
        {
            let sexp_vect = list_to_vect (sexp_list);
            let reversed_field_name_vect = [];
            for (let field_name of sexp_vect) {
                reversed_field_name_vect.unshift (field_name);
            }
            return [new dot_exp_t (reversed_field_name_vect)];
        }
    );
    #+end_src

* prim

*** the_prim_dict -- name to prim_den

    #+begin_src js
    let the_prim_dict = new Map ();
    #+end_src

*** new_prim

    #+begin_src js
    function new_prim (name, prim_fn)
    {
        let prim_den = new prim_den_t (prim_fn);
        the_prim_dict.set (name, prim_den);
    }
    #+end_src

*** bool

***** true_t

      #+begin_src js
      class true_t
      {
          constructor ()
          {
              this.type_name = "true-t";
          }

          eq_p (that)
          {
            if (this.type_name !== that.type_name)
                return false;
            else
                return true;
          }
      }
      #+end_src

***** false_t

      #+begin_src js
      class false_t
      {
          constructor ()
          {
              this.type_name = "false-t";
          }

          eq_p (that)
          {
            if (this.type_name !== that.type_name)
                return false;
            else
                return true;
          }
      }
      #+end_src

***** true-c

      #+begin_src js
      new_prim (
          "true-c",
          function (env)
          {
              data_stack_push (env, new true_t ());
          }
      );
      #+end_src

***** false-c

      #+begin_src js
      new_prim (
          "false-c",
          function (env)
          {
              data_stack_push (env, new false_t ());
          }
      );
      #+end_src

***** bool-and

      #+begin_src js
      new_prim (
          "bool-and",
          function (env)
          {
              let b = data_stack_pop (env);
              let a = data_stack_pop (env);
              if (a instanceof false_t)
                  data_stack_push (env, new false_t ());
              else if (b instanceof false_t)
                  data_stack_push (env, new false_t ());
              else
                  data_stack_push (env, new true_t ());
          }
      );
      #+end_src

***** bool-or

      #+begin_src js
      new_prim (
          "bool-or",
          function (env)
          {
              let b = data_stack_pop (env);
              let a = data_stack_pop (env);
              if (a instanceof true_t)
                  data_stack_push (env, new true_t ());
              else if (b instanceof true_t)
                  data_stack_push (env, new true_t ());
              else
                  data_stack_push (env, new false_t ());
          }
      );
      #+end_src

***** bool-not

      #+begin_src js
      new_prim (
          "bool-not",
          function (env)
          {
              let a = data_stack_pop (env);
              if (a instanceof false_t)
                  data_stack_push (env, new true_t ());
              else
                  data_stack_push (env, new false_t ());
          }
      );
      #+end_src

***** bool-p

      #+begin_src js
      new_prim (
          "bool-p",
          function (env)
          {
              let a = data_stack_pop (env);
              if (a instanceof false_t)
                  data_stack_push (env, new true_t ());
              if (a instanceof true_t)
                  data_stack_push (env, new true_t ());
              else
                  data_stack_push (env, new false_t ());
          }
      );
      #+end_src

*** >< number

***** number_t

      #+begin_src js
      class number_t
      {
          constructor (number)
          {
              this.type_name = "number-t";
              this.number = number;
          }

          eq_p (that)
          {
            if (this.type_name !== that.type_name)
                return false;
            else
                return this.number === that.number;
          }
      }
      #+end_src

*** >< string

***** string_t

      #+begin_src js
      class string_t
      {
          constructor (string)
          {
              this.type_name = "string-t";
              this.string = string;
          }

          eq_p (that)
          {
            if (this.type_name !== that.type_name)
                return false;
            else
                return this.string === that.string;
          }
      }
      #+end_src

***** string-p

      #+begin_src js
      new_prim (
          "string-p",
          function (env)
          {
              let obj = data_stack_pop (env);
              if (obj.type_name === "string-t")
                  data_stack_push (env, new true_t ());
              else
                  data_stack_push (env, new false_t ());
          }
      );
      #+end_src

***** string-length

      #+begin_src js
      new_prim (
          "string-length",
          function (env)
          {
              let obj = data_stack_pop (env);
              data_stack_push (env, new number_t (obj.string.length));
          }
      );
      #+end_src

***** string-ref

      #+begin_src js
      new_prim (
          "string-ref",
          function (env)
          {
              let index = data_stack_pop (env);
              let string = data_stack_pop (env);
              let char = string.string[index.number];
              data_stack_push (env, new string_t (char));
          }
      );
      #+end_src

***** string-append

      #+begin_src js
      new_prim (
          "string-append",
          function (env)
          {
              let b = data_stack_pop (env);
              let a = data_stack_pop (env);
              let new_string = a.string.concat (b.string);
              data_stack_push (env, new string_t (new_string));
          }
      );
      #+end_src

***** string-slice

      #+begin_src js
      new_prim (
          "string-slice",
          function (env)
          {
              let end = data_stack_pop (env);
              let begin = data_stack_pop (env);
              let string = data_stack_pop (env);
              let new_string
                  = string.string.slice (begin.number, end.number);
              data_stack_push (env, new string_t (new_string));
          }
      );
      #+end_src

*** >< list

***** null_t

      #+begin_src js
      class null_t
      {
          constructor ()
          {
              this.type_name = "null-t";
          }

          eq_p (that)
          {
              if (this.type_name !== that.type_name)
                  return false;
              else
                  return true;
          }
      }
      #+end_src

***** null_c

      #+begin_src js
      function null_c ()
      {
          return new null_t ();
      }
      #+end_src

***** null_p

      #+begin_src js
      function null_p (x)
      {
          return x instanceof null_t;
      }
      #+end_src

***** cons_t

      #+begin_src js
      class cons_t
      {
          constructor (car, cdr)
          {
              this.type_name = "cons-t";
              this.car = car;
              this.cdr = cdr;
          }

          eq_p (that)
          {
              if (this.type_name !== that.type_name)
                  return false;
              else if (! (this.car.eq_p (that.car)))
                  return false;
              else if (! (this.cdr.eq_p (that.cdr)))
                  return false;
              else
                  return true;
          }
      }
      #+end_src

***** cons_c

      #+begin_src js
      function cons_c (car, cdr)
      {
          assert (list_p (cdr));
          return new cons_t (car, cdr);
      }
      #+end_src

***** cons_p

      #+begin_src js
      function cons_p (x)
      {
          return x instanceof cons_t;
      }
      #+end_src

***** list_p

      #+begin_src js
      function list_p (x)
      {
          return (null_p (x) || cons_p (x));
      }
      #+end_src

* scan

*** code_scan -- string to string_vect

    - ";" as line comment
    - "name.filed" as "name .filed"

    #+begin_src js
    function code_scan (string)
    {
        let string_vect = [];
        let i = 0;
        let length = string.length;
        while (i < length) {
            let char = string[i];
            if (space_p (char))
                i = i + 1;
            else if (char === ';') {
                let end = string.indexOf ('\n', i+1);
                if (end === -1)
                    break;
                else
                    i = end + 1;
            }
            else if (delimiter_p (char)) {
                string_vect.push (char);
                i = i + 1;
            }
            else if (char === '"') {
                let end = string.indexOf ('"', i+1);
                if (end === -1) {
                    print ("- code_scan fail")
                    print ("  doublequote mismatch")
                    print ("  string : {}".format(string))
                    error ()
                }
                string_vect.push (string.slice (i, end + 1));
                i = end + 1;
            }
            else {
                let end = find_end (string, i+1);
                string_vect.push (string.slice (i, end + 1));
                i = end + 1;
            }
        }
        return string_vect;
    }
    #+end_src

*** space_p

    #+begin_src js
    function space_p (char)
    {
        return (char == ' ' ||
                char == '\n' ||
                char == '\t');
    }
    #+end_src

*** delimiter_p

    #+begin_src js
    function delimiter_p (char)
    {
        return (char == '(' ||
                char == ')' ||
                char == '[' ||
                char == ']' ||
                char == '{' ||
                char == '}' ||
                char == ',' ||
                char == ';' ||
                char == '`' ||
                char == "'");
    }
    #+end_src

*** find_end

    #+begin_src js
    function find_end (string, begin)
    {
        let length = string.length;
        let i = begin;
        while (true) {
            if (i === length)
                return i - 1;
            let char = string[i];
            let next = string[i+1];
            if (space_p (char) ||
                delimiter_p (char) ||
                (char === '"'))
                return i - 1;
            if ((char === '.') && (! (digital_char_p (next))))
                return i - 1;
            else
                i = i + 1;
        }
    }
    #+end_src

*** digital_char_p

    #+begin_src js
    function digital_char_p (x)
    {
        return ((x === "0") ||
                (x === "1") ||
                (x === "2") ||
                (x === "3") ||
                (x === "4") ||
                (x === "5") ||
                (x === "6") ||
                (x === "7") ||
                (x === "8") ||
                (x === "9"));
    }
    #+end_src

* sexp

*** [note] syntax sugar

    - [...] -> (begin ...)
    - {...} -> (closure ...)
    - ' ... -> (quote ...)
    - ` ... -> (partquote ...)

*** parse_sexp_vect -- string_vect to sexp_vect

    - sexp := null | cons(sexp, sexp_list) | string

    #+begin_src js
    function parse_sexp_vect (string_vect)
    {
        let length = string_vect.length;
        let i = 0;
        let sexp_vect = [];
        while (i < length) {
            let v = parse_sexp_with_index (string_vect, i);
            let s = v[0];
            i = v[1];
            sexp_vect.push (s);
        }
        return sexp_vect;
    }
    #+end_src

*** parse_sexp

    #+begin_src js
    function parse_sexp_with_index (string_vect, i)
    {
        let string = string_vect[i];
        if (string === '(')
            return parse_sexp_cons_until_ket (string_vect, i+1, ')');
        else if (string === '[') {
            let v = parse_sexp_cons_until_ket (string_vect, i+1, ']');
            let sc = v[0];
            let i1 = v[1];
            return [cons_c ('begin', sc), i1];
        }
        else if (string === '{') {
            let v = parse_sexp_cons_until_ket (string_vect, i+1, '}');
            let sc = v[0];
            let i1 = v[1];
            return [cons_c ('closure', sc), i1];
        }
        else if (string === "'") {
            let v = parse_sexp_with_index (string_vect, i+1);
            let s = v[0];
            let i1 = v[1];
            let sc = cons_c (s, null_c ());
            return [cons_c ('quote', sc), i1];
        }
        else if (string === "`") {
            let v = parse_sexp_with_index (string_vect, i+1);
            let s = v[0];
            let i1 = v[1];
            let sc = cons_c (s, null_c ());
            return [cons_c ('partquote', sc), i1];
        }
        else
            return [string, i+1];
    }
    #+end_src

*** parse_sexp_cons_until_ket

    #+begin_src js
    function parse_sexp_cons_until_ket (string_vect, i, ket)
    {
        let string = string_vect[i];
        if (string == ket)
            return [null_c (), i+1];
        else {
            let v = parse_sexp_with_index (string_vect, i);
            let s = v[0];
            let i1 = v[1];
            let v2 =
                parse_sexp_cons_until_ket (string_vect, i1, ket);
            let sc = v2[0];
            let i2 = v2[1];
            return [cons_c (s, sc), i2];
        }
    }
    #+end_src

*** sexp_repr

    #+begin_src js
    function sexp_repr (sexp)
    {
        if (null_p (sexp))
            return "null-c";
        else if (cons_p (sexp))
            return "(" +  sexp_list_repr (sexp) +  ")";
        else
            return sexp;
    }
    #+end_src

*** sexp_list_repr

    #+begin_src js
    function sexp_list_repr (sexp_cons)
    {
        if (null_p (sexp_cons.cdr))
            return sexp_repr (sexp_cons.car);
        else {
            let car_repr = sexp_repr (sexp_cons.car);
            let cdr_repr = sexp_list_repr (sexp_cons.cdr);
            return car_repr + " " + cdr_repr;
        }
    }
    #+end_src

*** list_to_vect

    #+begin_src js
    function list_to_vect (list)
    {
        if (null_p (list))
            return [];
        else {
            let e = list.car;
            let vect = [e];
            let rest = list.cdr;
            return vect.concat (list_to_vect (rest));
        }
    }
    #+end_src

*** vect_to_list

    #+begin_src js
    function vect_to_list (vect)
    {
        if (vect.length === 0)
            return null_c ();
        else
            return cons_c (vect[0], vect_to_list (vect.slice (1)));
    }
    #+end_src

* eval

*** code_eval

    #+begin_src js
    function code_eval (env, code)
    {
        let string_vect = code_scan (code);
        let sexp_vect = parse_sexp_vect (string_vect);
        sexp_vect_eval (env, sexp_vect);
    }
    #+end_src

*** sexp_vect_eval

    #+begin_src js
    function sexp_vect_eval (env, sexp_vect)
    {
        for (let sexp of sexp_vect) {
            sexp_eval (env, sexp);
        }
    }
    #+end_src

*** sexp_eval

    #+begin_src js
    function sexp_eval (env, sexp)
    {
        assert (cons_p (sexp));
        sexp = apply_all_passes (sexp);
        let name = sexp.car;
        let sexp_list = sexp.cdr;
        let top_keyword_fn = the_top_keyword_dict.get (name);
        if (top_keyword_fn) {
            assert (function_p (top_keyword_fn));
            top_keyword_fn (env, sexp_list);
        }
        else {
            let den = name_dict_get (env, name);
            assert (den instanceof top_macro_den_t);
            data_stack_push (env, sexp_list);
            den.den_exe (env);
        }
    }
    #+end_src

* pass

*** the_pass_vect -- the order of pass_fn matters

    #+begin_src js
    let the_pass_vect = [];
    #+end_src

*** new_pass

    #+begin_src js
    function new_pass (pass_fn)
    {
        the_pass_vect.push (pass_fn);
    }
    #+end_src

*** apply_all_passes

    #+begin_src js
    function apply_all_passes (sexp)
    {
        for (let pass_fn of the_pass_vect) {
            assert (pass_fn instanceof Function);
            sexp = pass_fn (sexp);
        }
        return sexp;
    }
    #+end_src

*** passes

***** pass_for_jojo

      #+begin_src js
      function pass_for_jojo (sexp)
      {
          if (cons_p (sexp) &&
              (sexp.car === "+jojo")) {
              let name = sexp.cdr.car;
              let body = sexp.cdr.cdr;
              body = substitute_recur (name, body);
              return cons_c ("+jojo", cons_c (name, body));
          }
          else
              return sexp;
      }

      new_pass (pass_for_jojo);
      #+end_src

***** substitute_recur

      #+begin_src js
      function substitute_recur (name, sexp)
      {
          if (string_p (sexp)) {
              if (sexp === "recur")
                  return name;
              else
                  return sexp;
          }
          else if (null_p (sexp)) {
              return null_c ();
          }
          else {
              return cons_c (substitute_recur (name, sexp.car),
                             substitute_recur (name, sexp.cdr));
          }
      }
      #+end_src

***** pass_for_field

      - .<field-name> -> (field <field-name>)

      #+begin_src js
      function pass_for_field (sexp)
      {
          if (string_p (sexp)) {
              if (sexp.length <= 1)
                  return sexp;
              let pre_fix =
                  sexp.slice (0, 1);
              if (pre_fix === ".") {
                  sexp = sexp.slice (1, sexp.length);
                  sexp = cons_c (sexp, null_c ());
                  sexp = cons_c ("field", sexp);
                  return sexp;
              }
              else
                  return sexp;
          }
          else if (null_p (sexp)) {
              return null_c ();
          }
          else {
              return cons_c (pass_for_field (sexp.car),
                             pass_for_field (sexp.cdr));
          }
      }

      new_pass (pass_for_field);
      #+end_src

* compile

*** sexp_list_compile

    #+begin_src js
    function sexp_list_compile (sexp_list)
    {
        let sexp_vect = list_to_vect (sexp_list);
        let exp_vect = [];
        for (let sexp of sexp_vect) {
            exp_vect = exp_vect.concat (sexp_compile (sexp));
        }
        return exp_vect;
    }
    #+end_src

*** sexp_compile

    #+begin_src js
    function sexp_compile (sexp)
    {
        if (string_p (sexp)) {
            if (sexp === "apply")
                return [new apply_exp_t ()];
            else if (sexp === "clone")
                return [new clone_exp_t ()];
            else if (sexp === ",")
                return [];
            // ><><><
            // drop dup over tuck swap
            else if (string_string_p (sexp)) {
                let string = string_string_to_string (sexp);
                return [new lit_exp_t (new string_t (string))];
            }
            else if (number_string_p (sexp)) {
                let number = number_string_to_number (sexp);
                return [new lit_exp_t (new number_t (number))];
            }
            else {
                let name = sexp;
                return [new call_exp_t (name)];
            }
        }
        else {
            if (! (cons_p (sexp))) {
                print ("- sexp_compile fail");
                print ("  non sexp :", sexp);
                error ();
            }
            let name = sexp.car;
            let rest_list = sexp.cdr;
            let keyword_fn = the_keyword_dict.get (name);
            if (keyword_fn) {
                assert (function_p (keyword_fn));
                return keyword_fn (rest_list);
            }
            else {
                let den = name_dict_get (env, name);
                assert (den instanceof macro_den_t);
                data_stack_push (env, rest_list);
                den.den_exe (env);
                let new_sexp = data_stack_pop (env);
                return sexp_compile (new_sexp);
            }
        }
    }
    #+end_src

*** string_string_p

    #+begin_src js
    function string_string_p (x)
    {
        if (! (string_p (x)))
            return false;
        else if (x.length <= 1)
            return false;
        else if (x[0] !== '"')
            return false;
        else if (x[x.length -1] !== '"')
            return false;
        else
            return true;
    }
    #+end_src

*** number_string_p

    #+begin_src js
    function number_string_p (number_string)
    {
        if (! (string_p (number_string)))
            return false;
        for (let x of number_string) {
            if (digital_char_p (x))
                return true;
            else if (x === ".")
                return true;
        }
        return false;
    }
    #+end_src

*** number_string_to_number

    #+begin_src js
    function number_string_to_number (number_string)
    {
        return eval (number_string);
    }
    #+end_src

*** string_string_to_string

    #+begin_src js
    function string_string_to_string (ss)
    {
        return ss.slice (1, ss.length -1);
    }
    #+end_src

* epilog

*** eval_code

    #+begin_src js
    function eval_code (code)
    {
        assert (string_p (code));
        let env = new env_t ();
        let top_level_scope = new scope_t ();
        scope_stack_push (env, top_level_scope);
        env_merge (env, the_prim_dict);
        code_eval (env, code);
        return env;
    }
    #+end_src

*** exports

    #+begin_src js
    module.exports.eval_code = eval_code;
    #+end_src
