#+property: tangle simple.jo
#+title: simple

* [todo-stack]

*** no (+gene) and (+disp)

*** fix (case)

*** >< exe

***** new-sum-obj

*** >< infer

***** Type & levels of Type

      - maybe <higher-type-obj>
        such as <<type>> <<functor>> <<monad>>

***** subtype

      - x -
        should we view <<functor>> and <<monad>>
        as subtype of <<type>> ?

      - k -
        but <<functor>> and <<monad>>
        are of form (-> <<type>> -- <<type>>)
        are they subtypes of (-> <<type>> -- <<type>>) ?
        it is (-> <<type>> -- <<type>>) subtype of <<type>> ?

      - x -
        in language like agda and idris
        they are not implemented as subtype of <<type>>
        how ?
        ><><><

      - k -
        in idris, type class is encoded by interface functions.
        subtype relation is also encoded by interface functions.
        could we do the similar ?

      - x -
        if we do so,
        we would need levels of Type
        and every type class must be viewed subtype of Type1

      - k -
        should we try un leveled Type ?
        with [Type : Type]
        and see how it would introduce paradox.

      - x -
        can we see how it is bad by intuition ?
        ><><><

      ------

      - x -
        <<monad>> : (-> <<type>> -- <<type>>)
        <maybe> : <<monad>>
        <maybe> must also of form (-> <<type>> -- <<type>>)

*** >< cut

*** >< unify & cover

***** use (+type <eq>) to test the implemention of unification

*** check

***** >< fun-den-type-check

* [note]

*** upon re-entering the code

    - to re-capture the conceptual model
      is to to renew :
      1. the datatypes
      2. the interface functions
      3. mutual recursiveness

*** as a type checker

    - this interpreter only implements
      the type checker of a programming language.

    - it can execute functions in the language,
      but it can only do so in a non-optimized way.

      - for example, without proper tail call.

    - another interpreter will be implemented
      to execute functions in the language
      in a better way, which will ignore
      much of the informations about type.

    - to really optimize the execution,
      a compiler must be written,
      in which all the informations about type
      can be used to optimize the compilation.

*** proxy to hypo and match

    - in a simple type system,
      there is no hypo obj,
      thus we do not need match obj.

*** mutual recursive

    - exe call infer through ante-prepare
    - infer call cut on <clo-obj>
    - cut call infer on non Den

    ------

    - thus it is hard to incrementally test this implementation

*** <todo-match> to <done-match>

    - x -
      when to change a Match from <todo-match> to <done-match> ?

    - k -
      every time we amend a <hypo-obj>'s value

    - x -
      then, every time we see a <todo-match>
      we know we can not change it to a <done-match> yet
      because we already tried

* <env>

*** <env>

    #+begin_src jojo
    (+data <env>
      .name-dict : [String Den Dict]
      .data-stack : [Obj List]
      .mark-stack : [Nat List]
      .return-stack : [Frame List]
      .local-stack : [String Obj Dict List]
      .goal-stack : [<goal> List]
      .hypo-dict : [<hypo-id> Obj Dict]
      .match-dict : [<match-id> Match Dict])
    #+end_src

*** name-dict

***** name-dict-getget

      #+begin_src jojo
      (+jojo name-dict-getget
        : (-> <env> (: :name String) -- <env> Den)
        dup .name-dict :name dict-get)
      #+end_src

*** data-stack

***** data-stack-push

      #+begin_src jojo
      (+jojo data-stack-push
        : (-> (: :env <env>) (: :obj Obj) -- <env>)
        (clone :env
          .data-stack [:obj :env.data-stack cons]))
      #+end_src

***** data-stack-pop

      #+begin_src jojo
      (+jojo data-stack-pop
        : (-> (: :env <env>) -- <env> Obj)
        (clone :env
          .data-stack [:env.data-stack.cdr])
        :env.data-stack.car)
      #+end_src

***** data-stack-drop

      #+begin_src jojo
      (+jojo data-stack-drop
        : (-> <env> -- <env>)
        data-stack-pop drop)
      #+end_src

***** data-stack-tos

      #+begin_src jojo
      (+jojo data-stack-tos
        : (-> <env> -- <env> Obj)
        dup .data-stack.car)
      #+end_src

***** >< data-stack-n-pop

      #+begin_src jojo
      (+jojo data-stack-n-pop
        : (-> <env> Nat -- <env> Obj List)
        )
      #+end_src

***** >< data-stack-zip-by-list

      #+begin_src jojo
      (+jojo data-stack-zip-by-list
        : (-> <env> (: :list Any List) -- <env> Any Obj Dict)
        )
      #+end_src

*** mark-stack

***** mark-stack-push

      #+begin_src jojo
      (+jojo mark-stack-push
        : (-> (: :env <env>) (: :x Nat) -- <env>)
        (clone :env
          .mark-stack [:x :env.mark-stack cons]))
      #+end_src

***** mark-stack-pop

      #+begin_src jojo
      (+jojo mark-stack-pop
        : (-> (: :env <env>) -- <env> Nat)
        (clone :env
          .mark-stack [:env.mark-stack.cdr])
        :env.mark-stack.car)
      #+end_src

***** mark-stack-mark

      #+begin_src jojo
      (+jojo mark-stack-mark
        : (-> <env> -- <env>)
        dup .data-stack list-length
        mark-stack-push)
      #+end_src

***** mark-stack-collect

      #+begin_src jojo
      (+jojo mark-stack-collect
        : (-> <env> -- <env> Obj List)
        dup .data-stack list-length mark-stack-pop sub
        data-stack-n-pop)
      #+end_src

*** return-stack

***** Frame

      #+begin_src jojo
      (+union Frame
        <scoping-frame>
        <simple-frame>)
      #+end_src

***** <scoping-frame>

      #+begin_src jojo
      (+data <scoping-frame>
        .body : [Exp List]
        .index : Nat)
      #+end_src

***** <simple-frame>

      #+begin_src jojo
      (+data <simple-frame>
        .body : [Exp List]
        .index : Nat)
      #+end_src

***** return-stack-push

      #+begin_src jojo
      (+jojo return-stack-push
        : (-> (: :env <env>) (: :frame Frame) -- <env>)
        (clone :env
          .return-stack [:frame :env.return-stack cons]))
      #+end_src

***** return-stack-pop

      #+begin_src jojo
      (+jojo return-stack-pop
        : (-> (: :env <env>) -- <env> Frame)
        (clone :env
          .return-stack [:env.return-stack.cdr])
        :env.return-stack.car)
      #+end_src

***** return-stack-drop

      #+begin_src jojo
      (+jojo return-stack-drop
        : (-> <env> -- <env>)
        return-stack-pop drop)
      #+end_src

***** return-stack-tos

      #+begin_src jojo
      (+jojo return-stack-tos
        : (-> <env> -- <env> Frame)
        dup .return-stack.car)
      #+end_src

***** top-frame-finished?

      #+begin_src jojo
      (+jojo top-frame-finished?
        : (-> <env> -- <env> Bool)
        return-stack-tos :frame!
        :frame.index :frame.body list-length eq?)
      #+end_src

***** top-frame-next-exp

      #+begin_src jojo
      (+jojo top-frame-next-exp
        : (-> <env> -- <env> Exp)
        return-stack-pop :frame!
        (clone :frame
          .index [:frame.index inc])
        return-stack-push
        :frame.body :frame.index list-ref)
      #+end_src

*** >< local-stack

***** >< local-stack-push

***** >< local-stack-pop

***** >< local-stack-drop

***** >< local-stack-tos

***** local-get

      #+begin_src jojo
      (+jojo local-get dict-get)
      #+end_src

***** local-set

      #+begin_src jojo
      (+jojo local-set
        : (-> String Obj Dict
              (: :local-name String)
              (: :obj Obj)
           -- String Obj Dict)
        (dict :local-name :obj)
        dict-update)
      #+end_src

***** new-local-scope

      #+begin_src jojo
      (+jojo new-local-scope
        : (-> <env> -- <env>)
        (dict) local-stack-push)
      #+end_src

*** goal-stack

***** <goal>

      #+begin_src jojo
      (+data <goal>
        .lhs : [Obj List]
        .rhs : [Obj List]
        .index : Nat)
      #+end_src

*** hypo-dict

***** >< hypo-dict-find -- one step

      #+begin_src jojo
      (+jojo hypo-dict-find
        : (-> <env> <hypo-obj>
           -- <env> (+ Obj true
                     | false))
        ><)
      #+end_src

*** match-dict

***** >< match-dict-get

      #+begin_src jojo
      (+jojo match-dict-get
        : (-> <env> <match-obj>
           -- <env> Match)
       ><)
      #+end_src

* Exp

*** [note] Exp

    - each Exp implement
      1. exe
      2. cut -- for Exp can occur in body

*** Exp

    #+begin_src jojo
    (+union Exp
      <call-exp>
      <get-local-exp>
      <set-local-exp>
      <clo-exp>
      <arrow-exp>
      <match-exp>
      Ins)

    (+type exp-t : type-tt
      call-exp : (-> .name : string-t -- exp-t)
      get-local-exp : (-> .name : string-t -- exp-t)
      set-local-exp : (-> .name : string-t -- exp-t)
      clo-exp : (-> .body : [exp-t list-t] -- exp-t)
      arrow-exp : (-> .ante : [exp-t list-t]
                      .succ : [exp-t list-t] -- exp-t)
      match-exp : (-> .arg : [exp-t list-t]
                      .clause-dict : [string-t clo-exp-t dict-t]
                   -- exp-t))

    (+data exp-t : type-tt
      call-exp [.name : string-t]
      get-local-exp [.name : string-t]
      set-local-exp [.name : string-t]
      clo-exp [.body : exp-t list-t]
      arrow-exp [.ante : exp-t list-t
                 .succ : exp-t list-t]
      match-exp [.arg : exp-t list-t
                 .clause-dict : string-t clo-exp-t dict-t])

    (+data exp-t : type-tt
      call-exp
      [.name : string-t]
      get-local-exp
      [.name : string-t]
      set-local-exp
      [.name : string-t]
      clo-exp
      [.body : exp-t list-t]
      arrow-exp
      [.ante : exp-t list-t
       .succ : exp-t list-t]
      match-exp
      [.arg : exp-t list-t
       .clause-dict : string-t clo-exp-t dict-t])
    #+end_src

*** about eval

***** list-eval

      #+begin_src jojo
      (+jojo list-eval
        : (-> (: :env <env>) (: :exp-list Exp List) -- <env>)
        :env .return-stack list-length :base!
        (create <simple-frame>
           .body :exp-list
           .index 0)
        return-stack-push
        :env :base eval-with-base)
      #+end_src

***** eval-with-base

      #+begin_src jojo
      (+jojo eval-with-base
        : (-> <env> (: :base Nat) -- <env>)
        (when [dup .return-stack list-length :base equal? not]
          eval-one-step :base recur))
      #+end_src

***** eval-one-step -- pop rs

      #+begin_src jojo
      (note it is assumed that
        there is at least one step to exe)

      (+jojo eval-one-step
        : (-> <env> -- <env>)
        (if top-frame-finished?
          (case return-stack-pop
            <scoping-frame> local-stack-drop
            <simple-frame> nop)
          [top-frame-next-exp exe]))
      #+end_src

*** about collect

***** collect-obj-list

      #+begin_src jojo
      (+jojo collect-obj-list
        : (-> <env> Exp List -- <env> Obj List)
        swap mark-stack-mark
        swap list-eval
        mark-stack-collect)
      #+end_src

***** collect-obj

      #+begin_src jojo
      (+jojo collect-obj
        : (-> <env> List -- <env> Obj)
        null cons
        collect-obj-list
        car)
      #+end_src

*** exe -- might push rs

    #+begin_src jojo
    (+gene exe
      : (-> <env> (: :exp Exp) -- <env>)
      "- exe fail" p nl
      "  :exp = " p :exp p nl
      error)
    #+end_src

*** exe -- inline

    #+begin_src jojo
    (+fun exe
      : (-> <env> (: :exp Exp) -- <env>)
      (case :exp
        (<call-exp>
         :exp.name name-dict-getget den-exe)
        (<get-local-exp>
         local-stack-tos :exp.local-name local-get
         data-stack-push)
        (<set-local-exp>
         data-stack-pop :obj!
         local-stack-pop :exp.local-name :obj local-set
         local-stack-push)
        (<clo-exp>
         (create <clo-obj>
           .locals local-stack-tos
           .body [:exp.body])
         data-stack-push)
        (<arrow-exp>
         (create <arrow-obj>
           .ante [:exp.ante collect-obj-list]
           .succ [:exp.succ collect-obj-list])
         data-stack-push)
        (<match-exp>
         :exp.arg collect-obj-list car
         :exp obj-match)))
    #+end_src

*** [note] cut

    - to cut a function
      we only need to use the arrow of the function.

    - to cut the arrow of a function
      is to unify its antecedent
      with the objects in the data-stack,
      and return its succedent as return value.

      - the the values of objects
        is unified with values of the antecedent.
        thus it is a value-value unification.
        [v-v-uni]

    - to cut a hypo
      is to push this objects into data-stack
      and use its type as object.

    - to cut a data such as {succ}
      we must infer its type,
      i.e. an arrow object

    ------

    - x -
      when cutting a <fun-den>
      the argument in the ds might be <sum-obj>
      the result of the cut must also be <sum-obj>

*** cut

    #+begin_src jojo
    (+gene cut
      : (-> (: :env <env>) (: :exp Exp) -- <env>)
      error)
    #+end_src

*** >< list-cut

    #+begin_src jojo
    (+jojo list-cut
      : (-> <env> (: :exp-list Exp List) -- <env>)
      )
    #+end_src

*** <call-exp>

    #+begin_src jojo
    (+data <call-exp>
      .name : String)
    #+end_src

*** <call-exp> exe

    #+begin_src jojo
    (+disp exe : (-> <env> (: :exp <call-exp>) -- <env>)
      :exp.name name-dict-getget den-exe)
    #+end_src

*** <get-local-exp>

    #+begin_src jojo
    (+data <get-local-exp>
      .local-name : String)
    #+end_src

*** <get-local-exp> exe

    #+begin_src jojo
    (+disp exe
      : (-> <env> (: :exp <get-local-exp>) -- <env>)
      local-stack-tos :exp.local-name local-get
      data-stack-push)
    #+end_src

*** <set-local-exp>

    #+begin_src jojo
    (+data <set-local-exp>
      .local-name : String)
    #+end_src

*** <set-local-exp> exe

    #+begin_src jojo
    (+disp exe
      : (-> <env> (: :exp <set-local-exp>) -- <env>)
      data-stack-pop :obj!
      local-stack-pop :exp.local-name :obj local-set
      local-stack-push)
    #+end_src

*** <clo-exp>

    #+begin_src jojo
    (+data <clo-exp>
      .body : [Exp List])
    #+end_src

*** <clo-exp> exe

    #+begin_src jojo
    (+disp exe
      : (-> <env> (: :exp <clo-exp>) -- <env>)
      (create <clo-obj>
        .locals local-stack-tos
        .body [:exp.body])
      data-stack-push)
    #+end_src

*** <arrow-exp>

    #+begin_src jojo
    (+data <arrow-exp>
      .ante : [Exp List]
      .succ : [Exp List])
    #+end_src

*** <arrow-exp> exe

    #+begin_src jojo
    (+disp exe
      : (-> <env> (: :exp <arrow-exp>) -- <env>)
      (create <arrow-obj>
        .ante [:exp.ante collect-obj-list]
        .succ [:exp.succ collect-obj-list])
      data-stack-push)
    #+end_src

*** <match-exp>

    #+begin_src jojo
    (+data <match-exp>
      .arg : [Exp List]
      .clause-dict : [String <clo-exp> Dict])
    #+end_src

*** <match-exp> exe

    #+begin_src jojo
    (+disp exe
      : (-> <env> (: :exp <match-exp>) -- <env>)
      :exp.arg collect-obj-list car
      :exp obj-match)
    #+end_src

*** [note] obj-match

    - when .arg of <match-exp> eval to

      1. <data-cons-obj>
         by the name of the cons
         we can decide which branch to go

      2. <hypo-obj>
         if <hypo-obj> has not bound to value
         we can not decide which branch to go
         a new <match-obj> will be created

*** >< obj-match

    #+begin_src jojo
    (+jojo obj-match
      : (-> <env>
            (: :obj Obj)
            (: :match-exp <match-exp>)
         -- <env>)
      (case :obj
        <data-cons-obj>
        [:obj.data-cons-name
         :match-exp.clause-dict
         dict-get collect-obj
         clo-obj-apply]
        <hypo-obj>
        (if [:obj hypo-dict-find]
          [:match-exp recur]
          [:obj :match-exp new-match-obj
           data-stack-push])
        <match-obj>
        [><><><]
        else error))
    #+end_src

*** new-match-obj

    #+begin_src jojo
    (+jojo new-match-obj
      : (-> <env>
            (: :obj <hypo-obj>)
            (: :match-exp <match-exp>)
         -- <env> <match-obj>)
      :match-exp.clause-dict eval-clause-dict :clause-dict!
      :obj :clause-dict new-sum-obj :sum-obj!
      (create <todo-match>
        .type :sum-obj
        .arg :obj
        .clause-dict :clause-dict))
    #+end_src

*** >< eval-clause-dict

    #+begin_src jojo
    (+jojo eval-clause-dict
      : (-> <env> String <clo-exp> Dict
         -- <env> String <clo-obj> Dict))
    #+end_src

*** [note] new-sum-obj

    - given the data-constructor
      ><><>< hypo argument
      the type of each branch of a (match) can be known

*** >< new-sum-obj

    #+begin_src jojo
    (+jojo new-sum-obj
      : (-> <env>
            (: :obj <hypo-obj>)
            (: :clause-dict [String <clo-obj> Dict])
         -- <env> <sum-obj>)
       )
    #+end_src

*** >< clo-obj-apply

    #+begin_src jojo
    (+jojo clo-obj-apply
      : (-> <env> <clo-obj> -- <env>)
      )
    #+end_src

* >< Ins

*** [note] Ins

    - 'Ins' denotes 'instruction'

    - an Ins is a special Exp
      in the sense that
      as a data it has no fields

*** [note] about hypothetically constructed object

    - in oop,
      when you ask for a new object of a class,
      the init function of the class is used
      to form an object of that class.
      [the init function might takes arguments]

    - in jojo,
      when you ask for a new object of a type,

      1. the type might has many data-constructors,
         we do not know
         which data-constructors should be used,
         thus a hypo will be created.

      2. the type might has only one data-constructor.
         but it takes arguments,
         we do not have the arguments yet,
         thus a hypo will be created.

*** [note] <suppose-ins>

    - [:n : <nat>]
      compiles to
      [<nat> suppose dup :n! infer]

    - two occurences of [<nat> suppose]
      create two different <hypo-obj>s.

*** <suppose-ins>

    #+begin_src jojo
    (+data <suppose-ins>)
    #+end_src

*** <suppose-ins> exe

    #+begin_src jojo
    (+disp exe
      : (-> <env> (: :ins <suppose-ins>) -- <env>)
      data-stack-pop :type!
      generate-hypo-id :hypo-id!
      (create <hypo-type-obj>
        .hypo-id :hypo-id
        .type :type)
      :hypo-type-obj!
      (create <hypo-obj>
        .hypo-id :hypo-id
        .hypo-type :hypo-type-obj)
      data-stack-push)
    #+end_src

*** >< <dup-ins>

*** <infer-ins>

    #+begin_src jojo
    (+data <infer-ins>)
    #+end_src

*** >< <infer-ins> exe

    #+begin_src jojo
    (+disp exe
      : (-> <env> (: :ins <infer-ins>)-- <env>)
      )
    #+end_src

*** >< <apply-ins>

* Den

*** [note] Den

    - each Den must implement
      1. den-exe
      2. den-cut

*** Den

    #+begin_src jojo
    (+union Den
      <fun-den>
      <data-cons-den>
      <type-cons-den>)
    #+end_src

*** den-exe

    #+begin_src jojo
    (+gene den-exe
      : (-> (: :env <env>) (: :den Den) -- <env>)
      "- den-exe fail" p nl
      "  unknown den : " p :den p nl
      error)
    #+end_src

*** >< den-cut

    #+begin_src jojo
    (+gene den-cut
      ><)
    #+end_src

*** [note] <fun-den>

    - to execute a function
      is to apply a function
      to objects in the data-stack.

    - when you execute a function,
      a new arrow object will be created
      from the type of the function.

    - the antecedent is used
      to do an unification with the objects in the data-stack.

    - note that,
      new-frame will be formed for each function call,
      to give them new scope for local bindings.

*** <fun-den>

    #+begin_src jojo
    (+data <fun-den>
      .type : <arrow-exp>
      .body : [Exp List])
    #+end_src

*** <fun-den> den-exe

    #+begin_src jojo
    (+disp den-exe
      : (-> <env> (: :den <fun-den>) -- <env>)
      new-local-scope
      :den.type collect-obj :type!
      :type.ante ante-prepare
      :type.ante ante-correspond
      (create <scoping-frame>
        .body :den.body
        .index 0)
      return-stack-push)
    #+end_src

*** <data-cons-den>

    #+begin_src jojo
    (+data <data-cons-den>
      .type : Exp
      .data-cons-name : String
      .field-name-list : [String List]
      .type-cons-name : String)
    #+end_src

*** <data-cons-den> den-exe

    #+begin_src jojo
    (+disp den-exe
      : (-> <env> (: :den <data-cons-den>)
         -- <env>)
      :den.type collect-obj :type!
      :type.ante ante-prepare
      :den.field-name-list data-stack-zip-by-list :fields!
      (create <data-cons-obj>
        .type :type type->return-type
        .data-cons-name :den.data-cons-name
        .fields :fields)
      data-stack-push)
    #+end_src

*** <type-cons-den>

    #+begin_src jojo
    (+data <type-cons-den>
      .type : Exp
      .type-cons-name : String
      .field-name-list : [String List]
      .data-cons-name-list : [String List])
    #+end_src

*** <type-cons-den> den-exe

    #+begin_src jojo
    (+disp den-exe
      : (-> <env> (: :den <type-cons-den>)
         -- <env>)
      :den.type collect-obj :type!
      :type.ante ante-prepare
      :den.field-name-list data-stack-zip-by-list :fields!
      (create <type-cons-obj>
        .type :type type->return-type
        .type-cons-name :den.type-cons-name
        .fields :fields)
      data-stack-push)
    #+end_src

*** [note] ante-prepare

    1. get Obj List from ds of length of ante

    2. Obj List infer and unifiy with ante

       - this unification can let us write less types.
         for example, if we know 'add' is going to be applied
         to :x, we do not need to assert [:x : <nat>]

       - this unification might be part of the type-checking,
         because function application
         can happen during type-checking.
         if it fails, type-check fails.

       - data-constructors are special functions.
         thus they also do such unification.

*** ante-prepare

    #+begin_src jojo
    (+jojo ante-prepare
      : (-> <env> (: :ante Obj List) -- <env>)
      :ante list-length data-stack-n-pop :obj-list!
      :obj-list {infer} list-map :ante list-unifiy)
    #+end_src

*** [note] ante-correspond

    1. for <hypo-type-obj> in ante
       type->obj and unifiy with corresponding Obj

    2. put those Obj s
       that not correspond with <hypo-type-obj>
       back to ds

    ------

    - note that, in ante,
      the occurance of <hypo-type-obj>,
      is used as a criterion to take value out of ds.
      - not the occurance of local name.

*** >< ante-correspond

    #+begin_src jojo
    (+jojo ante-correspond
      : (-> <env> (: :ante Obj List) -- <env>)
      )
    #+end_src

*** type->return-type

    #+begin_src jojo
    (+jojo type->return-type
      : (-> Obj -- Obj)
      (when [dup arrow-obj?]
        .succ .car))
    #+end_src

* Obj

*** [note] Obj

    - each Obj must implement
      1. infer
      2. cover
      3. unify

*** Obj

    #+begin_src jojo
    (+union Obj
      <data-cons-obj> <type-cons-obj>
      <clo-obj> <arrow-obj>
      <hypo-obj> <hypo-type-obj>
      <match-obj> <sum-obj>)
    #+end_src

*** infer

    #+begin_src jojo
    (+gene infer
      : (-> (: :env <env>) (: :obj Obj) -- <env> Obj)
      error)
    #+end_src

*** [note] sub term lattice & subtype relation

    - ><

*** >< list-unifiy

    #+begin_src jojo
    (+jojo list-unifiy
      : (-> <env> (: :l Obj List) (: :r Obj List) -- <env>)
      )
    #+end_src

*** >< unify-one-step

    #+begin_src jojo
    (+jojo unify-one-step
      : (-> <env> -- <env>)
      )
    #+end_src

*** unify

    #+begin_src jojo
    (+gene unify
      : (-> <env> Obj Obj -- <env>)
      )
    #+end_src

*** list-cover

    #+begin_src jojo
    (+jojo list-cover
      : (-> <env> Obj List Obj List
         -- <env>))
    #+end_src

*** <data-cons-obj>

    #+begin_src jojo
    (+data <data-cons-obj>
      .type : <type-cons-obj>
      .data-cons-name : String
      .fields : [String Obj Dict])
    #+end_src

*** >< <data-cons-obj> infer

    #+begin_src jojo
    (+disp infer
     : (-> <env> <data-cons-obj>
        -- <env> <type-cons-obj>)
     )
    #+end_src

*** <type-cons-obj>

    #+begin_src jojo
    (+data <type-cons-obj>
      .type : <higher-type-obj>
      .type-cons-name : String
      .fields : [String Obj Dict])
    #+end_src

*** >< <type-cons-obj> infer

    #+begin_src jojo
    (+disp infer
     : (-> <env> <type-cons-obj>
        -- <env> <type-cons-obj>))
    #+end_src

*** <clo-obj>

    #+begin_src jojo
    (+data <clo-obj>
      .locals : [String Obj Dict]
      .body : [Exp List])
    #+end_src

*** >< <clo-obj> infer

    #+begin_src jojo
    (note every time the the type of a closure is asked for,
      we use the body of the closure
      to construct a new arrow object.)

    (+disp infer
     : (-> <env> <clo-obj>
        -- <env> <arrow-obj>))
    #+end_src

*** <arrow-obj>

    #+begin_src jojo
    (+data <arrow-obj>
      .ante : [Obj List]
      .succ : [Obj List])
    #+end_src

*** >< <arrow-obj> infer

    #+begin_src jojo
    (+disp infer
     : (-> <env> <arrow-obj>
        -- <env> <arrow-obj>))
    #+end_src

*** [note] <hypo-obj> & <hypo-type-obj>

    - <hypo-obj> is the hero of unification.

    - <hypo-obj> denotes "hypothetically constructed object"
      whose type is known, but value is unknown for now.

      - a phrase learned from Arend Heyting
        << Intuitionistic Views on the Nature of Mathematics >>

    - in the future,
      unification-stack will be used
      to bind <hypo-obj>'s value.

      - a <hypo-obj> can be viewed as a proxy to actual Obj
        [through unification-stack].

    - be careful about
      'information non-decreasing principle'
      when asked for the type of a <hypo-obj>
      we must maintain the type is of which <hypo-obj>.

      thus <hypo-type-obj> is used

    - <hypo-obj> infer <hypo-type-obj>
      <hypo-type-obj> type->obj <hypo-obj>

      - note that
        <hypo-type-obj> is the only Obj
        which 'type->obj' can applied to

*** <hypo-id>

    #+begin_src jojo
    (+data <hypo-id>
      .id : String)
    #+end_src

*** <hypo-obj>

    #+begin_src jojo
    (+data <hypo-obj>
      .hypo-id : <hypo-id>
      .hypo-type : <hypo-type-obj>)
    #+end_src

*** >< <arrow-obj> infer

    #+begin_src jojo
    (+disp infer
      : (-> <env> <hypo-obj>
         -- <env> <hypo-type-obj>))
    #+end_src

*** <hypo-type-obj>

    #+begin_src jojo
    (+data <hypo-type-obj>
      .hypo-id : <hypo-id>
      .type : Obj)
    #+end_src

*** >< <hypo-type-obj> infer

    #+begin_src jojo
    (+disp infer
      : (-> <env> <hypo-type-obj>
         -- <env> ><><><))
    #+end_src

*** >< hypo-type-obj->hypo-obj

    #+begin_src jojo
    (+jojo hypo-type-obj->hypo-obj
      : (-> <env> <hypo-type-obj>
         -- <env> <hypo-obj>))
    #+end_src

*** [note] <match-obj> & <sum-obj>

    - <match-obj> proxy to Match
      for the state of Match
      might can change from <todo-match> to <done-match>

    - the type of <todo-match>
      is <sum-obj>

    - the type of <done-match>
      is one branch of the <sum-obj>

*** <match-id>

    #+begin_src jojo
    (+data <match-id>
      .id : String)
    #+end_src

*** <match-obj>

    #+begin_src jojo
    (+data <match-obj>
      .match-id : <match-id>)
    #+end_src

*** >< <match-obj> infer

    #+begin_src jojo
    (+disp infer
     : (-> <env> <match-obj>
        -- <env> Obj))
    #+end_src

*** Match

    #+begin_src jojo
    (+union Match
      <todo-match>
      <done-match>)

    (+data <todo-match>
      .type : <sum-obj>
      .arg : <hypo-obj>
      .clause-dict : [String <clo-obj> Dict])

    (+data <done-match>
      .type : Obj
      .result : Obj)
    #+end_src

*** <sum-obj>

    #+begin_src jojo
    (+data <sum-obj>
      .objs : [Obj List])
    #+end_src

*** >< <sum-obj> infer

    #+begin_src jojo
    (+disp infer
     : (-> <env> <sum-obj>
        -- <env> <sum-obj>))
    #+end_src

* check

*** [note] fun-den-type-check

    - to type-check a function definition,
      [of which the type exp must be a <arrow-exp>]
      1. we first exe the ante of the <arrow-exp>
      2. and cut the body exp to it
         and collect the result
      3. exe the succ of the <arrow-exp>
         cover it to the result of cut

*** fun-den-type-check

    #+begin_src jojo
    (+jojo fun-den-type-check
      : (-> <env> (: :den <fun-den>))
      mark-stack-mark
      :den.type.ante list-eval
      :den.body list-cut
      mark-stack-collect :results!
      :den.type.succ collect-obj-list
      :results list-cover)
    #+end_src
