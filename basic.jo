(+data <null>)
(+data <cons> .cdr .car)

(+jojo list-print :f! :l!
  (case :l
    <null> ["null" string-write space]
    <cons> [:l .cdr :f (recur)
            :l .car :f apply space
            "cons" string-write space]))

(note

  (+var list-0
    null
    1 cons
    2 cons)

  (run list-0 (% int-write) list-print))

(note
  (+jojo t0 1 :a0! 2 :b0! (% :a0 :b0 add))
  (run t0 dup
    apply int-write space
    apply int-write space
    newline)

  (+jojo t1 1 :a! 2 :b! (% :a (% :b t0 apply add)))
  (run t1 apply apply add)


  (+jojo t0 1 :a! (% :a))
  (+jojo t1 2 :a! (% (% t0 apply)))
  (run t1 apply apply)


  (+jojo t0 1 :a! (% :a))
  (+jojo t1 2 :a! (% (% t0)))
  (run t1 apply apply apply)

  (+jojo t0 1 :a! (% :a))
  (+jojo t1 (% (% t0 apply)))
  (run t1 apply apply)

  (run t1 apply))

(note
  (+jojo com :m1! :m2!
   (% :m2 apply
      :m1 apply))
  (run (% 1) (% 2) com apply add int-write)
  (run (% 1) (% 2) com (% 3) com apply add add int-write)
  (run (% 1) (% 2) (% 3) com com apply add add int-write)
  (run step (% 1) (% 2) (% 3) com com apply add add int-write))

(+var server "8888" 5 tcp-socket-listen)
(+jojo run-server
  server socket-accept :addr! :client!
  "got a connection from " string-write :addr string-write newline
  :client "thank you for connecting" socket-send
  :client close (loop))
(note (run run-server))

(+var clinet "cicada" "8888" tcp-socket-connect)
(+jojo run-clinet
  clinet socket-recv string-write newline)
(note (run run-clinet))

(+data <nothing>)
(+data <just> .v)

(+data <leaf> .v)
(+data <node> .l .r)

(+jojo tree-write :f! :t!
  (note [tree fun] -> [])
  (case :t
    <leaf> [:t .v :f apply "leaf" string-write space]
    <node> [:t .l :f (recur)
            :t .r :f (recur) "node" string-write space]))

(+jojo tree-map :f! :t!
  (note [tree fun] -> [tree])
  (case :t
    <leaf> [:t .v :f apply leaf]
    <node> [:t .l :f (recur)
            :t .r :f (recur) node]))

(+var a-tree
  1 leaf 2 leaf node
  3 leaf 4 leaf node
  5 leaf node
  node)

(run a-tree
  (% 100 add) tree-map
  (% int-write space) tree-write)

(+jojo maybe-nothing :m1! :m2!
  (% :m2 apply
     (if dup nothing? then end)
     :m1 apply))

(note not ok
  can not call maybe-nothing twice ?
  (+jojo zip-tree :t1! :t2!
    (note [tree tree] -> [tree | nothing])
    (cond [:t1 leaf? :t2 leaf? and]
          [:t1 .v :t2 .v cons leaf]
          [:t1 node? :t2 node? and]
          [(% :t1 .l :t2 .l zip-tree)
           (% :t1 .r :t2 .r zip-tree)
           (% node)
           maybe-nothing
           maybe-nothing
           apply]
          else nothing)))

(+jojo zip-tree :t1! :t2!
  (note [tree tree] -> [tree | nothing])
  (cond [:t1 leaf? :t2 leaf? and]
        [:t1 .v :t2 .v cons leaf]
        [:t1 node? :t2 node? and]
        [(% :t1 .l :t2 .l zip-tree)
         (% :t1 .r :t2 .r zip-tree
            (if dup nothing? then end)
            node)
         maybe-nothing apply]
        else nothing))

(note ok
  (+jojo zip-tree :t1! :t2!
    (note [tree tree] -> [tree | nothing])
    (cond [:t1 leaf? :t2 leaf? and]
          [:t1 .v :t2 .v cons leaf]
          [:t1 node? :t2 node? and]
          [(% :t1 .l :t2 .l zip-tree)
           (% :t1 .r :t2 .r zip-tree
              (if dup nothing? then end)
              node)
           maybe-nothing apply]
          else nothing)))

(note ok
  (+jojo zip-tree :t1! :t2!
    (note [tree tree] -> [tree | nothing])
    (cond [:t1 leaf? :t2 leaf? and]
          [:t1 .v :t2 .v cons leaf]
          [:t1 node? :t2 node? and]
          [:t1 .l :t2 .l zip-tree (if dup nothing? then end)
           :t1 .r :t2 .r zip-tree (if dup nothing? then end)
           node]
          else nothing)))

(+jojo write-tree-or-nothing
  (if dup nothing? then drop "nothing" string-write end)
  (el (% dup .cdr int-write space
         .car int-write space
         "cons" string-write space)
      tree-write))

(run
  a-tree 1 leaf zip-tree
  write-tree-or-nothing)

(run
  1 leaf a-tree zip-tree
  write-tree-or-nothing)

(run
  a-tree 1 leaf 1 leaf node zip-tree
  write-tree-or-nothing)

(run
  1 leaf 1 leaf node a-tree zip-tree
  write-tree-or-nothing)

(run
  a-tree dup zip-tree
  write-tree-or-nothing)

(+jojo number-tree
  (note (-> <int>, :<t> <tree> -- <int>, <int> <tree>))
  :t!
  (case :t
    <leaf> [dup inc swap leaf]
    <node> [:t .l (recur) :l!
            :t .r (recur) :r!
            :l :r node]))

(+var tree-2
  "1" leaf "2" leaf node
  "3" leaf "4" leaf node
  "5" leaf node
  node)

(run
  tree-2
  0 swap number-tree
  swap drop
  (% int-write space) tree-write newline)
