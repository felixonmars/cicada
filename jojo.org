#+HTML_HEAD: <link rel="stylesheet" href="http://xieyuheng.github.io/asset/css/page.css" type="text/css" media="screen" />
#+PROPERTY: tangle jojo.c
#+TITLE:  jojo

---------

- the implementation of the interpreter ([[https://github.com/xieyuheng/jojo][source]])

---------

* todo

  - module system
  - string
  - vector
  - fix jump

* helper

*** header

    #+begin_src c
    #include <stdio.h>
    #include <ctype.h>
    #include <stdlib.h>
    #include <stdint.h>
    #include <setjmp.h>
    #include <string.h>
    #include <dlfcn.h>
    #+end_src

*** bool

    #+begin_src c
    typedef enum { false, true } bool;
    #+end_src

*** number

    #+begin_src c
    int max(int a, int b) {
      if (a < b) {
        return b;
      }
      else {
        return a;
      }
    }

    int min(int a, int b) {
      if (a > b) {
        return b;
      }
      else {
        return a;
      }
    }
    #+end_src

*** char

    #+begin_src c
    bool isbarcket(char c) {
      return (c == '(' ||
              c == ')' ||
              c == '[' ||
              c == ']' ||
              c == '{' ||
              c == '}');
    }
    #+end_src

*** string

***** string

      #+begin_src c
      typedef char* string;
      #+end_src

***** string_equal

      #+begin_src c
      bool string_equal(string s1, string s2) {
        if (strcmp(s1, s2) == 0) {
          return true;
        }
        else {
          return false;
        }
      }
      #+end_src

***** nat_string_p

      #+begin_src c
      bool nat_string_p(string str) {
        int i = 0;
        while (str[i] != 0) {
          if (!isdigit(str[i])) {
            return false;
            }
          i++;
        }
        return true;
      }
      #+end_src

***** int_string_p

      #+begin_src c
      bool int_string_p(string str) {
        if (str[0] == '-' ||
            str[0] == '+') {
          return nat_string_p(str + 1);
        }
        else {
          return nat_string_p(str);
        }
      }
      #+end_src

* hashtable

*** primitive

    #+begin_src c
    typedef void (*primitive)();
    #+end_src

*** name & jojo

    #+begin_src c
    typedef int name;

    typedef struct {
      int size;
      name *array;
    } jojo;
    #+end_src

*** bind & nametable_entry

    #+begin_src c
    typedef union {
      int cell;
      primitive primitive;
      jojo jojo;
    } bind;

    typedef struct {
      int index;
      string key;
      name type;
      bind value;
      int orbit_length;
      int orbiton;
    } nametable_entry;
    #+end_src

*** new_nametable_entry

    #+begin_src c
    name k2n (string str);

    nametable_entry new_nametable_entry(int index) {
      nametable_entry e = {
        .index = index,
        .key = 0,
        .type = k2n("none"),
        .value.cell = 0,
        .orbit_length = 0,
        .orbiton = 0
      };
      return e;
    }
    #+end_src

*** nametable_entry_[occured|entry_used|no_collision]

    #+begin_src c
    bool nametable_entry_occured(nametable_entry e) {
      return e.key != 0;
    }

    bool nametable_entry_used(nametable_entry e) {
      return e.type != k2n("none");
    }

    bool nametable_entry_no_collision(nametable_entry e) {
      return e.index == e.orbiton;
    }
    #+end_src

*** nametable

    #+begin_src c
    // prime table size
    //   1000003   about 976 k
    //   1000033
    //   1000333
    //   100003    about 97 k
    //   100333
    //   997
    #define nametable_size 100003
    nametable_entry nametable[nametable_size];
    int nametable_counter = 0;
    #+end_src

*** string_to_sum

    #+begin_src c
    int string_to_sum(string str) {
      int sum = 0;
      int max_step = 10;
      int i = 0;
      while (i < strlen(str)) {
        sum = sum + str[i] * (2 << min(i, max_step));
        i++;
      }
      return sum;
    }
    #+end_src

*** nametable_keyeq

    #+begin_src c
    bool nametable_keyeq(string k1, string k2) {
      return string_equal(k1, k2);
    }
    #+end_src

*** nametable_hash

    #+begin_src c
    int nametable_hash(string key, int counter) {
      return (counter + string_to_sum(key)) % nametable_size;
    }
    #+end_src

*** string_area

    #+begin_src c
    char string_area[4 * 1024 * 1024];
    int string_area_counter = 0;
    #+end_src

*** copy_to_string_area

    #+begin_src c
    string copy_to_string_area(string str) {
      char *str1;
      int i = 0;
      str1 = (string_area + string_area_counter);
      while (true) {
        if (str[i] == 0) {
          str1[i] = str[i];
          i++;
          break;
        }
        else {
          str1[i] = str[i];
          i++;
        }
      }
      string_area_counter = i + string_area_counter;
      return str1;
    }
    #+end_src

*** nametable_insert

    #+begin_src c
    // -1 denotes the hash_table is filled
    int nametable_insert(string key) {
      int orbit_index = nametable_hash(key, 0);
      int counter = 0;
      while (true) {
        int index = nametable_hash(key, counter);
        if (!nametable_entry_occured(nametable[index])) {
          key = copy_to_string_area(key);
          nametable[index].key = key;
          nametable[index].orbiton = orbit_index;
          nametable[orbit_index].orbit_length = 1 + counter;
          nametable_counter = 1 + nametable_counter;
          return index;
        }
        else if (nametable_keyeq(key, nametable[index].key)) {
          return index;
        }
        else if (counter == nametable_size) {
          return -1;
        }
        else {
          counter = 1 + counter;
        }
      }
    }
    #+end_src

*** nametable_search

    #+begin_src c
    // -1 denotes key not occured
    int nametable_search(string key) {
      int counter = 0;
      while (true) {
        int index = nametable_hash(key, counter);
        if (!nametable_entry_occured(nametable[index])) {
          return -1;
        }
        else if (nametable_keyeq(key, nametable[index].key)) {
          return index;
        }
        else if (counter == nametable_size) {
          return -1;
        }
        else {
          counter = 1 + counter;
        }
      }
    }
    #+end_src

*** nametable_entry_print

    #+begin_src c
    string n2k (int index);

    void nametable_entry_print(nametable_entry entry) {
      printf("%s : ", n2k(entry.type));
      if (entry.type == k2n("cell")) {
        printf("%d", entry.value.cell);
      }
      else if (entry.type == k2n("primitive")) {
        printf("%d", entry.value.primitive);
      }
      else if (entry.type == k2n("jojo")) {
        printf("%d ", entry.value.jojo.size);
        printf("[ ", entry.value.jojo.size);
        int i;
        for (i=0; i < entry.value.jojo.size; i=i+1) {
          printf("%d ", entry.value.jojo.array[i]);
        }
        printf("]", entry.value.jojo.size);
      }
    }
    #+end_src

*** nametable_report_orbit

    #+begin_src c
    void nametable_report_orbit(int index, int counter) {
      while (counter < nametable[index].orbit_length) {
        string key = nametable[index].key;
        int next_index = nametable_hash(key, counter);
        if (index == nametable[next_index].orbiton) {
          printf("  - %d %s\n", next_index, nametable[next_index].key);
        }
        if (nametable_entry_used(nametable[next_index])) {
          printf("    = ");
          nametable_entry_print(nametable[next_index]);
          printf("\n");
        }
        counter = 1 + counter;
      }
    }
    #+end_src

*** nametable_report

    #+begin_src c
    void nametable_report() {
      printf("\n");
      printf("- nametable_report\n");
      printf("  : <index> <key> // <orbit-length>\n");
      int index = 0;
      while (index < nametable_size) {
        if (nametable_entry_occured(nametable[index]) &&
            nametable_entry_no_collision(nametable[index])) {
          printf("  - %d %s // %d\n",
                 index, nametable[index].key, nametable[index].orbit_length);
          if (nametable_entry_used(nametable[index])) {
            printf("    = ");
            nametable_entry_print(nametable[index]);
            printf("\n");
          }
          nametable_report_orbit(index, 1);
        }
        index = 1 + index;
      }
      printf("  : <index> <key> // <orbit-length>\n");
      printf("\n");
      printf("- used : %d\n", nametable_counter);
      printf("- free : %d\n", nametable_size - nametable_counter);
    }
    #+end_src

*** nametable_print

    #+begin_src c
    void nametable_print() {
      printf("\n");
      printf("- nametable_print\n");
      int index = 0;
      while (index < nametable_size) {
        printf("  - %d %s %d // %d\n",
               index,
               nametable[index].key,
               nametable[index].value,
               nametable[index].orbit_length);
        index = 1 + index;
      }
      printf("\n");
      printf("- used : %d\n", nametable_counter);
      printf("- free : %d\n", nametable_size - nametable_counter);
    }
    #+end_src

*** k2n & n2k

    #+begin_src c
    name k2n(string str) {
      return nametable_insert(str);
    }

    string n2k(int index) {
      return nametable[index].key;
    }
    #+end_src

*** init_nametable

    #+begin_src c
    void init_nametable() {
      int i = 0;
      while (i < nametable_size) {
        nametable[i] = new_nametable_entry(i);
        i++;
      }
    }
    #+end_src

*** jojo_area

    #+begin_src c
    name jojo_area[1024 * 1024];
    int jojo_area_counter = 0;
    #+end_src

*** here

    #+begin_src c
    void here(int n) {
      jojo_area[jojo_area_counter] = n;
      jojo_area_counter++;
    }
    #+end_src

*** nametable_set_cell

    #+begin_src c
    void nametable_set_cell(int index, int cell) {
      nametable[index].type = k2n("cell");
      nametable[index].value.cell = cell;
    }
    #+end_src

*** nametable_set_primitive

    #+begin_src c
    void nametable_set_primitive(int index, primitive primitive) {
      nametable[index].type = k2n("primitive");
      nametable[index].value.primitive = primitive;
    }
    #+end_src

*** nametable_get_cell

    #+begin_src c
    int nametable_get_cell(int index) {
      return nametable[index].value.cell;
    }
    #+end_src

*** nametable_get_primitive

    #+begin_src c
    primitive nametable_get_primitive(int index) {
      return nametable[index].value.primitive;
    }
    #+end_src

*** nametable_get_jojo

    #+begin_src c
    jojo nametable_get_jojo(int index) {
      return nametable[index].value.jojo;
    }
    #+end_src

*** test

    #+begin_src c
    void nametable_test() {
      k2n("testkey0");
      k2n("testkey1");
      k2n("testkey2");
      k2n("testkey3");
      k2n("testkey4");

      k2n("testkey0");
      k2n("testkey1");
      k2n("testkey2");
      k2n("testkey3");
      k2n("testkey4");

      k2n("testtestkey0");
      k2n("testtestkey1");
      k2n("testtestkey2");
      k2n("testtestkey3");
      k2n("testtestkey4");

      k2n("testtesttestkey0");
      k2n("testtesttestkey1");
      k2n("testtesttestkey2");
      k2n("testtesttestkey3");
      k2n("testtesttestkey4");

      k2n("testtesttesttestkey0");
      k2n("testtesttesttestkey1");
      k2n("testtesttesttestkey2");
      k2n("testtesttesttestkey3");
      k2n("testtesttesttestkey4");

      nametable_set_cell(k2n("k1"), 1);
      nametable_report();

      nametable_set_cell(k2n("k1"), 0);
      nametable_report();

      // nametable_print();
    }
    #+end_src

* as & rs

*** as

    #+begin_src c
    typedef int argument_stack[1024 * 4];

    argument_stack as;
    int as_base = 64;
    int as_pointer = 64;

    void as_push(int value) {
      as[as_pointer] = value;
      as_pointer++;
    }

    int as_pop() {
      as_pointer--;
      return as[as_pointer];
    }
    #+end_src

*** rs

    #+begin_src c
    typedef name* return_stack[1024 * 4];

    return_stack rs;
    int rs_base = 64;
    int rs_pointer = 64;

    void rs_push(name* value) {
      rs[rs_pointer] = value;
      rs_pointer++;
    }

    name* rs_pop() {
      rs_pointer--;
      return rs[rs_pointer];
    }
    #+end_src

* define

*** define_primitive

    #+begin_src c
    void define_primitive(string str, primitive fun) {
      name index = k2n(str);
      nametable_set_primitive(index, fun);
    }
    #+end_src

*** define_function

    #+begin_src c
    void define_function(string str, int size, string *str_array) {
      name index = k2n(str);
      int i;
      name *array;
      array = (jojo_area + jojo_area_counter);
      for (i=0; i < size; i=i+1) {
        array[i] = k2n(str_array[i]);
      }
      jojo_area_counter = size + jojo_area_counter;
      nametable[index].type = k2n("jojo");
      nametable[index].value.jojo.size = size;
      nametable[index].value.jojo.array = array;
    }
    #+end_src

*** define_variable

    #+begin_src c
    void define_variable(string str, int cell) {
      name index = k2n(str);
      nametable_set_cell(index, cell);
    }
    #+end_src

* apply

*** apply

    - be careful when calling this function in primitive
      because after rs_push a jojo
      one need to exit current primitive to run the jojo

    #+begin_src c
    void apply(name jo) {
      if (!nametable_entry_used(nametable[jo])) {
        printf("undefined name : %s\n", n2k(jo));
        return;
      }
      int jo_type = nametable[jo].type;
      if (jo_type == k2n("primitive")) {
        primitive primitive = nametable_get_primitive(jo);
        primitive();
      }
      else if (jo_type == k2n("jojo")) {
        jojo jojo = nametable_get_jojo(jo);
        rs_push(jojo.array);
      }
      else if (jo_type == k2n("cell")) {
        int cell = nametable_get_cell(jo);
        as_push(cell);
      }
    }
    #+end_src

*** p_apply

    #+begin_src c
    void p_apply() {
      apply(as_pop());
    }
    #+end_src

* eval

*** eval

    #+begin_src c
    jmp_buf jmp_buffer;

    bool exit_eval() {
      longjmp(jmp_buffer, 666);
    }

    void eval() {
      if (666 == setjmp(jmp_buffer)) {
        return;
      }
      else {
        int rs_base = rs_pointer;
        while (rs_pointer >= rs_base) {
          name* function_body = rs_pop();
          rs_push(function_body + 1);
          int jo = *(int*)function_body;
          apply(jo);
        }
      }
    }
    #+end_src

*** eval_jo

    #+begin_src c
    void eval_jo(name jo) {
      int jo_type = nametable[jo].type;
      if (jo_type == k2n("primitive")) {
        primitive primitive = nametable_get_primitive(jo);
        primitive();
      }
      else if (jo_type == k2n("jojo")) {
        jojo jojo = nametable_get_jojo(jo);
        rs_push(jojo.array);
        eval();
      }
      else if (jo_type == k2n("cell")) {
        int cell = nametable_get_cell(jo);
        as_push(cell);
      }
    }
    #+end_src

* *stack_operation*

*** p_drop

    #+begin_src c
    void p_drop() {
      // (a ->)
      as_pop();
    }
    #+end_src

*** p_dup

    #+begin_src c
    void p_dup() {
      // (a a -> a)
      int a = as_pop();
      as_push(a);
      as_push(a);
    }
    #+end_src

*** p_over

    #+begin_src c
    void p_over() {
      // (a b -> a b a)
      int b = as_pop();
      int a = as_pop();
      as_push(a);
      as_push(b);
      as_push(a);
    }
    #+end_src

*** p_tuck

    #+begin_src c
    void p_tuck() {
      // (a b -> b a b)
      int b = as_pop();
      int a = as_pop();
      as_push(b);
      as_push(a);
      as_push(b);
    }
    #+end_src

*** p_swap

    #+begin_src c
    void p_swap() {
      // (a b -> b a)
      int b = as_pop();
      int a = as_pop();
      as_push(b);
      as_push(a);
    }
    #+end_src

*** p_print_stack

    #+begin_src c
    void p_print_stack() {
      // ([io] ->)
      if (as_pointer < as_base) {
        printf("  * %d *  ", (as_pointer - as_base));
        printf("-- below the stack --\n");
      }
      else {
        printf("  * %d *  ", (as_pointer - as_base));
        printf("-- ");
        int i = as_base;
        while (i < as_pointer) {
          printf("%d ", as[i]);
          i++;
        }
        printf("--\n");
      }
    }
    #+end_src

*** export_stack_operation

    #+begin_src c
    void export_stack_operation() {
      define_primitive("drop", p_drop);
      define_primitive("dup", p_dup);
      define_primitive("over", p_over);
      define_primitive("tuck", p_tuck);
      define_primitive("swap", p_swap);
      define_primitive("print-stack", p_print_stack);
    }
    #+end_src

* *ending*

*** p_end

    #+begin_src c
    void p_end() {
      // (rs: addr ->)
      rs_pop();
    }
    #+end_src

*** p_bye

    #+begin_src c
    void p_bye() {
      // (-> [exit])
      printf("bye bye ^-^/\n");
      exit_eval();
    }
    #+end_src

*** export_ending

    #+begin_src c
    void export_ending() {
      define_primitive("end", p_end);
      define_primitive("bye", p_bye);
    }
    #+end_src

* *control*

*** p_jump_back

    #+begin_src c
    void p_jump_back() {
      // (offset -> [rs])
      name* function_body = rs_pop();
      rs_push(function_body - as_pop());
    }
    #+end_src

*** p_jump_over

    #+begin_src c
    void p_jump_over() {
      // (offset -> [rs])
      name* function_body = rs_pop();
      rs_push(function_body + as_pop());
    }
    #+end_src

*** i_lit

    #+begin_src c
    void i_lit() {
      // ([rs] -> int)
      name* function_body = rs_pop();
      rs_push(function_body + 1);
      int jo = *(int*)function_body;
      as_push(jo);
    }
    #+end_src

*** i_tail_call

    #+begin_src c
    void i_tail_call() {
      // ([rs] -> int)
      name* function_body = rs_pop();
      int jo = *(int*)function_body;
      apply(jo);
    }
    #+end_src

*** p_jump_if_false

    #+begin_src c
    void p_jump_if_false() {
      // (bool addr -> [rs])
      name* a = as_pop();
      int b = as_pop();
      if (b == 0) {
        rs_pop();
        rs_push(a);
      }
    }
    #+end_src

*** export_control

    #+begin_src c
    void export_control() {
      define_primitive("jump-back", p_jump_back);
      define_primitive("jump-over", p_jump_over);
      define_primitive("i/lit", i_lit);
      define_primitive("i/tail-call", i_tail_call);
      define_primitive("jump-if-false", p_jump_if_false);
    }
    #+end_src

* *bool*

*** p_true

    #+begin_src c
    void p_true() {
      as_push(1);
    }
    #+end_src

*** p_false

    #+begin_src c
    void p_false() {
      as_push(0);
    }
    #+end_src

*** p_not

    #+begin_src c
    void p_not() {
      // (bool -> bool)
      int a = as_pop();
      as_push(!a);
    }
    #+end_src

*** export_bool

    #+begin_src c
    void export_bool() {
      define_primitive("true", p_true);
      define_primitive("false", p_false);
      define_primitive("not", p_not);
    }
    #+end_src

* *int*

*** p_add

    #+begin_src c
    void p_add() {
      // (int int -> int)
      int b = as_pop();
      int a = as_pop();
      as_push(a + b);
    }
    #+end_src

*** p_sub

    #+begin_src c
    void p_sub() {
      // (int int -> int)
      int b = as_pop();
      int a = as_pop();
      as_push(a - b);
    }
    #+end_src

*** p_mul

    #+begin_src c
    void p_mul() {
      // (int int -> int)
      int b = as_pop();
      int a = as_pop();
      as_push(a * b);
    }
    #+end_src

*** p_div

    #+begin_src c
    void p_div() {
      // (int int -> int)
      int b = as_pop();
      int a = as_pop();
      as_push(a / b);
    }
    #+end_src

*** p_mod

    #+begin_src c
    void p_mod() {
      // (int int -> int)
      int b = as_pop();
      int a = as_pop();
      as_push(a % b);
    }
    #+end_src

*** k_int

    #+begin_src c
    void k_int() {
      // ([io] -> [jojo_area])
      while (true) {
        name s = read_symbol();
        if (s == k2n(")")) {
          break;
        }
        else if (int_string_p(n2k(s))) {
          here(k2n("i/lit"));
          here(atoi(n2k(s)));
        }
        else {
          printf("meet non-int string in (# ...) : %s", n2k(s));
          break;
        }
      }
    }
    #+end_src

*** p_eq_p

    #+begin_src c
    void p_eq_p() {
      // (int int -> bool)
      int b = as_pop();
      int a = as_pop();
      as_push(a == b);
    }
    #+end_src

*** p_gt_p

    #+begin_src c
    void p_gt_p() {
      // (int int -> bool)
      int b = as_pop();
      int a = as_pop();
      as_push(a > b);
    }
    #+end_src

*** p_lt_p

    #+begin_src c
    void p_lt_p() {
      // (int int -> bool)
      int b = as_pop();
      int a = as_pop();
      as_push(a < b);
    }
    #+end_src

*** p_gteq_p

    #+begin_src c
    void p_gteq_p() {
      // (int int -> bool)
      int b = as_pop();
      int a = as_pop();
      as_push(a >= b);
    }
    #+end_src

*** p_lteq_p

    #+begin_src c
    void p_lteq_p() {
      // (int int -> bool)
      int b = as_pop();
      int a = as_pop();
      as_push(a <= b);
    }
    #+end_src

*** export_int

    #+begin_src c
    void export_int() {
      define_primitive("add", p_add);
      define_primitive("sub", p_sub);

      define_primitive("mul", p_mul);
      define_primitive("div", p_div);
      define_primitive("mod", p_mod);

      define_primitive("neg", p_not);

      define_primitive("eq?", p_eq_p);
      define_primitive("gt?", p_gt_p);
      define_primitive("lt?", p_lt_p);
      define_primitive("gteq?", p_gteq_p);
      define_primitive("lteq?", p_lteq_p);

      define_primitive("#", k_int);
    }
    #+end_src

* >< *byte*

  #+begin_src c
  typedef uint8_t byte;
  #+end_src

* *io*

*** read_symbol

    #+begin_src c
    name read_symbol() {
      // ([io] -> symbol)
      char buf[1024];
      int cur = 0;
      int collecting = false;
      char c;
      char go = true;
      while (go) {
        c = getchar();
        if (!collecting) {
          if (isspace(c)) {
            // do nothing
          }
          else {
            collecting = true;
            buf[cur] = c;
            cur++;
            if (isbarcket(c)) {
              go = false;
            }
          }
        }
        else {
          if (isbarcket(c) ||
              isspace(c)) {
            ungetc(c, stdin);
            go = false;
          }
          else {
            buf[cur] = c;
            cur++;
          }
        }
      }
      buf[cur] = 0;
      return k2n(buf);
    }
    #+end_src

*** p_read_symbol

    #+begin_src c
    void p_read_symbol() {
      as_push(read_symbol());
    }
    #+end_src

*** p_simple_wirte

    #+begin_src c
    void p_simple_wirte() {
      // (int -> [io])
      printf("%d\n", as_pop());
    }
    #+end_src

*** export_io

    #+begin_src c
    void export_io() {
      define_primitive("read-symbol", p_read_symbol);
      define_primitive("simple-wirte", p_simple_wirte);
      define_primitive(".", p_simple_wirte);
    }
    #+end_src

* *keyword*

*** k_comment

    #+begin_src c
    void k_comment() {
      // ([io] ->)
      while (true) {
        name s = read_symbol();
        if (s == k2n("(")) {
          k_comment();
        }
        if (s == k2n(")")) {
          break;
        }
      }
    }
    #+end_src

*** k_if

***** note

      - (if a b p? -> c d)
        a b p?
        [jump] jumk_if_false
        c d
        :jump

      - because the use of as_snapshot
        bar can not be nested in antecedent

***** compile_question

      #+begin_src c
      void compile_question() {
        // ([io] -> [jojo_area])
        while (true) {
          name s = read_symbol();
          if (s == k2n("(")) {
            eval_jo(read_symbol());
          }
          else if (s == k2n("->")) {
            break;
          }
          else {
            here(s);
          }
        }
      }
      #+end_src

***** compile_answer

      #+begin_src c
      void compile_answer() {
        // ([io] -> [jojo_area])
        here(k2n("i/lit"));
        int* offset_place = (jojo_area + jojo_area_counter);
        jojo_area_counter++;
        here(k2n("jump-if-false"));
        while (true) {
          name s = read_symbol();
          if (s == k2n("(")) {
            eval_jo(read_symbol());
          }
          else if (s == k2n(")")) {
            break;
          }
          else {
            here(s);
          }
        }
        offset_place[0] = (jojo_area + jojo_area_counter);
      }
      #+end_src

***** k_if

      #+begin_src c
      void k_if() {
        // ([io] -> [jojo_area])
        compile_question();
        compile_answer();
      }
      #+end_src

*** k_tail_call

    #+begin_src c
    void k_tail_call() {
      // ([io] -> [jojo_area])
      here(k2n("i/tail-call"));
      name s = read_symbol();
      here(s);
      k_comment();
    }
    #+end_src

*** export_keyword

    #+begin_src c
    void export_keyword() {
      define_primitive(":", k_comment);
      define_primitive("if", k_if);
      define_primitive("tail-call", k_tail_call);
    }
    #+end_src

* *top_level_keyword*

*** p_define_function

    #+begin_src c
    void p_define_function() {
      // ([io] -> [nametable])
      name index;
      index = read_symbol();
      int old_jojo_area_counter = jojo_area_counter;
      name* array = jojo_area + jojo_area_counter;
      while (true) {
        name s = read_symbol();
        if (s == k2n("(")) {
          eval_jo(read_symbol());
        }
        else if (s == k2n(")")) {
          here(k2n("end"));
          break;
        }
        else {
          here(s);
        }
      }
      nametable[index].type = k2n("jojo");
      nametable[index].value.jojo.size = jojo_area_counter - old_jojo_area_counter;
      nametable[index].value.jojo.array = array;
    }
    #+end_src

*** export_top_level_keyword

    #+begin_src c
    void export_top_level_keyword() {
      define_primitive("~", p_define_function);
    }
    #+end_src

* *misc*

*** do_nothing

    #+begin_src c
    void do_nothing() {
    }
    #+end_src

*** export_mise

    #+begin_src c
    void export_mise() {
      define_primitive("(", do_nothing);
      define_primitive("apply", p_apply);
      define_primitive("nametable-report", nametable_report);
    }
    #+end_src

* dl

* *play*

*** k1

    #+begin_src c
    void k1() {
      as_push(atoi("12345"));
    }
    #+end_src

*** k3

    - cc -fPIC -c k2.c -o libk2.o
      cc -shared libk2.o -o libk2.so
      cc -shared -fPIC -c k2.c -o libk2.so

    #+begin_src c
    void k3() {
      string lib_file = "./play/libk2.so";
      string func_to_run = "k2";
      void* lib = dlopen(lib_file, RTLD_LAZY);
      if (lib == NULL) {
        printf("Failed to open the library %s: %s\n",
               lib_file, dlerror());
      };

      primitive func = dlsym(lib, func_to_run);
      if (func == NULL) {
        printf("Did not find %s function in the library %s: %s\n",
               func_to_run, lib_file, dlerror());
      };

      func();

      int rc = dlclose(lib);
      if (rc != 0) {
        printf("Failed to close %s\n", lib_file);
      };
    }
    #+end_src

*** export_play

    #+begin_src c
    void export_play() {
      define_primitive("k1", k1);
      define_primitive("k3", k3);
    }
    #+end_src

* *repl*

*** export_repl

    #+begin_src c
    void export_repl() {
      define_variable("little-test-number", 4);
      // basic-repl can not be defined as primitive
      string p_basic_repl[] = {
        "read-symbol",
        "apply",
        "little-test-number",
        "jump-back"
      };
      define_function("basic-repl", 4, p_basic_repl);
    }
    #+end_src

* the_story_begins

*** the_story_begins

    #+begin_src c
    void the_story_begins() {

      init_nametable();

      export_stack_operation();
      export_ending();
      export_control();
      export_int();
      export_io();
      export_bool();
      export_keyword();
      export_top_level_keyword();
      export_mise();
      export_repl();
      export_play();

      jojo first_jojo = nametable_get_jojo(k2n("basic-repl"));
      rs_push(first_jojo.array);
      eval();
    }
    #+end_src

*** main

    #+begin_src c
    int main(int argc, string* argv) {
      the_story_begins();
      return 0;
    }
    #+end_src
