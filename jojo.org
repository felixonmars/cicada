#+property: tangle jojo.c
#+title:  jojo

* [todo-stack]

  - single inheritance
    all function as multiple dispatching generic function
    - we can do this, if we assume all function have fixed number of arguments

  - :name for local var
    and (> :name) to set them

  - about gc
    - note about gc
    - move gc to c code
    - gc for string
      and all kinks of data
    - fix the roots of gc
    - re-test the gc

  - low-level syntax macro
    [at reader level]

  - c-like struct
    - by c struct, stack in c is easy.
      the c-like syntax we designed for jojo
      also shall let us implement stack in jojo easily.

* [todo-list]

  - trace and untrace a jo

  - delimited continuation
    to control return_stack [and data_stack]

  - concurrent
    use list to implement return_stack and data_stack in jojo
    thus each group of stacks is a light weight process

  - fix print_return_point
    - we need to add some overhead to local variable
      maybe I will add this,
      when I really need to print local variable with tag.

* [maybe]

  - make BLOCK_SIZE local to object

* [note]

*** interface convention

    - before trying to get something from somewhere,
      first ask if it is there at all.

    - this convention can only be used
      when condition race will not occur,
      or when condition race is not important.

*** important common sense

    - all programs are changings of state of machine

    - syntax-checker, type-checker, compiler are all special interpreters

*** threaded code interpreter

    - types of threaded code interpreter :
      1. indirect threaded code
      2. direct threaded code
      3. token threaded code
      4. subroutine threaded code
      5. dynamic threaded code
         [jotable] [symbol-hash-table [of lisp]]

    - overhead of eval
      base_pointer test [to be able to return to c function]
      step_flag test

    - overhead of jo_apply
      dispatching [dynamic threaded code]

*** possible static type system

    - type comment in jojo and c code :
      1. change of data_stack -- [...] -> [...]
      2. other effect -- {}
         which can occur in any position in a type comment

    - the type comment in the code suggest a static type system.

      a static type system
      and a compiled verison of jojo
      might be implemented,

      but an untyped and a dynamic typed level are also important.

*** levels of languages

    1. untyped -- ffi to c [thus as low as c]
    2. dynamic typed -- debug and test
    3. static typed
    4. logic
    5. concurrent
    6. dependent type -- type as proof
    7. algebraic topology and combinatorial topology

*** apply and scope

    - apply will create new scope of local names.

    - thus
      p_compile_jojo will create new scope of local names.

    - by the following we can add pre-setted name to a scope :
      current-local-pointer swap
      (< data) (< tag) (jo self) local-in
      apply-with-local-pointer

    - but we can not use old names in the scope outside this scope.

*** limits

    | name                 | length      | unit          |
    |----------------------+-------------+---------------|
    | jojo_area            | 1024 * 1024 | jo            |
    | jotable              | 97 * 1024   | jotable_entry |
    | name_record          | 16 * 1024   | jo            |
    |----------------------+-------------+---------------|
    | data_stack           |             | cell          |
    | return_stack         |             | return_point  |
    | local_record         | 4 * 1024    | local_point   |
    | alias_record         | 1024        | alias_point   |
    |----------------------+-------------+---------------|
    | compiling_stack      |             | jo*           |
    | binding_filter_stack |             | jo            |
    | jo_filter_stack      |             | jo            |
    | keyword_stack        |             | alias_pointer |
    | reading_stack        |             | input_stack   |
    | writing_stack        |             | output_stack  |

*** minimalism

    - to keep the core minimal,
      I only implement the features needed to load other modules.

*** input_stack & output_stack

    - input_stack  push from high address to low address
      pop  -- read
      push -- unread

    - output_stack push from low address to high address
      push -- write
      pop  -- unwrite

* header

  #+begin_src c
  #include <sys/types.h>
  #include <sys/stat.h>
  #include <unistd.h>
  #include <stdio.h>
  #include <stdlib.h>
  #include <errno.h>
  #include <string.h>
  #include <fcntl.h>
  #include <ctype.h>
  #include <stdint.h>
  #include <dlfcn.h>
  #include <dirent.h>
  #include <signal.h>
  #include <limits.h>
  #include <stdarg.h>
  #+end_src

* type

  #+begin_src c
  typedef enum { false, true } bool;
  // typedef intptr_t cell;
  typedef intmax_t cell;
  typedef uint8_t byte;
  typedef void (* primitive)();
  #+end_src

* utility

*** int

    #+begin_src c
    cell max(cell a, cell b) {
      if (a < b) {
        return b;
      }
      else {
        return a;
      }
    }

    cell min(cell a, cell b) {
      if (a > b) {
        return b;
      }
      else {
        return a;
      }
    }

    cell power(cell a, cell n) {
      cell result = 1;
      while (n >= 1) {
        result = result * a;
        n--;
      }
      return result;
    }
    #+end_src

*** char

    #+begin_src c
    bool isbarcket(char c) {
      return (c == '(' ||
              c == ')' ||
              c == '[' ||
              c == ']' ||
              c == '{' ||
              c == '}' ||
              c == '"');
    }
    #+end_src

*** char_to_nat

    #+begin_src c
    cell char_to_nat(char c) {
      if (c >= '0' && c <= '9') {
        return (c - '0');
      }
      else if (c >= 'A' && c <= 'Z') {
        return (c - 'A') + 10;
      }
      else if (c >= 'a' && c <= 'z') {
        return (c - 'a') + 10;
      }
      else {
        return 0;
      }
    }
    #+end_src

*** string

***** string_equal

      #+begin_src c
      bool string_equal(char* s1, char* s2) {
        if (strcmp(s1, s2) == 0) {
          return true;
        }
        else {
          return false;
        }
      }
      #+end_src

***** nat_string_p

      #+begin_src c
      bool nat_string_p(char* str) {
        cell i = 0;
        while (str[i] != 0) {
          if (!isdigit(str[i])) {
            return false;
            }
          i++;
        }
        return true;
      }
      #+end_src

***** int_string_p

      #+begin_src c
      bool int_string_p(char* str) {
        if (str[0] == '-' ||
            str[0] == '+') {
          return nat_string_p(str + 1);
        }
        else {
          return nat_string_p(str);
        }
      }
      #+end_src

***** string_to_based_nat & string_to_based_int & string_to_int

      #+begin_src c
      cell string_to_based_nat(char* str, cell base) {
        cell result = 0;
        cell len = strlen(str);
        cell i = 0;
        while (i < len) {
          result = result + (char_to_nat(str[i]) * power(base, (len - i - 1)));
          i++;
        }
        return result;
      }

      cell string_to_based_int(char* str, cell base) {
        if (str[0] == '-') {
          return - string_to_based_nat(str, base);
        }
        else {
          return string_to_based_nat(str, base);
        }
      }

      cell string_to_int(char* str) { return string_to_based_int(str, 10); }
      #+end_src

*** error

    #+begin_src c
    report(char* format, ...) {
      va_list arg_list;
      va_start(arg_list, format);
      vdprintf(STDERR_FILENO, format, arg_list);
      va_end(arg_list);
    }
    #+end_src

* jotable

*** type

    #+begin_src c
    typedef struct _jotable_entry {
      char *key;
      struct _jotable_entry *tag;
      cell value;
    } jotable_entry;

    typedef jotable_entry *jo;

    // prime table size
    //   1000003   about 976 k
    //   1000033
    //   1000333
    //   100003    about 97 k
    //   100333
    //   997
    #define jotable_size 100003
    jotable_entry jotable[jotable_size];

    // thus (jotable + index) is jo
    #+end_src

*** used_jo_p

    #+begin_src c
    bool used_jo_p(jo jo) {
      return jo->tag != 0;
    }
    #+end_src

*** string_to_sum

    #+begin_src c
    cell string_to_sum(char* str) {
      cell sum = 0;
      cell max_step = 10;
      cell i = 0;
      while (i < strlen(str)) {
        sum = sum + ((byte) str[i]) * (2 << min(i, max_step));
        i++;
      }
      return sum;
    }
    #+end_src

*** jotable_hash

    #+begin_src c
    // a hash an index into jotable
    cell jotable_hash(cell sum, cell counter) {
      return (counter + sum) % jotable_size;
    }
    #+end_src

*** jotable_insert

    #+begin_src c
    p_debug();

    jo jotable_insert(char* key) {
      // in C : [string] -> [jo]
      cell sum = string_to_sum(key);
      cell counter = 0;
      while (true) {
        cell index = jotable_hash(sum, counter);
        jo jo = (jotable + index);
        if (jo->key == 0) {
          key = strdup(key);
          jo->key = key;
          return jo;
        }
        else if (string_equal(key, jo->key)) {
          return jo;
        }
        else if (counter == jotable_size) {
          report("- jotable_insert fail\n");
          report("  the hash_table is filled\n");
          p_debug();
          return NULL;
        }
        else {
          counter++;
        }
      }
    }
    #+end_src

*** str2jo

    #+begin_src c
    jo str2jo(char* str) {
      return jotable_insert(str);
    }
    #+end_src

*** jo2str

    #+begin_src c
    char* jo2str(jo jo) {
      return jo->key;
    }
    #+end_src

*** literal jo

    #+begin_src c
    jo EMPTY_JO;
    jo TAG_PRIM;
    jo TAG_JOJO;
    jo TAG_PRIM_KEYWORD;
    jo TAG_KEYWORD;
    jo TAG_DATA;

    jo JO_DECLARED;

    jo ROUND_BAR;
    jo ROUND_KET;
    jo SQUARE_BAR;
    jo SQUARE_KET;
    jo FLOWER_BAR;
    jo FLOWER_KET;
    jo DOUBLE_QUOTE;

    jo JO_INS_INT;
    jo JO_INS_JO;
    jo JO_INS_STRING;
    jo JO_INS_BYTE;
    jo JO_INS_BARE_JOJO;
    jo JO_INS_ADDRESS;

    jo JO_INS_JUMP;
    jo JO_INS_JUMP_IF_FALSE;

    jo JO_INS_TAIL_CALL;
    jo JO_INS_LOOP;
    jo JO_INS_RECUR;

    jo JO_NULL;
    jo JO_THEN;
    jo JO_ELSE;

    jo JO_APPLY;
    jo JO_END;

    jo JO_LOCAL_DATA_IN;
    jo JO_LOCAL_DATA_OUT;

    jo JO_LOCAL_TAG_IN;
    jo JO_LOCAL_TAG_OUT;

    jo JO_LOCAL_IN;
    jo JO_LOCAL_OUT;
    #+end_src

* stack

*** stack_link

    #+begin_src c
    typedef struct _stack_link__t {
      cell* stack;
      struct _stack_link__t* link;
    } stack_link__t;
    typedef stack_link__t* stack_link;
    #+end_src

*** stack

    #+begin_src c
    typedef struct {
      char* name;
      cell pointer;
      cell* stack;
      stack_link link;
    } stack__t;
    typedef stack__t* stack;

    #define STACK_BLOCK_SIZE 1024
    // #define STACK_BLOCK_SIZE 1 // for testing
    #+end_src

*** new_stack

    #+begin_src c
    stack new_stack(char* name) {
      stack stack = (stack__t*)malloc(sizeof(stack__t));
      stack->name = name;
      stack->pointer = 0;
      stack->stack = (cell*)malloc(sizeof(cell) * STACK_BLOCK_SIZE);
      stack->link = NULL;
      return stack;
    }
    #+end_src

*** stack_free

    #+begin_src c
    stack_free_link(stack_link link) {
      if (link == NULL) {
        return;
      }
      else {
        stack_free_link(link->link);
        free(link->stack);
        free(link);
      }
    }

    // ><><><
    // stack->name is not freed
    stack_free(stack stack) {
      stack_free_link(stack->link);
      free(stack->stack);
      free(stack);
    }
    #+end_src

*** stack_block_underflow_check

    #+begin_src c
    // can not pop
    // for stack->pointer can not decrease under 0
    stack_block_underflow_check(stack stack) {
      if (stack->pointer > 0) {
        return;
      }
      else if (stack->link != NULL) {
        free(stack->stack);
        stack->stack = stack->link->stack;
        stack_link old_link = stack->link;
        stack->link = stack->link->link;
        free(old_link);
        stack->pointer = STACK_BLOCK_SIZE;
        return;
      }
      else {
        report("- stack_block_underflow_check fail\n");
        report("  %s underflow\n", stack->name);
        p_debug();
      }
    }
    #+end_src

*** stack_block_overflow_check

    #+begin_src c
    // can not push
    // for stack->pointer can not increase over STACK_BLOCK_SIZE
    stack_block_overflow_check(stack stack) {
      if (stack->pointer < STACK_BLOCK_SIZE) {
        return;
      }
      else {
        stack_link new_link = (stack_link__t*)malloc(sizeof(stack_link__t));
        new_link->stack = stack->stack;
        new_link->link = stack->link;
        stack->link = new_link;
        stack->stack = (cell*)malloc(sizeof(cell) * STACK_BLOCK_SIZE);
        stack->pointer = 0;
      }
    }
    #+end_src

*** stack_empty_p

    #+begin_src c
    bool stack_empty_p(stack stack) {
      return
        stack->pointer == 0 &&
        stack->link == NULL;
    }
    #+end_src

*** stack_length

    #+begin_src c
    cell stack_length_link(cell sum, stack_link link) {
      if (link == NULL) {
        return sum;
      }
      else {
        return stack_length_link(sum + STACK_BLOCK_SIZE, link->link);
      }
    }

    cell stack_length(stack stack) {
      return stack_length_link(stack->pointer, stack->link);
    }
    #+end_src

*** pop

    #+begin_src c
    cell pop(stack stack) {
      stack_block_underflow_check(stack);
      stack->pointer--;
      return stack->stack[stack->pointer];
    }
    #+end_src

*** tos

    #+begin_src c
    cell tos(stack stack) {
      stack_block_underflow_check(stack);
      return stack->stack[stack->pointer - 1];
    }
    #+end_src

*** drop

    #+begin_src c
    drop(stack stack) {
      stack_block_underflow_check(stack);
      stack->pointer--;
    }
    #+end_src

*** push

    #+begin_src c
    push(stack stack, cell data) {
      stack_block_overflow_check(stack);
      stack->stack[stack->pointer] = data;
      stack->pointer++;
    }
    #+end_src

*** stack_traverse_from_top

    #+begin_src c
    stack_traverse_from_top_help
    (cell cursor,
     cell* stack,
     stack_link link,
     void fun(cell)) {
      while (cursor > 0) {
        fun(stack[cursor - 1]);
        cursor--;
      }
      if (link != NULL) {
        stack_traverse_from_top_help
          (STACK_BLOCK_SIZE,
           link->stack,
           link->link,
           fun);
      }
    }

    stack_traverse_from_top(stack stack, void fun(cell)) {
      stack_traverse_from_top_help
        (stack->pointer,
         stack->stack,
         stack->link,
         fun);
    }
    #+end_src

*** stack_traverse_from_bottom

    #+begin_src c
    stack_traverse_from_bottom_help
    (cell cursor,
     cell* stack,
     stack_link link,
     void fun(cell)) {
      if (link != NULL) {
        stack_traverse_from_bottom_help
          (STACK_BLOCK_SIZE,
           link->stack,
           link->link,
           fun);
      }
      cell i = 0;
      while (i < cursor) {
        fun(stack[i]);
        i++;
      }
    }

    stack_traverse_from_bottom(stack stack, void fun(cell)) {
      stack_traverse_from_bottom_help
        (stack->pointer,
         stack->stack,
         stack->link,
         fun);
    }
    #+end_src

* input_stack

*** [note]

    - free input_stack will not close the file.

*** input_stack_type

    #+begin_src c
    typedef enum {
      INPUT_STACK_REGULAR_FILE,
      INPUT_STACK_STRING,
      INPUT_STACK_TERMINAL,
    } input_stack_type;
    #+end_src

*** input_stack_link

    #+begin_src c
    typedef struct _input_stack_link__t {
      byte* stack;
      cell end_pointer;
      struct _input_stack_link__t* link;
    } input_stack_link__t;
    typedef input_stack_link__t* input_stack_link;
    #+end_src

*** input_stack

    #+begin_src c
    typedef struct {
      cell pointer;
      cell end_pointer;
      byte* stack;
      input_stack_link link;
      input_stack_type type;
      union {
        int   file;
        char* string;
        // int   terminal;
      };
      cell string_pointer;
    } input_stack__t;
    typedef input_stack__t* input_stack;

    // #define INPUT_STACK_BLOCK_SIZE (4 * 1024)
    #define INPUT_STACK_BLOCK_SIZE 1 // for testing
    #+end_src

*** input_stack_new

    #+begin_src c
    input_stack input_stack_new(input_stack_type input_stack_type) {
      input_stack input_stack =
        (input_stack__t*)malloc(sizeof(input_stack__t));
      input_stack->pointer = INPUT_STACK_BLOCK_SIZE;
      input_stack->end_pointer = INPUT_STACK_BLOCK_SIZE;
      input_stack->stack = (byte*)malloc(INPUT_STACK_BLOCK_SIZE);
      input_stack->link = NULL;
      input_stack->type = input_stack_type;
      return input_stack;
    }
    #+end_src

*** input_stack_file

    #+begin_src c
    input_stack input_stack_file(int file) {
      int file_flag = fcntl(file, F_GETFL);
      int access_mode = file_flag & O_ACCMODE;
      if (file_flag == -1) {
        report("- input_stack_file fail\n");
        perror("  fcntl error ");
        p_debug();
      }
      input_stack input_stack = input_stack_new(INPUT_STACK_REGULAR_FILE);
      input_stack->file = file;
      return input_stack;
    }
    #+end_src

*** input_stack_string

    #+begin_src c
    input_stack input_stack_string(char* string) {
      input_stack input_stack = input_stack_new(INPUT_STACK_STRING);
      input_stack->string = string;
      input_stack->string_pointer = 0;
      return input_stack;
    }
    #+end_src

*** input_stack_terminal

    #+begin_src c
    input_stack input_stack_terminal() {
      input_stack input_stack = input_stack_new(INPUT_STACK_TERMINAL);
      return input_stack;
    }
    #+end_src

*** input_stack_free

    #+begin_src c
    input_stack_free_link(input_stack_link link) {
      if (link == NULL) {
        return;
      }
      else {
        input_stack_free_link(link->link);
        free(link->stack);
        free(link);
      }
    }

    input_stack_free(input_stack input_stack) {
      input_stack_free_link(input_stack->link);
      free(input_stack->stack);
      free(input_stack);
    }
    #+end_src

*** input_stack_block_underflow_check

    #+begin_src c
    // can not pop
    // for input_stack->pointer can not increase over input_stack->end_pointer
    input_stack_block_underflow_check(input_stack input_stack) {
      if (input_stack->pointer < input_stack->end_pointer) {
        return;
      }

      else if (input_stack->link != NULL) {
        free(input_stack->stack);
        input_stack->stack = input_stack->link->stack;
        input_stack->end_pointer = input_stack->link->end_pointer;
        input_stack_link old_link = input_stack->link;
        input_stack->link = input_stack->link->link;
        free(old_link);
        input_stack->pointer = 0;
        return;
      }

      else if (input_stack->type == INPUT_STACK_REGULAR_FILE) {
        ssize_t real_bytes = read(input_stack->file,
                                  input_stack->stack,
                                  INPUT_STACK_BLOCK_SIZE);
        if (real_bytes == 0) {
          report("- input_stack_block_underflow_check fail\n");
          report("  input_stack underflow\n");
          report("  meet end-of-file when reading a regular_file\n");
          report("  file descriptor : %ld\n", input_stack->file);
          p_debug();
        }
        else {
          input_stack->pointer = 0;
          input_stack->end_pointer = real_bytes;
          return;
        }
      }

      else if (input_stack->type == INPUT_STACK_STRING) {
        byte byte = input_stack->string[input_stack->string_pointer];
        if (byte == '\0') {
          report("- input_stack_block_underflow_check fail\n");
          report("  input_stack underflow\n");
          report("  meet end-of-string when reading a string\n");
          p_debug();
        }
        input_stack->string_pointer++;
        input_stack->end_pointer = INPUT_STACK_BLOCK_SIZE;
        input_stack->pointer = INPUT_STACK_BLOCK_SIZE - 1;
        input_stack->stack[input_stack->pointer] = byte;
        return;
      }

      else if (input_stack->type == INPUT_STACK_TERMINAL) {
        ssize_t real_bytes = read(STDIN_FILENO,
                                  input_stack->stack,
                                  INPUT_STACK_BLOCK_SIZE);
        if (real_bytes == 0) {
          report("- input_stack_block_underflow_check fail\n");
          report("  input_stack underflow\n");
          report("  meet end-of-file when reading from terminal\n");
          p_debug();
        }
        else {
          input_stack->pointer = 0;
          input_stack->end_pointer = real_bytes;
          return;
        }
      }

      else {
        report("- input_stack_block_underflow_check fail\n");
        report("  meet unknow stack type\n");
        report("  stack type number : %ld\n", input_stack->type);
        p_debug();
      }
    }
    #+end_src

*** input_stack_block_overflow_check

    #+begin_src c
    // can not push
    // for input_stack->pointer can not decrease under 0
    input_stack_block_overflow_check(input_stack input_stack) {
      if (input_stack->pointer > 0) {
        return;
      }
      else {
        input_stack_link new_link =
          (input_stack_link__t*)malloc(sizeof(input_stack_link__t));
        new_link->stack = input_stack->stack;
        new_link->link = input_stack->link;
        new_link->end_pointer = input_stack->end_pointer;
        input_stack->link = new_link;
        input_stack->stack = (byte*)malloc(INPUT_STACK_BLOCK_SIZE);
        input_stack->pointer = INPUT_STACK_BLOCK_SIZE;
        input_stack->end_pointer = INPUT_STACK_BLOCK_SIZE;
      }
    }
    #+end_src

*** input_stack_empty_p

    - note the semantic of 'input_stack_empty_p'.

      when one asks 'input_stack_empty_p',
      there is already one byte readed into the input_stack.

    #+begin_src c
    bool input_stack_empty_p(input_stack input_stack) {
      if (input_stack->pointer != input_stack->end_pointer ||
          input_stack->link != NULL) {
        return false;
      }
      if (input_stack->type == INPUT_STACK_REGULAR_FILE) {
        ssize_t real_bytes = read(input_stack->file,
                                  input_stack->stack,
                                  INPUT_STACK_BLOCK_SIZE);
        if (real_bytes == 0) {
          return true;
        }
        else {
          input_stack->pointer = 0;
          input_stack->end_pointer = real_bytes;
          return false;
        }
      }
      else if (input_stack->type == INPUT_STACK_STRING) {
        return input_stack->string[input_stack->string_pointer] == '\0';
      }
      else if (input_stack->type == INPUT_STACK_TERMINAL) {
        ssize_t real_bytes = read(STDIN_FILENO,
                                  input_stack->stack,
                                  INPUT_STACK_BLOCK_SIZE);
        if (real_bytes == 0) {
          return true;
        }
        else {
          input_stack->pointer = 0;
          input_stack->end_pointer = real_bytes;
          return false;
        }
      }
      else {
        report("- input_stack_empty_p meet unknow stack type\n");
        report("  stack type number : %ld\n", input_stack->type);
        p_debug();
      }
    }
    #+end_src

*** input_stack_pop

    #+begin_src c
    byte input_stack_pop(input_stack input_stack) {
      input_stack_block_underflow_check(input_stack);
      byte byte = input_stack->stack[input_stack->pointer];
      input_stack->pointer++;
      return byte;
    }
    #+end_src

*** input_stack_tos

    #+begin_src c
    byte input_stack_tos(input_stack input_stack) {
      input_stack_block_underflow_check(input_stack);
      byte byte = input_stack->stack[input_stack->pointer];
      return byte;
    }
    #+end_src

*** input_stack_drop

    #+begin_src c
    input_stack_drop(input_stack input_stack) {
      input_stack_block_underflow_check(input_stack);
      input_stack->pointer++;
    }
    #+end_src

*** input_stack_push

    #+begin_src c
    input_stack_push(input_stack input_stack, byte byte) {
      input_stack_block_overflow_check(input_stack);
      input_stack->pointer--;
      input_stack->stack[input_stack->pointer] = byte;
    }
    #+end_src

* output_stack

*** [note]

    - I will not seek the real file during pop and push.
      and no undo for the terminal.

    - output to
      1. file     -- the aim is to flush bytes to file
      2. string   -- the aim is to collect bytes to string
      3. terminal -- byte are directly printed to the terminal

    - flush to file or collect to string
      will not free the output_stack.

    - free output_stack will not close the file.

*** output_stack_type

    #+begin_src c
    typedef enum {
      OUTPUT_STACK_REGULAR_FILE,
      OUTPUT_STACK_STRING,
      OUTPUT_STACK_TERMINAL,
    } output_stack_type;
    #+end_src

*** output_stack_link

    #+begin_src c
    typedef struct _output_stack_link__t {
      byte* stack;
      struct _output_stack_link__t* link;
    } output_stack_link__t;
    typedef output_stack_link__t* output_stack_link;
    #+end_src

*** output_stack

    #+begin_src c
    typedef struct {
      cell pointer;
      byte* stack;
      output_stack_link link;
      output_stack_type type;
      union {
        int   file; // with cache
        // char* string;
        //   generate string
        //   instead of output to pre-allocated buffer
        // int   terminal; // no cache
      };
      cell string_pointer;
    } output_stack__t;
    typedef output_stack__t* output_stack;

    // #define OUTPUT_STACK_BLOCK_SIZE (4 * 1024)
    #define OUTPUT_STACK_BLOCK_SIZE 1 // for testing
    #+end_src

*** output_stack_new

    #+begin_src c
    output_stack output_stack_new(output_stack_type output_stack_type) {
      output_stack output_stack =
        (output_stack__t*)malloc(sizeof(output_stack__t));
      output_stack->pointer = 0;
      output_stack->stack = (byte*)malloc(OUTPUT_STACK_BLOCK_SIZE);
      output_stack->link = NULL;
      output_stack->type = output_stack_type;
      return output_stack;
    }
    #+end_src

*** output_stack_file

    #+begin_src c
    output_stack output_stack_file(int file) {
      int file_flag = fcntl(file, F_GETFL);
      int access_mode = file_flag & O_ACCMODE;
      if (file_flag == -1) {
        report("- output_stack_file fail\n");
        perror("  fcntl error ");
        p_debug();
      }
      else if (access_mode == O_WRONLY || access_mode == O_RDWR) {
        output_stack output_stack = output_stack_new(OUTPUT_STACK_REGULAR_FILE);
        output_stack->file = file;
        return output_stack;
      }
      else {
        report("- output_stack_file fail\n");
        report("  output_stack_file fail\n");
        p_debug();
      }
    }
    #+end_src

*** output_stack_string

    #+begin_src c
    output_stack output_stack_string() {
      output_stack output_stack = output_stack_new(OUTPUT_STACK_STRING);
      return output_stack;
    }
    #+end_src

*** output_stack_terminal

    #+begin_src c
    output_stack output_stack_terminal() {
      output_stack output_stack = output_stack_new(OUTPUT_STACK_TERMINAL);
      return output_stack;
    }
    #+end_src

*** output_stack_free

    #+begin_src c
    output_stack_free_link(output_stack_link link) {
      if (link == NULL) {
        return;
      }
      else {
        output_stack_free_link(link->link);
        free(link->stack);
        free(link);
      }
    }

    output_stack_free(output_stack output_stack) {
      output_stack_free_link(output_stack->link);
      free(output_stack->stack);
      free(output_stack);
    }
    #+end_src

*** output_stack_file_flush

    #+begin_src c
    output_stack_file_flush_link(int file, output_stack_link link) {
      if (link == NULL) {
        return;
      }
      else {
        output_stack_file_flush_link(file, link->link);
        ssize_t real_bytes = write(file,
                                   link->stack,
                                   OUTPUT_STACK_BLOCK_SIZE);
        if (real_bytes != OUTPUT_STACK_BLOCK_SIZE) {
          report("- output_stack_file_flush_link fail\n");
          report("  file descriptor : %ld\n", file);
          perror("  write error : ");
          p_debug();
        }
      }
    }

    output_stack_file_flush(output_stack output_stack) {
      output_stack_file_flush_link(output_stack->file,
                                   output_stack->link);
      ssize_t real_bytes = write(output_stack->file,
                                 output_stack->stack,
                                 output_stack->pointer);
      if (real_bytes != output_stack->pointer) {
        report("- output_stack_file_flush fail\n");
        report("  file descriptor : %ld\n", output_stack->file);
        perror("  write error : ");
        p_debug();
      }
      else {
        output_stack_free_link(output_stack->link);
        output_stack->link = NULL;
        output_stack->pointer = 0;
      }
    }
    #+end_src

*** output_stack_string_collect

    #+begin_src c
    cell output_stack_string_length_link(cell sum, output_stack_link link) {
      if (link == NULL) {
        return sum;
      }
      else {
        return
          OUTPUT_STACK_BLOCK_SIZE +
          output_stack_string_length_link(sum, link->link);
      }
    }

    cell output_stack_string_length(output_stack output_stack) {
      cell sum = strlen(output_stack->stack);
      return output_stack_string_length_link(sum, output_stack->link);
    }


    byte* output_stack_string_collect_link(byte* buffer, output_stack_link link) {
      if (link == NULL) {
        return buffer;
      }
      else {
        buffer = output_stack_string_collect_link(buffer, link->link);
        memcpy(buffer, link->stack, OUTPUT_STACK_BLOCK_SIZE);
        return buffer + OUTPUT_STACK_BLOCK_SIZE;
      }
    }

    char* output_stack_string_collect(output_stack output_stack) {
      byte* string = (byte*)malloc(1 + output_stack_string_length(output_stack));
      byte* buffer = string;
      buffer = output_stack_string_collect_link(buffer, output_stack->link);
      memcpy(buffer, output_stack->stack, output_stack->pointer);
      buffer[output_stack->pointer] = '\0';
      return string;
    }
    #+end_src

*** output_stack_block_underflow_check

    #+begin_src c
    // can not pop
    // for output_stack->pointer can not decrease under 0
    output_stack_block_underflow_check(output_stack output_stack) {
      if (output_stack->pointer > 0) {
        return;
      }

      else if (output_stack->link != NULL) {
        free(output_stack->stack);
        output_stack->stack = output_stack->link->stack;
        output_stack_link old_link = output_stack->link;
        output_stack->link = output_stack->link->link;
        free(old_link);
        output_stack->pointer = OUTPUT_STACK_BLOCK_SIZE;
        return;
      }

      else if (output_stack->type == OUTPUT_STACK_REGULAR_FILE) {
        report("- output_stack_block_underflow_check fail\n");
        report("  output_stack underflow\n");
        report("  when writing a regular_file\n");
        report("  file descriptor : %ld\n", output_stack->file);
        p_debug();
      }

      else if (output_stack->type == OUTPUT_STACK_STRING) {
        report("- output_stack_block_underflow_check fail\n");
        report("  output_stack underflow\n");
        report("  when writing a string\n");
        p_debug();
      }

      else if (output_stack->type == OUTPUT_STACK_TERMINAL) {
        report("- output_stack_block_underflow_check fail\n");
        report("  output_stack underflow\n");
        report("  when writing to terminal\n");
        p_debug();
      }

      else {
        report("- output_stack_block_underflow_check fail\n");
        report("  meet unknow stack type\n");
        report("  stack type number : %ld\n", output_stack->type);
        p_debug();
      }
    }
    #+end_src

*** output_stack_block_overflow_check

    #+begin_src c
    // can not push
    // for output_stack->pointer can not increase over OUTPUT_STACK_BLOCK_SIZE
    output_stack_block_overflow_check(output_stack output_stack) {
      if (output_stack->pointer < OUTPUT_STACK_BLOCK_SIZE) {
        return;
      }
      else {
        output_stack_link new_link =
          (output_stack_link__t*)malloc(sizeof(output_stack_link__t));
        new_link->stack = output_stack->stack;
        new_link->link = output_stack->link;
        output_stack->link = new_link;
        output_stack->stack = (byte*)malloc(OUTPUT_STACK_BLOCK_SIZE);
        output_stack->pointer = 0;
      }
    }
    #+end_src

*** output_stack_empty_p

    #+begin_src c
    bool output_stack_empty_p(output_stack output_stack) {
      if (output_stack->pointer != 0 ||
          output_stack->link != NULL) {
        return false;
      }
      if (output_stack->type == OUTPUT_STACK_REGULAR_FILE) {
        return true;
      }
      else if (output_stack->type == OUTPUT_STACK_STRING) {
        return true;
      }
      else if (output_stack->type == OUTPUT_STACK_TERMINAL) {
        return true;
      }
      else {
        report("- output_stack_empty_p meet unknow stack type\n");
        report("  stack type number : %ld\n", output_stack->type);
        p_debug();
      }
    }
    #+end_src

*** output_stack_pop

    #+begin_src c
    byte output_stack_pop(output_stack output_stack) {
      output_stack_block_underflow_check(output_stack);
      output_stack->pointer--;
      return output_stack->stack[output_stack->pointer];
    }
    #+end_src

*** output_stack_tos

    #+begin_src c
    byte output_stack_tos(output_stack output_stack) {
      output_stack_block_underflow_check(output_stack);
      return output_stack->stack[output_stack->pointer - 1];
    }
    #+end_src

*** output_stack_drop

    #+begin_src c
    output_stack_drop(output_stack output_stack) {
      output_stack_block_underflow_check(output_stack);
      output_stack->pointer--;
    }
    #+end_src

*** output_stack_push

    #+begin_src c
    output_stack_push(output_stack output_stack, byte b) {
      if (output_stack->type == OUTPUT_STACK_TERMINAL) {
        byte buffer[1];
        buffer[0] = b;
        ssize_t real_bytes = write(STDOUT_FILENO, buffer, 1);
        if (real_bytes != 1) {
          report("- output_stack_push fail\n");
          perror("  write error : ");
          p_debug();
        }
      }
      else {
        output_stack_block_overflow_check(output_stack);
        output_stack->stack[output_stack->pointer] = b;
        output_stack->pointer++;
      }
    }
    #+end_src

* compiling_stack & here

*** compiling_stack

    - to redirect compiling location

    #+begin_src c
    stack compiling_stack; // of jojo

    p_compiling_stack_inc() {
      jo* jojo = pop(compiling_stack);
      push(compiling_stack, jojo + 1);
    }
    #+end_src

*** here

    #+begin_src c
    here(cell n) {
      jo* jojo = pop(compiling_stack);
      jojo[0] = n;
      push(compiling_stack, jojo + 1);
    }
    #+end_src

* data_stack & return_stack

*** data_stack

    #+begin_src c
    stack data_stack; // of cell
    #+end_src

*** local

    #+begin_src c
    typedef struct {
      jo name;
      cell local_tag;
      cell local_data;
    } local_point;

    local_point local_record[4 * 1024];
    cell current_local_pointer = 0;
    #+end_src

*** return_stack

    #+begin_src c
    typedef struct {
      jo* jojo;
      cell local_pointer;
    } return_point;

    stack return_stack;

    return_point return_stack_pop() {
      return_point rp;
      rp.jojo = pop(return_stack);
      rp.local_pointer = pop(return_stack);
      return rp;
    }

    return_point return_stack_tos() {
      return_point rp;
      rp.jojo = pop(return_stack);
      rp.local_pointer = pop(return_stack);
      push(return_stack, rp.local_pointer);
      push(return_stack, rp.jojo);
      return rp;
    }

    bool return_stack_empty_p() {
      return stack_empty_p(return_stack);
    }

    return_stack_make_point(jo* jojo, cell local_pointer) {
      push(return_stack, local_pointer);
      push(return_stack, jojo);
    }

    return_stack_new_point(jo* jojo) {
      return_stack_make_point(jojo, current_local_pointer);
    }

    return_stack_inc() {
      jo* jojo = pop(return_stack);
      push(return_stack, jojo + 1);
    }
    #+end_src

* *name*

*** name_record

    #+begin_src c
    jo name_record[16 * 1024];
    cell name_record_counter = 0;
    #+end_src

*** p_name_record

    #+begin_src c
    p_name_record() {
      push(data_stack, name_record);
    }
    #+end_src

*** binding_filter_stack

***** binding_filter_stack

      #+begin_src c
      stack binding_filter_stack; // of jo
      #+end_src

***** p_binding_filter_stack_push

      #+begin_src c
      p_binding_filter_stack_push() {
        push(binding_filter_stack, pop(data_stack));
      }
      #+end_src

***** p_binding_filter_stack_pop

      #+begin_src c
      p_binding_filter_stack_pop() {
        push(data_stack, pop(binding_filter_stack));
      }
      #+end_src

***** run_binding_filter

      #+begin_src c
      jo_apply_now(jo jo);

      run_binding_filter() {
        // [name] -> [name]
        stack_traverse_from_bottom(binding_filter_stack, jo_apply_now);
      }
      #+end_src

*** name_can_bind_p

    #+begin_src c
    bool name_can_bind_p(jo name) {
      if (name->tag == JO_DECLARED) {
        return true;
      }
      else if (used_jo_p(name)) {
        return false;
      }
      else {
        return true;
      }
    }
    #+end_src

*** p_bind_name

    #+begin_src c
    p_bind_name() {
      // [data tag name] -> {set-jotable}
      run_binding_filter();

      jo name = pop(data_stack);
      jo tag = pop(data_stack);
      cell data = pop(data_stack);

      if (!name_can_bind_p(name)) {
        report("- p_bind_name can not rebind\n");
        report("  name : %s\n", jo2str(name));
        report("  tag : %s\n", jo2str(tag));
        report("  data : %ld\n", data);
        report("  it has been bound as a %s\n", jo2str(name->tag));
        return;
      }

      name_record[name_record_counter] = name;
      name_record_counter++;
      name_record[name_record_counter] = 0;

      name->tag = tag;
      name->value = data;
    }
    #+end_src

*** p_rebind_name

    #+begin_src c
    p_rebind_name() {
      // [data tag name] -> {set-jotable}
      run_binding_filter();

      jo name = pop(data_stack);
      jo tag = pop(data_stack);
      cell data = pop(data_stack);

      if (!used_jo_p(name)) {
        name_record[name_record_counter] = name;
        name_record_counter++;
        name_record[name_record_counter] = 0;
      }

      name->tag = tag;
      name->value = data;
    }
    #+end_src

*** add_prim

    #+begin_src c
    add_prim(char* str, primitive fun) {
      jo name = str2jo(str);
      push(data_stack, fun);
      push(data_stack, TAG_PRIM);
      push(data_stack, name);
      p_bind_name();
    }
    #+end_src

*** add_prim_keyword

    #+begin_src c
    add_prim_keyword(char* str, primitive fun) {
      jo name = str2jo(str);
      push(data_stack, fun);
      push(data_stack, TAG_PRIM_KEYWORD);
      push(data_stack, name);
      p_bind_name();
    }
    #+end_src

*** expose_name

    #+begin_src c
    expose_name() {
      add_prim("bind-name", p_bind_name);
      add_prim("rebind-name", p_rebind_name);

      add_prim("name-record", p_name_record);

      add_prim("binding-filter-stack-push", p_binding_filter_stack_push);
      add_prim("binding-filter-stack-pop", p_binding_filter_stack_pop);
    }
    #+end_src

* *apply* & eval

*** [note]

    - be careful when calling jo_apply in primitive,
      because after push a jojo to return_stack,
      one need to exit current primitive to run the jojo.

      if wished follow a 'eval();' after jo_apply
      to return to the primitive function.

    - keyword_stack and alias_record
      form a hook for read_jo.

*** keyword_stack

    #+begin_src c
    stack keyword_stack; // of alias_pointer
    #+end_src

*** alias

    #+begin_src c
    typedef struct {
      jo nick;
      jo name;
    } alias_point;

    alias_point alias_record[1024];
    cell current_alias_pointer = 0;
    #+end_src

*** jo_apply

    #+begin_src c
    eval();
    p_debug();

    jo_apply(jo jo) {
      if (!used_jo_p(jo)) {
        report("- jo_apply meet undefined jo : %s\n", jo2str(jo));
        p_debug();
        return;
      }

      cell tag = jo->tag;

      if (tag == TAG_PRIM) {
        primitive primitive = jo->value;
        primitive();
      }
      else if (tag == TAG_JOJO) {
        cell jojo = jo->value;
        return_stack_new_point(jojo);
      }

      else if (tag == TAG_PRIM_KEYWORD) {
        push(keyword_stack, current_alias_pointer);
        primitive primitive = jo->value;
        primitive();
        current_alias_pointer = pop(keyword_stack);
      }
      else if (tag == TAG_KEYWORD) {
        // keywords are always evaled
        push(keyword_stack, current_alias_pointer);
        cell jojo = jo->value;
        return_stack_new_point(jojo);
        eval();
        current_alias_pointer = pop(keyword_stack);
      }

      else if (tag == TAG_DATA) {
        cell cell = jo->value;
        push(data_stack, cell);
      }
      else {
        cell cell = jo->value;
        push(data_stack, cell);
        push(data_stack, tag);
      }
    }
    #+end_src

*** jo_apply_now

    #+begin_src c
    jo_apply_now(jo jo) {
      cell tag = jo->tag;
      if (tag == TAG_JOJO) {
        cell jojo = jo->value;
        return_stack_new_point(jojo);
        eval();
        return;
      }
      else {
        jo_apply(jo);
        return;
      }
    }
    #+end_src

*** jo_apply_with_local_pointer

    #+begin_src c
    jo_apply_with_local_pointer(jo jo, cell local_pointer) {
      cell tag = jo->tag;
      if (tag == TAG_JOJO) {
        cell jojo = jo->value;
        return_stack_make_point(jojo, local_pointer);
        return;
      }
      else {
        jo_apply(jo);
        return;
      }
    }
    #+end_src

*** eval

    #+begin_src c
    bool step_flag = false;

    stepper();
    exit_stepper();

    eval() {
      cell base = return_stack->pointer;
      while (return_stack->pointer >= base) {
        return_point rp = return_stack_tos();
        return_stack_inc();
        jo* jojo = rp.jojo;
        jo jo = jojo[0];
        jo_apply(jo);
        if (step_flag == true) {
          stepper();
        }
      }
      if (step_flag == true) {
        report("- the stepped jojo is finished\n");
        exit_stepper();
      }
    }
    #+end_src

*** p_apply

    #+begin_src c
    p_apply() {
      return_stack_new_point(pop(data_stack));
    }
    #+end_src

*** p_apply_with_local_pointer

    #+begin_src c
    p_apply_with_local_pointer() {
      // [local_pointer jojo] -> [*]
      jo* jojo = pop(data_stack);
      cell local_pointer = pop(data_stack);
      return_stack_make_point(jojo, local_pointer);
    }
    #+end_src

*** p_jo_apply

    #+begin_src c
    p_jo_apply() {
      jo_apply(pop(data_stack));
    }
    #+end_src

*** p_jo_apply_with_local_pointer

    #+begin_src c
    p_jo_apply_with_local_pointer() {
      jo jo = pop(data_stack);
      cell local_pointer = pop(data_stack);
      jo_apply_with_local_pointer(jo, local_pointer);
    }
    #+end_src

*** expose_apply

    #+begin_src c
    expose_apply() {
      add_prim("apply", p_apply);
      add_prim("apply-with-local-pointer", p_apply_with_local_pointer);

      add_prim("jo/apply", p_jo_apply);
      add_prim("jo/apply-with-local-pointer", p_jo_apply_with_local_pointer);
    }
    #+end_src

* *stack_operation*

*** p_drop

    #+begin_src c
    p_drop() {
      pop(data_stack);
    }
    #+end_src

*** p_2drop

    #+begin_src c
    p_2drop() {
      pop(data_stack);
      pop(data_stack);
    }
    #+end_src

*** p_dup

    #+begin_src c
    p_dup() {
      // a a -> a
      cell a = pop(data_stack);
      push(data_stack, a);
      push(data_stack, a);
    }
    #+end_src

*** p_2dup

    #+begin_src c
    p_2dup() {
      // b a -> b a b a
      cell a = pop(data_stack);
      cell b = pop(data_stack);
      push(data_stack, b);
      push(data_stack, a);
      push(data_stack, b);
      push(data_stack, a);
    }
    #+end_src

*** p_over

    #+begin_src c
    p_over() {
      // b a -> b a b
      cell a = pop(data_stack);
      cell b = pop(data_stack);
      push(data_stack, b);
      push(data_stack, a);
      push(data_stack, b);
    }
    #+end_src

*** p_2over

    #+begin_src c
    p_2over() {
      // d c  b a -> d c  b a  d c
      cell a = pop(data_stack);
      cell b = pop(data_stack);
      cell c = pop(data_stack);
      cell d = pop(data_stack);
      push(data_stack, d);
      push(data_stack, c);
      push(data_stack, b);
      push(data_stack, a);
      push(data_stack, d);
      push(data_stack, c);
    }
    #+end_src

*** p_tuck

    #+begin_src c
    p_tuck() {
      // b a -> a b a
      cell a = pop(data_stack);
      cell b = pop(data_stack);
      push(data_stack, a);
      push(data_stack, b);
      push(data_stack, a);
    }
    #+end_src

*** p_2tuck

    #+begin_src c
    p_2tuck() {
      // d c  b a -> b a  d c  b a
      cell a = pop(data_stack);
      cell b = pop(data_stack);
      cell c = pop(data_stack);
      cell d = pop(data_stack);
      push(data_stack, b);
      push(data_stack, a);
      push(data_stack, d);
      push(data_stack, c);
      push(data_stack, b);
      push(data_stack, a);
    }
    #+end_src

*** p_swap

    #+begin_src c
    p_swap() {
      // b a -> a b
      cell a = pop(data_stack);
      cell b = pop(data_stack);
      push(data_stack, a);
      push(data_stack, b);
    }
    #+end_src

*** p_2swap

    #+begin_src c
    p_2swap() {
      // d c  b a -> b a  d c
      cell a = pop(data_stack);
      cell b = pop(data_stack);
      cell c = pop(data_stack);
      cell d = pop(data_stack);
      push(data_stack, b);
      push(data_stack, a);
      push(data_stack, d);
      push(data_stack, c);
    }
    #+end_src

*** p_print_data_stack

    #+begin_src c
    print_data_stack_data(cell data) {
      report("%ld ", data);
    }

    p_print_data_stack() {
      // {terminal-output}
      report("  * %ld *  ", stack_length(data_stack));
      report("-- ");
      stack_traverse_from_bottom(data_stack, print_data_stack_data);
      report("--\n");
    }
    #+end_src

*** expose_stack_operation

    #+begin_src c
    expose_stack_operation() {
      add_prim("drop", p_drop);
      add_prim("2drop", p_2drop);
      add_prim("dup", p_dup);
      add_prim("2dup", p_2dup);
      add_prim("over", p_over);
      add_prim("2over", p_2over);
      add_prim("tuck", p_tuck);
      add_prim("2tuck", p_2tuck);
      add_prim("swap", p_swap);
      add_prim("2swap", p_2swap);
      add_prim("print-data-stack", p_print_data_stack);
    }
    #+end_src

* *ending*

*** p_end

    #+begin_src c
    p_end() {
      return_point rp = return_stack_pop();
      current_local_pointer = rp.local_pointer;
    }
    #+end_src

*** p_bye

    #+begin_src c
    p_bye() {
      report("bye bye ^-^/\n");
      exit(0);
    }
    #+end_src

*** expose_ending

    #+begin_src c
    expose_ending() {
      add_prim("end", p_end);
      add_prim("bye", p_bye);
    }
    #+end_src

* *byte*

*** reading_stack

    #+begin_src c
    stack reading_stack; // of input_stack
    #+end_src

*** writing_stack

    #+begin_src c
    stack writing_stack; // of output_stack
    #+end_src

*** has_byte_p

    #+begin_src c
    bool has_byte_p() {
      return !input_stack_empty_p(tos(reading_stack));
    }
    #+end_src

*** p_has_byte_p

    #+begin_src c
    p_has_byte_p() {
      push(data_stack, has_byte_p());
    }
    #+end_src

*** read_byte

    #+begin_src c
    byte read_byte() {
      return input_stack_pop(tos(reading_stack));
    }
    #+end_src

*** p_read_byte

    #+begin_src c
    p_read_byte() {
      // -> byte
      push(data_stack, read_byte());
    }
    #+end_src

*** byte_unread

    #+begin_src c
    byte_unread(byte b) {
      input_stack_push(tos(reading_stack), b);
    }
    #+end_src

*** p_byte_unread

    #+begin_src c
    p_byte_unread() {
      // byte -> {reading_stack}
      byte_unread(pop(data_stack));
    }
    #+end_src

*** byte_print

    #+begin_src c
    byte_print(byte b) {
      output_stack_push(tos(writing_stack), b);
    }
    #+end_src

*** p_byte_print

    #+begin_src c
    p_byte_print() {
      // byte ->
      byte_print(pop(data_stack));
    }
    #+end_src

*** p_ignore_until_double_quote

    #+begin_src c
    p_ignore_until_double_quote() {
      while (true) {
        byte b = read_byte();
        if (b == '"') {
          return;
        }
        else {
          // loop
        }
      }
    }
    #+end_src

*** k_one_byte

    #+begin_src c
    k_one_byte() {
      byte byte = read_byte();
      p_ignore_until_double_quote();
      here(JO_INS_BYTE);
      here(byte);
    }
    #+end_src

*** k_byte

    #+begin_src c
    jo read_raw_jo();

    k_byte() {
      // (byte ...)
      while (true) {
        jo jo = read_raw_jo();
        if (jo == ROUND_KET) {
          return;
        }
        else if (jo == DOUBLE_QUOTE) {
          k_one_byte();
          // loop
        }
        else {
          // loop
        }
      }
    }
    #+end_src

*** expose_byte

    #+begin_src c
    i_int();

    expose_byte() {
      add_prim("has-byte?", p_has_byte_p);
      add_prim("read/byte", p_read_byte);
      add_prim("byte/unread", p_byte_unread);
      add_prim("byte/print", p_byte_print);
      add_prim("ignore-until-double-quote", p_ignore_until_double_quote);

      add_prim("ins/byte", i_int);
      add_prim_keyword("byte", k_byte);
    }
    #+end_src

* *bool*

*** p_true

    #+begin_src c
    p_true() {
      push(data_stack, true);
    }
    #+end_src

*** p_false

    #+begin_src c
    p_false() {
      push(data_stack, false);
    }
    #+end_src

*** p_not

    #+begin_src c
    p_not() {
      // bool -> bool
      cell a = pop(data_stack);
      push(data_stack, !a);
    }
    #+end_src

*** p_and

    #+begin_src c
    p_and() {
      // bool bool -> bool
      cell a = pop(data_stack);
      cell b = pop(data_stack);
      push(data_stack, a&&b);
    }
    #+end_src

*** p_or

    #+begin_src c
    p_or() {
      // bool bool -> bool
      cell a = pop(data_stack);
      cell b = pop(data_stack);
      push(data_stack, a||b);
    }
    #+end_src

*** expose_bool

    #+begin_src c
    expose_bool() {
      add_prim("true", p_true);
      add_prim("false", p_false);
      add_prim("not", p_not);
      add_prim("and", p_and);
      add_prim("or", p_or);
    }
    #+end_src

* *string*

*** k_one_string

    #+begin_src c
    k_one_string() {
      // "..."
      char buffer[1024 * 1024];
      cell cursor = 0;
      while (true) {
        char c = read_byte();
        if (c == '"') {
          buffer[cursor] = 0;
          cursor++;
          break;
        }
        else {
          buffer[cursor] = c;
          cursor++;
        }
      }
      char* str = malloc(cursor);
      strcpy(str, buffer);
      here(JO_INS_STRING);
      here(str);
    }
    #+end_src

*** k_string

    #+begin_src c
    k_string() {
      // (string "...")
      while (true) {
        jo s = read_raw_jo();
        if (s == ROUND_KET) {
          return;
        }
        else if (s == DOUBLE_QUOTE) {
          k_one_string();
        }
        else {
          // do nothing
        }
      }
    }
    #+end_src

*** p_string_length

    #+begin_src c
    p_string_length() {
      // string -> length
      push(data_stack, strlen(pop(data_stack)));
    }
    #+end_src

*** string_print

    #+begin_src c
    string_print(char* str) {
      while (str[0] != '\0') {
        byte_print(str[0]);
        str++;
      }
    }
    #+end_src

*** p_string_print

    #+begin_src c
    p_string_print() {
      // string -> {terminal-output}
      string_print(pop(data_stack));
    }
    #+end_src

*** p_string_append_to_buffer

    #+begin_src c
    p_string_append_to_buffer() {
      // buffer string -> buffer
      char* str = pop(data_stack);
      char* buffer = tos(data_stack);
      strcat(buffer, str);
    }
    #+end_src

***** p_string_first_byte

    #+begin_src c
    p_string_first_byte() {
      char* s = pop(data_stack);
      push(data_stack, s[0]);
    }
    #+end_src

*** p_string_last_byte

    #+begin_src c
    p_string_last_byte() {
      char* s = pop(data_stack);
      cell i = 0;
      while (s[i+1] != 0) {
        i++;
      }
      push(data_stack, s[i]);
    }
    #+end_src

*** p_string_member_p

    #+begin_src c
    p_string_member_p() {
      // non-zero-byte string -> true or false
      char* s = pop(data_stack);
      byte b = pop(data_stack);
      cell i = 0;
      while (s[i] != 0) {
        if (s[i] == b) {
          push(data_stack, true);
          return;
        }
        else {
          i++;
        }
      }
      push(data_stack, false);
    }
    #+end_src

*** p_string_find_byte

    #+begin_src c
    p_string_find_byte() {
      // byte string -> [index true] or [false]
      char* s = pop(data_stack);
      byte b = pop(data_stack);
      cell i = 0;
      while (s[i] != 0) {
        if (s[i] == b) {
          push(data_stack, i);
          push(data_stack, true);
          return;
        }
        else {
          i++;
        }
      }
      push(data_stack, false);
    }
    #+end_src

*** p_string_equal_p

    #+begin_src c
    p_string_equal_p() {
      push(data_stack, string_equal(pop(data_stack), pop(data_stack)));
    }
    #+end_src

*** expose_string

    #+begin_src c
    expose_string() {
      add_prim("ins/string", i_int);
      add_prim_keyword("string", k_string);
      add_prim_keyword("one-string", k_one_string);
      add_prim("string/print", p_string_print);
      add_prim("string/length", p_string_length);
      add_prim("string/append-to-buffer", p_string_append_to_buffer);
      add_prim("string/first-byte", p_string_first_byte);
      add_prim("string/last-byte", p_string_last_byte);
      add_prim("string/member?", p_string_member_p);
      add_prim("string/find-byte", p_string_find_byte);
      add_prim("string/equal?", p_string_equal_p);
    }
    #+end_src

* *int*

*** p_inc

    #+begin_src c
    p_inc() {
      cell a = pop(data_stack);
      push(data_stack, a + 1);
    }
    #+end_src

*** p_dec

    #+begin_src c
    p_dec() {
      cell a = pop(data_stack);
      push(data_stack, a - 1);
    }
    #+end_src

*** p_neg

    #+begin_src c
    p_neg() {
      cell a = pop(data_stack);
      push(data_stack, - a);
    }
    #+end_src

*** p_add

    #+begin_src c
    p_add() {
      cell b = pop(data_stack);
      cell a = pop(data_stack);
      push(data_stack, a + b);
    }
    #+end_src

*** p_sub

    #+begin_src c
    p_sub() {
      cell b = pop(data_stack);
      cell a = pop(data_stack);
      push(data_stack, a - b);
    }
    #+end_src

*** p_mul

    #+begin_src c
    p_mul() {
      cell b = pop(data_stack);
      cell a = pop(data_stack);
      push(data_stack, a * b);
    }
    #+end_src

*** p_div

    #+begin_src c
    p_div() {
      cell b = pop(data_stack);
      cell a = pop(data_stack);
      push(data_stack, a / b);
    }
    #+end_src

*** p_mod

    #+begin_src c
    p_mod() {
      cell b = pop(data_stack);
      cell a = pop(data_stack);
      push(data_stack, a % b);
    }
    #+end_src

*** p_eq_p

    #+begin_src c
    p_eq_p() {
      cell b = pop(data_stack);
      cell a = pop(data_stack);
      push(data_stack, a == b);
    }
    #+end_src

*** p_gt_p

    #+begin_src c
    p_gt_p() {
      cell b = pop(data_stack);
      cell a = pop(data_stack);
      push(data_stack, a > b);
    }
    #+end_src

*** p_lt_p

    #+begin_src c
    p_lt_p() {
      cell b = pop(data_stack);
      cell a = pop(data_stack);
      push(data_stack, a < b);
    }
    #+end_src

*** p_gteq_p

    #+begin_src c
    p_gteq_p() {
      cell b = pop(data_stack);
      cell a = pop(data_stack);
      push(data_stack, a >= b);
    }
    #+end_src

*** p_lteq_p

    #+begin_src c
    p_lteq_p() {
      cell b = pop(data_stack);
      cell a = pop(data_stack);
      push(data_stack, a <= b);
    }
    #+end_src

*** i_int

    #+begin_src c
    i_int() {
      // [] -> [cell] {return_stack}
      return_point rp = return_stack_tos();
      return_stack_inc();
      jo* jojo = rp.jojo;
      jo jo = jojo[0];
      push(data_stack, jo);
    }
    #+end_src

*** k_int

    #+begin_src c
    jo read_raw_jo();

    k_int() {
      // (int ...)
      while (true) {
        jo s = read_raw_jo();
        if (s == ROUND_KET) {
          break;
        }
        else {
          here(JO_INS_INT);
          here(string_to_int(jo2str(s)));
        }
      }
    }
    #+end_src

*** p_int_print

    #+begin_src c
    p_int_print() {
      char buffer [32];
      sprintf(buffer, "%ld", pop(data_stack));
      string_print(buffer);
    }
    #+end_src

*** expose_int

    #+begin_src c
    expose_int() {
      add_prim("inc", p_inc);
      add_prim("dec", p_dec);
      add_prim("neg", p_neg);

      add_prim("add", p_add);
      add_prim("sub", p_sub);

      add_prim("mul", p_mul);
      add_prim("div", p_div);
      add_prim("mod", p_mod);

      add_prim("eq?", p_eq_p);
      add_prim("gt?", p_gt_p);
      add_prim("lt?", p_lt_p);
      add_prim("gteq?", p_gteq_p);
      add_prim("lteq?", p_lteq_p);

      add_prim("ins/int", i_int);
      add_prim_keyword("int", k_int);

      add_prim("int/print", p_int_print);
    }
    #+end_src

* *memory*

*** p_allocate

    #+begin_src c
    p_allocate () {
      // size -> addr
      push(data_stack, calloc(pop(data_stack), 1));
    }
    #+end_src

*** p_free

    #+begin_src c
    p_free () {
      // addr ->
      free(pop(data_stack));
    }
    #+end_src

*** k_address

    #+begin_src c
    k_ignore();

    k_address() {
      // (address ...)
      here(JO_INS_ADDRESS);
      jo name = read_raw_jo();
      here(&(name->value));
      k_ignore();
    }
    #+end_src

*** p_jo_as_var

    #+begin_src c
    p_jo_as_var() {
      jo jo = pop(data_stack);
      push(data_stack, &(jo->value));
    }
    #+end_src

*** p_set_cell

    #+begin_src c
    p_set_cell() {
      // cell address ->
      cell* address = pop(data_stack);
      cell value = pop(data_stack);
      address[0] = value;
    }
    #+end_src

*** p_get_cell

    #+begin_src c
    p_get_cell() {
      // address -> cell
      cell* address = pop(data_stack);
      push(data_stack, address[0]);
    }
    #+end_src

*** p_set_byte

    #+begin_src c
    p_set_byte() {
      // byte address ->
      char* address = pop(data_stack);
      cell value = pop(data_stack);
      address[0] = value;
    }
    #+end_src

*** p_get_byte

    #+begin_src c
    p_get_byte() {
      // address -> byte
      char* address = pop(data_stack);
      push(data_stack, address[0]);
    }
    #+end_src

*** expose_memory

    #+begin_src c
    expose_memory() {
      add_prim("allocate", p_allocate);
      add_prim("free", p_free);

      add_prim("ins/address", i_int);
      add_prim_keyword("address", k_address);

      add_prim("jo-as-var", p_jo_as_var);
      add_prim("set-cell", p_set_cell);
      add_prim("get-cell", p_get_cell);
      add_prim("set-byte", p_set_byte);
      add_prim("get-byte", p_get_byte);
    }
    #+end_src

* *jo*

*** p_alias_add

    #+begin_src c
    p_alias_add() {
      jo name = pop(data_stack);
      jo nick = pop(data_stack);
      alias_record[current_alias_pointer].nick = nick;
      alias_record[current_alias_pointer].name = name;
      current_alias_pointer++;
    }
    #+end_src

*** p_alias_filter

    #+begin_src c
    p_alias_filter() {
      // nick -> name
      if (stack_empty_p(keyword_stack)) {
        return;
      }
      jo nick = pop(data_stack);
      cell base = tos(keyword_stack);
      cell i = current_alias_pointer;
      while (i >= base) {
        if (alias_record[i].nick == nick) {
          push(data_stack, alias_record[i].name);
          return;
        }
        else {
          i--;
        }
      }
      push(data_stack, nick);
    }
    #+end_src

*** has_jo_p

    #+begin_src c
    bool has_jo_p() {
      byte c;
      while (true) {

        if (!has_byte_p()) {
          return false;
        }

        c = read_byte();

        if (isspace(c)) {
          // loop
        }
        else {
          byte_unread(c);
          return true;
        }
      }
    }
    #+end_src

*** p_has_jo_p

    #+begin_src c
    p_has_jo_p() {
      push(data_stack, has_jo_p());
    }
    #+end_src

*** p_read_raw_jo

    #+begin_src c
    p_read_raw_jo() {
      // {reading_stack} -> jo
      byte buf[1024];
      cell cur = 0;
      cell collecting = false;
      byte c;
      byte go = true;

      while (go) {

        if (!has_byte_p()) {
          if (!collecting) {
            report("- p_read_raw_jo meet end-of-file\n");
            return;
          }
          else {
            break;
          }
        }

        c = read_byte(); // report("- read_byte() : %c\n", c);

        if (!collecting) {
          if (isspace(c)) {
            // loop
          }
          else {
            collecting = true;
            buf[cur] = c;
            cur++;
            if (isbarcket(c)) {
              go = false;
            }
          }
        }

        else {
          if (isbarcket(c) ||
              isspace(c)) {
            byte_unread(c);
            go = false;
          }
          else {
            buf[cur] = c;
            cur++;
          }
        }
      }

      buf[cur] = 0;
      push(data_stack, str2jo(buf));
    }
    #+end_src

*** jo_filter_stack

***** jo_filter_stack

      #+begin_src c
      stack jo_filter_stack; // of jo
      #+end_src

***** p_jo_filter_stack_push

      #+begin_src c
      p_jo_filter_stack_push() {
        push(jo_filter_stack, pop(data_stack));
      }
      #+end_src

***** p_jo_filter_stack_pop

      #+begin_src c
      p_jo_filter_stack_pop() {
        push(data_stack, pop(jo_filter_stack));
      }
      #+end_src

***** run_jo_filter

      - the order is important

      #+begin_src c
      run_jo_filter() {
        stack_traverse_from_bottom(jo_filter_stack, jo_apply_now);
      }
      #+end_src

*** p_read_jo

    #+begin_src c
    p_read_jo() {
      p_read_raw_jo();
      run_jo_filter();
    }
    #+end_src

*** read_jo

    #+begin_src c
    jo read_jo() {
      p_read_jo();
      return pop(data_stack);
    }
    #+end_src

*** read_raw_jo

    #+begin_src c
    jo read_raw_jo() {
      p_read_raw_jo();
      return pop(data_stack);
    }
    #+end_src

*** string_unread

    #+begin_src c
    string_unread(char* str) {
      if (str[0] == '\0') {
        return;
      }
      else {
        string_unread(str+1);
        byte_unread(str[0]);
      }
    }
    #+end_src

*** p_jo_unread

    #+begin_src c
    p_jo_unread() {
      // jo -> {tos of reading_stack}
      jo jo = pop(data_stack);
      char* str = jo2str(jo);
      byte_unread(' ');
      string_unread(str);
      byte_unread(' ');
    }
    #+end_src

*** cat_2_jo

    #+begin_src c
    jo cat_2_jo(jo x, jo y) {
      char str[2 * 1024];
      str[0] = 0;
      strcat(str, jo2str(x));
      strcat(str, jo2str(y));
      return str2jo(str);
    }
    #+end_src

*** cat_3_jo

    #+begin_src c
    jo cat_3_jo(jo x, jo y, jo z) {
      char str[3 * 1024];
      str[0] = 0;
      strcat(str, jo2str(x));
      strcat(str, jo2str(y));
      strcat(str, jo2str(z));
      return str2jo(str);
    }
    #+end_src

*** p_jo_append

    #+begin_src c
    p_jo_append() {
      jo jo2 = pop(data_stack);
      jo jo1 = pop(data_stack);
      push(data_stack, cat_2_jo(jo1, jo2));
    }
    #+end_src

*** p_empty_jo

    #+begin_src c
    p_empty_jo() {
      push(data_stack, EMPTY_JO);
    }
    #+end_src

*** p_jo_used_p

    #+begin_src c
    p_jo_used_p() {
      // jo -> bool
      jo jo = pop(data_stack);
      push(data_stack, used_jo_p(jo));
    }
    #+end_src

*** p_jo_to_string

    #+begin_src c
    p_jo_to_string() {
      // jo -> string
      jo jo = pop(data_stack);
      push(data_stack, jo2str(jo));
    }
    #+end_src

*** p_string_length_to_jo

    #+begin_src c
    p_string_length_to_jo() {
      // string length -> jo
      cell len = pop(data_stack);
      cell str = pop(data_stack);
      char buffer[2 * 1024];
      strncpy(buffer, str, len);
      buffer[len] = 0;
      push(data_stack, str2jo(buffer));
    }
    #+end_src

*** p_string_to_jo

    #+begin_src c
    p_string_to_jo() {
      // string -> jo
      char* str = pop(data_stack);
      push(data_stack, str2jo(str));
    }
    #+end_src

*** p_null

    #+begin_src c
    p_null() {
      push(data_stack, JO_NULL);
    }
    #+end_src

*** k_raw_jo

    #+begin_src c
    k_raw_jo() {
      // (raw-jo ...)
      while (true) {
        jo s = read_raw_jo();
        if (s == ROUND_BAR) {
          jo_apply(read_jo());
        }
        else if (s == ROUND_KET) {
          break;
        }
        else {
          here(JO_INS_JO);
          here(s);
        }
      }
    }
    #+end_src

*** k_jo

    #+begin_src c
    k_jo() {
      // (jo ...)
      while (true) {
        jo s = read_jo();
        if (s == ROUND_BAR) {
          jo_apply(read_jo());
        }
        else if (s == ROUND_KET) {
          break;
        }
        else {
          here(JO_INS_JO);
          here(s);
        }
      }
    }
    #+end_src

*** p_jo_print

    #+begin_src c
    p_jo_print() {
      // jo -> {terminal-output}
      string_print(jo2str(pop(data_stack)));
    }
    #+end_src

*** p_generate_jo

    #+begin_src c
    cell p_generate_jo_counter = 0;
    p_generate_jo() {
      char* s = pop(data_stack);
      char buffer [1024];
      sprintf(buffer, "%s:generated-jo#%ld", jo2str(s), p_generate_jo_counter);
      p_generate_jo_counter++;
      push(data_stack, str2jo(buffer));
    }
    #+end_src

*** p_jo_find_byte

    #+begin_src c
    p_jo_find_byte() {
      // byte jo -> [index true] or [false]
      p_jo_to_string();
      p_string_find_byte();
    }
    #+end_src

*** p_jo_right_part

    #+begin_src c
    p_jo_right_part() {
      // index jo -> jo
      jo jo = pop(data_stack);
      cell index = pop(data_stack);
      char* s = jo2str(jo);
      push(data_stack, str2jo(s + index));
    }
    #+end_src

*** p_jo_left_part

    #+begin_src c
    p_jo_left_part() {
      // index jo -> jo
      char target[1024];
      jo jo = pop(data_stack);
      cell index = pop(data_stack);
      char* source = jo2str(jo);
      cell i = 0;
      while (i < index) {
        target[i] = source[i];
        i++;
      }
      target[index] = 0;
      push(data_stack, str2jo(target));
    }
    #+end_src

*** p_jo_part

    #+begin_src c
    p_jo_part() {
      // index-begin index-end jo -> jo
      char target[1024];
      jo jo = pop(data_stack);
      cell index_end = pop(data_stack);
      cell index_begin = pop(data_stack);
      char* source = jo2str(jo);
      cell i = index_begin;
      while (i < index_end) {
        target[i] = source[i];
        i++;
      }
      target[index_end] = 0;
      push(data_stack, str2jo(target + index_begin));
    }
    #+end_src

*** expose_jo

    #+begin_src c
    expose_jo() {
      add_prim("null", p_null);

      add_prim("jo-filter-stack-push", p_jo_filter_stack_push);
      add_prim("jo-filter-stack-pop", p_jo_filter_stack_pop);

      add_prim("alias-add", p_alias_add);
      add_prim("alias-filter", p_alias_filter);

      add_prim("has-jo?", p_has_jo_p);

      add_prim("read/raw-jo", p_read_raw_jo);
      add_prim("read/jo", p_read_jo);

      add_prim("jo/unread", p_jo_unread);

      add_prim("ins/jo", i_int);
      add_prim_keyword("jo", k_jo);
      add_prim_keyword("raw-jo", k_raw_jo);

      add_prim("jo/used?", p_jo_used_p);
      add_prim("jo/append", p_jo_append);
      add_prim("empty-jo", p_empty_jo);
      add_prim("jo->string", p_jo_to_string);
      add_prim("string->jo", p_string_to_jo);
      add_prim("string/length->jo", p_string_length_to_jo);
      add_prim("jo/print", p_jo_print);
      add_prim("generate-jo", p_generate_jo);

      add_prim("jo/find-byte", p_jo_find_byte);
      add_prim("jo/left-part", p_jo_left_part);
      add_prim("jo/right-part", p_jo_right_part);
      add_prim("jo/part", p_jo_part);
    }
    #+end_src

* *file*

*** p_error_number_print

    #+begin_src c
    p_error_number_print() {
      // errno -> {terminal-output}
      int no = pop(data_stack);
      string_print(strerror(no));
    }
    #+end_src

*** p_path_open_read

    #+begin_src c
    p_path_open_read() {
      // [path] -> [file true] or [errno false]
      char* path = pop(data_stack);

      FILE* file = fopen(path, "r");
      if (file == NULL) {
        push(data_stack, errno);
        push(data_stack, false);
      }
      else {
        push(data_stack, file);
        push(data_stack, true);
      }
    }
    #+end_src

*** p_path_open_write

    #+begin_src c
    p_path_open_write() {
      // [path] -> [file true] or [errno false]
      char* path = pop(data_stack);

      FILE* file = fopen(path, "wx");
      if (file == NULL) {
        push(data_stack, errno);
        push(data_stack, false);
      }
      else {
        push(data_stack, file);
        push(data_stack, true);
      }
    }
    #+end_src

*** p_path_open_read_and_write

    #+begin_src c
    p_path_open_read_and_write() {
      // [path] -> [file true] or [errno false]
      char* path = pop(data_stack);

      FILE* file = fopen(path, "r+");
      if (file == NULL) {
        push(data_stack, errno);
        push(data_stack, false);
      }
      else {
        push(data_stack, file);
        push(data_stack, true);
      }
    }
    #+end_src

*** p_path_open_create

    #+begin_src c
    p_path_open_create() {
      // [path] -> [file true] or [errno false]
      char* path = pop(data_stack);

      FILE* file = fopen(path, "w+");
      if (file == NULL) {
        push(data_stack, errno);
        push(data_stack, false);
      }
      else {
        push(data_stack, file);
        push(data_stack, true);
      }
    }
    #+end_src

*** p_file_close

    #+begin_src c
    p_file_close() {
      // [file] -> [true] or [errno false]
      // - error reasons
      // 1. to close an unopened file descriptor
      // 2. close the same file descriptor twice
      // 3. error conditions for specific file system
      //    to diagnose during a close operation
      //    - for example, NFS (Network File System)
      FILE* file = pop(data_stack);

      if (fclose(file) == EOF) {
        push(data_stack, errno);
        push(data_stack, false);
      }
      else {
        push(data_stack, true);
      }
    }
    #+end_src

*** p_file_end_p

    #+begin_src c
    p_file_end_p() {
      // file -> true or false
      FILE* file = pop(data_stack);

      if (feof(file)) {
        push(data_stack, true);
      }
      else {
        push(data_stack, false);
      }
    }
    #+end_src

*** p_file_read

    #+begin_src c
    p_file_read() {
      // [file buffer requested-bytes] ->
      // [real-bytes true] or [errno false]
      // - partial read reasons
      //   1. [regular-file] end-of-file is reached
      //   2. [terminal] meets '\n'
      size_t want_bytes = pop(data_stack);
      void* buffer = pop(data_stack);
      FILE* file = pop(data_stack);

      size_t real_bytes = fread(buffer, 1, file, want_bytes);
      if (real_bytes != want_bytes) {
        if (ferror(file)) {
          push(data_stack, errno);
          push(data_stack, false);
        }
        else {
          push(data_stack, real_bytes);
          push(data_stack, true);
        }
      }
      else {
        push(data_stack, real_bytes);
        push(data_stack, true);
      }
    }
    #+end_src

*** p_file_write

    #+begin_src c
    p_file_write() {
      // [file buffer want-bytes] ->
      // [true] or [errno false]
      // - partial write reasons
      //   1. disk was filled
      //   2. the process resource limit on file sizes was reached
      size_t want_bytes = pop(data_stack);
      void* buffer = pop(data_stack);
      FILE* file = pop(data_stack);

      ssize_t real_bytes = fwrite(buffer, 1, want_bytes, file);
      if (real_bytes != want_bytes) {
        push(data_stack, errno);
        push(data_stack, false);
      }
      else {
        push(data_stack, true);
      }
    }
    #+end_src

*** p_file_size

    #+begin_src c
    p_file_size() {
      // file -> int
      FILE* file = pop(data_stack);
      struct stat file_state;
      fstat(fileno(file), &file_state);
      push(data_stack, file_state.st_size);
    }
    #+end_src

*** p_file_regular_file_p

    #+begin_src c
    p_file_regular_file_p() {
      // file -> true or false
      FILE* file = pop(data_stack);
      struct stat file_state;
      fstat(fileno(file), &file_state);
      if ((file_state.st_mode & S_IFMT) == S_IFREG) {
        push(data_stack, true);
      }
      else {
        push(data_stack, false);
      }
    }
    #+end_src

*** p_file_directory_p

    #+begin_src c
    p_file_directory_p() {
      // file -> true or false
      FILE* file = pop(data_stack);
      struct stat file_state;
      fstat(fileno(file), &file_state);
      if ((file_state.st_mode & S_IFMT) == S_IFDIR) {
        push(data_stack, true);
      }
      else {
        push(data_stack, false);
      }
    }
    #+end_src

*** p_file_character_device_p

    #+begin_src c
    p_file_character_device_p() {
      // file -> true or false
      FILE* file = pop(data_stack);
      struct stat file_state;
      fstat(fileno(file), &file_state);
      if ((file_state.st_mode & S_IFMT) == S_IFCHR) {
        push(data_stack, true);
      }
      else {
        push(data_stack, false);
      }
    }
    #+end_src

*** p_file_block_device_p

    #+begin_src c
    p_file_block_device_p() {
      // file -> true or false
      FILE* file = pop(data_stack);
      struct stat file_state;
      fstat(fileno(file), &file_state);
      if ((file_state.st_mode & S_IFMT) == S_IFBLK) {
        push(data_stack, true);
      }
      else {
        push(data_stack, false);
      }
    }
    #+end_src

*** p_file_fifo_p

    #+begin_src c
    p_file_fifo_p() {
      // file -> true or false
      FILE* file = pop(data_stack);
      struct stat file_state;
      fstat(fileno(file), &file_state);
      if ((file_state.st_mode & S_IFMT) == S_IFIFO) {
        push(data_stack, true);
      }
      else {
        push(data_stack, false);
      }
    }
    #+end_src

*** p_file_socket_p

    #+begin_src c
    p_file_socket_p() {
      // file -> true or false
      FILE* file = pop(data_stack);
      struct stat file_state;
      fstat(fileno(file), &file_state);
      if ((file_state.st_mode & S_IFMT) == S_IFSOCK) {
        push(data_stack, true);
      }
      else {
        push(data_stack, false);
      }
    }
    #+end_src

*** p_path_exist_p

    #+begin_src c
    p_path_exist_p() {
      // path -> true or false
      char* path = pop(data_stack);

      if (access(path, F_OK) == -1) {
        push(data_stack, false);
      }
      else {
        push(data_stack, true);
      }
    }
    #+end_src

*** p_path_readable_p

    #+begin_src c
    p_path_readable_p() {
      // path -> true or false
      char* path = pop(data_stack);

      if (access(path, R_OK) == -1) {
        push(data_stack, false);
      }
      else {
        push(data_stack, true);
      }
    }
    #+end_src

*** p_path_writable_p

    #+begin_src c
    p_path_writable_p() {
      // path -> true or false
      char* path = pop(data_stack);

      if (access(path, W_OK) == -1) {
        push(data_stack, false);
      }
      else {
        push(data_stack, true);
      }
    }
    #+end_src

*** p_path_executable_p

    #+begin_src c
    p_path_executable_p() {
      // path -> true or false
      char* path = pop(data_stack);

      if (access(path, X_OK) == -1) {
        push(data_stack, false);
      }
      else {
        push(data_stack, true);
      }
    }
    #+end_src

*** p_file_print_path

    #+begin_src c
    p_file_print_path() {
      // file -> path
      FILE* file = pop(data_stack);

      char proc_link_path[PATH_MAX];
      char file_path[PATH_MAX];

      sprintf(proc_link_path, "/proc/self/fd/%d", fileno(file));

      ssize_t real_bytes = readlink(proc_link_path, file_path, PATH_MAX);
      if (real_bytes == -1) {
        report("- p_file_print_path fail readlink /proc/self/fd/%d\n", fileno(file));
        perror("\n");
      }
      else {
        file_path[real_bytes] = '\0';
        string_print(file_path);
      }
    }
    #+end_src

*** p_path_load

    #+begin_src c
    p_repl();

    p_path_load() {
      // path -> {reading_stack}
      char* path = pop(data_stack);
      int file = open(path, O_RDONLY);
      if(file == -1) {
        report("- p_path_load fail : %s\n", path);
        perror("file open failed");
        return;
      }
      input_stack input_stack = input_stack_file(file);
      push(reading_stack, input_stack);
      p_repl();
      drop(reading_stack);
      input_stack_free(input_stack);
      close(file);
    }
    #+end_src

*** get_real_reading_path

    #+begin_src c
    erase_real_path_to_dir(char* path) {
      cell cursor = strlen(path);
      while (path[cursor] != '/') {
        path[cursor] = '\0';
        cursor--;
      }
      path[cursor] = '\0';
    }

    char* get_real_reading_path(char* path) {
      // caller of this function
      // should free its return value
      char* real_reading_path = malloc(PATH_MAX);
      if (path[0] == '/' ||
          ((input_stack__t*)tos(reading_stack))->type == INPUT_STACK_TERMINAL) {
        realpath(path, real_reading_path);
        return real_reading_path;
      }
      else {
        char* proc_link_path = malloc(PATH_MAX);
        sprintf(proc_link_path,
                "/proc/self/fd/%d",
                ((input_stack__t*)tos(reading_stack))->file);
        ssize_t real_bytes = readlink(proc_link_path, real_reading_path, PATH_MAX);
        if (real_bytes == -1) {
          report("- get_real_reading_path fail to readlink\n");
          report("  proc_link_path : %s\n", proc_link_path);
          perror("  readlink : ");
          free(proc_link_path);
          free(real_reading_path);
          p_debug();
          return NULL; // to fool the compiler
        }
        free(proc_link_path);
        real_reading_path[real_bytes] = '\0';
        erase_real_path_to_dir(real_reading_path);
        strcat(real_reading_path, "/");
        strcat(real_reading_path, path);
        return real_reading_path;
      }
    }
    #+end_src

*** k_one_include

    #+begin_src c
    k_one_include() {
      // "..."
      char* path = malloc(PATH_MAX);
      cell cursor = 0;
      while (true) {
        char c = read_byte();
        if (c == '"') {
          path[cursor] = 0;
          cursor++;
          break;
        }
        else {
          path[cursor] = c;
          cursor++;
        }
      }
      char* real_read_path = get_real_reading_path(path);
      free(path);
      push(data_stack, real_read_path);
      p_path_load();
      free(real_read_path);
    }
    #+end_src

*** k_include

    #+begin_src c
    k_include() {
      // (include "..." ...)
      while (true) {
        jo s = read_raw_jo();
        if (s == ROUND_KET) {
          return;
        }
        else if (s == ROUND_BAR) {
          jo_apply(read_jo());
        }
        else if (s == DOUBLE_QUOTE) {
          k_one_include();
        }
        else {
          // do nothing
        }
      }
    }
    #+end_src

*** expose_file

    #+begin_src c
    expose_file() {
      add_prim("error-number/print", p_error_number_print);

      add_prim("path/open/read", p_path_open_read);
      add_prim("path/open/write", p_path_open_write);
      add_prim("path/open/create", p_path_open_create);
      add_prim("path/open/read-and-write", p_path_open_read_and_write);

      add_prim("file/close", p_file_close);

      add_prim("file/read", p_file_read);
      add_prim("file/write", p_file_write);

      add_prim("file/size", p_file_size);

      add_prim("file/regular-file?", p_file_regular_file_p);
      add_prim("file/directory?", p_file_directory_p);
      add_prim("file/character-device?", p_file_character_device_p);
      add_prim("file/block-device?", p_file_block_device_p);
      add_prim("file/fifo?", p_file_fifo_p);
      add_prim("file/socket?", p_file_socket_p);

      add_prim("path/exist?", p_path_exist_p);
      add_prim("path/readable?", p_path_readable_p);
      add_prim("path/writable?", p_path_writable_p);
      add_prim("path/executable?", p_path_executable_p);

      add_prim("file/print-path", p_file_print_path);

      add_prim("path/load", p_path_load);
      add_prim_keyword("include", k_include);
    }
    #+end_src

* *system*

*** p_cmd_number

    #+begin_src c
    cell cmd_number;

    p_cmd_number() {
      // -> cmd_number
      push(data_stack, cmd_number);
    }
    #+end_src

*** p_index_to_cmd_string

    #+begin_src c
    char** cmd_string_array;

    p_index_to_cmd_string() {
      // index -> string
      cell index = pop(data_stack);
      char* cmd_string = cmd_string_array[index];
      push(data_stack, cmd_string);
    }
    #+end_src

*** p_find_env_string

    #+begin_src c
    p_find_env_string() {
      // string -> [env-string true] or [false]
      char* var_string = pop(data_stack);
      char* env_string = getenv(var_string);
      if (env_string == NULL) {
        push(data_stack, false);
      }
      else {
        push(data_stack, env_string);
        push(data_stack, true);
      }
    }
    #+end_src

*** p_string_sh_run

    #+begin_src c
    p_string_sh_run() {
      // string -> {*}
      system(pop(data_stack));
    }
    #+end_src

*** expose_system

    #+begin_src c
    expose_system() {
      add_prim("cmd-number", p_cmd_number);
      add_prim("index->cmd-string", p_index_to_cmd_string);
      add_prim("find-env-string", p_find_env_string);

      add_prim("string/sh-run", p_string_sh_run);
    }
    #+end_src

* *cffi*

*** ccall

    #+begin_src c
    ccall (char* function_name, void* lib) {
      primitive fun = dlsym(lib, function_name);
      if (fun == NULL) {
        report("- ccall fail\n");
        report("  function_name : %s\n", function_name);
        report("  dynamic link error : %s\n", dlerror());
      };
      fun();
    }
    #+end_src

*** k_clib_one

    #+begin_src c
    k_clib_one() {
      // "..."
      char* path = malloc(PATH_MAX);
      cell cursor = 0;
      while (true) {
        char c = read_byte();
        if (c == '"') {
          path[cursor] = 0;
          cursor++;
          break;
        }
        else {
          path[cursor] = c;
          cursor++;
        }
      }
      char* real_read_path = get_real_reading_path(path);
      free(path);
      void* lib = dlopen(real_read_path, RTLD_LAZY);
      if (lib == NULL) {
        report("- k_clib_one fail to open library\n");
        report("  real_read_path : %s\n", real_read_path);
        report("  dynamic link error : %s\n", dlerror());
        p_debug();
        return;
      };
      free(real_read_path);
      ccall("expose", lib);
    }
    #+end_src

*** k_clib

    #+begin_src c
    k_clib() {
      // (clib "..." ...)
      while (true) {
        jo s = read_raw_jo();
        if (s == ROUND_KET) {
          return;
        }
        else if (s == DOUBLE_QUOTE) {
          k_clib_one();
        }
        else {
          // do nothing
        }
      }
    }
    #+end_src

*** expose_cffi

    #+begin_src c
    expose_cffi() {
      add_prim("clib", k_clib);
    }
    #+end_src

* *top_level*

*** k_define

    #+begin_src c
    k_run();

    k_define() {
      jo name = read_jo();
      k_run();
      push(data_stack, name);
      p_bind_name();
    }
    #+end_src

*** k_redefine

    #+begin_src c
    k_redefine() {
      jo name = read_jo();
      k_run();
      push(data_stack, name);
      p_rebind_name();
    }
    #+end_src

*** p_defined_p

    #+begin_src c
    p_defined_p() {
      // [name] -> true or false
      jo name = pop(data_stack);
      push(data_stack, used_jo_p(name));
    }
    #+end_src

*** k_declare

***** [note]

      - no compile before define
        declare helps mutual recursive function

***** k_declare_one

      #+begin_src c
      k_declare_one() {
        jo jo = read_jo();
        jo->tag = JO_DECLARED;
        k_ignore();
      }
      #+end_src

***** k_declare

      #+begin_src c
      k_declare() {
        while (true) {
          jo s = read_jo();
          if (s == ROUND_KET) {
            return;
          }
          else if (s == ROUND_BAR) {
            k_declare_one();
          }
          else {
            // do nothing
          }
        }
      }
      #+end_src

*** p_declared_p

    #+begin_src c
    p_declared_p() {
      // [name] -> true or false
      jo name = pop(data_stack);
      if (name->tag == JO_DECLARED) {
        push(data_stack, true);
      }
      else {
        push(data_stack, false);
      }
    }
    #+end_src

*** k_run

    #+begin_src c
    p_compile_jojo();

    k_run() {
      // (run ...)
      jo* jojo = tos(compiling_stack);
      p_compile_jojo();
      return_stack_new_point(jojo);
      eval();
    }
    #+end_src

*** k_test

    #+begin_src c
    bool test_flag = false;
    p_test_flag() { push(data_stack, test_flag); }
    p_test_flag_on() { test_flag = true; }
    p_test_flag_off() { test_flag = false; }

    k_test() {
      if (test_flag) {
        k_run();
      }
      else {
        k_ignore();
      }
    }
    #+end_src

*** p_repl

    #+begin_src c
    bool repl_flag = false;
    p_repl_flag() { push(data_stack, repl_flag); }
    p_repl_flag_on() { repl_flag = true; }
    p_repl_flag_off() { repl_flag = false; }

    p_repl() {
      while (true) {
        if (!has_jo_p()) {
          return 69;
        }
        jo s = read_jo();
        if (s == ROUND_BAR) {
          jo_apply(read_jo());
          if (repl_flag) {
            p_print_data_stack();
          }
        }
        else {
          // loop
        }
      }
    }
    #+end_src

*** p_bare_jojo_print

    #+begin_src c
    p_bare_jojo_print() {
      // jojo -> {terminal-output}
      jo* jojo = pop(data_stack);
      report("[ ");
      while (true) {
        if (jojo[0] == 0 && jojo[1] == 0) {
          break;
        }
        else if (jojo[0] == JO_INS_INT) {
          report("(int %ld) ", jojo[1]);
          jojo++;
          jojo++;
        }
        else if (jojo[0] == JO_INS_JO) {
          report("(jo %s) ", jo2str(jojo[1]));
          jojo++;
          jojo++;
        }
        else if (jojo[0] == JO_INS_STRING) {
          report("(string \"%s\") ", (char*)jojo[1]);
          jojo++;
          jojo++;
        }
        else if (jojo[0] == JO_INS_BYTE) {
          report("(btye \"%c\") ", (char)jojo[1]);
          jojo++;
          jojo++;
        }
        else if (jojo[0] == JO_INS_BARE_JOJO) {
          report("(bare-jojo ");
          push(data_stack, jojo + 2);
          p_bare_jojo_print();
          report(") ");
          jojo = jojo + (cell)jojo[1];
          jojo++;
        }
        else if (jojo[0] == JO_INS_ADDRESS) {
          report("(address %ld) ", jojo[1]);
          jojo++;
          jojo++;
        }
        else if (jojo[0] == JO_INS_JUMP_IF_FALSE) {
          report("(jump-if-false %ld) ", jojo[1]);
          jojo++;
          jojo++;
        }
        else if (jojo[0] == JO_INS_JUMP) {
          report("(jump %ld) ", jojo[1]);
          jojo++;
          jojo++;
        }
        else if (jojo[0] == JO_INS_LOOP) {
          report("(loop) ");
          jojo++;
          jojo++;
        }
        else if (jojo[0] == JO_INS_RECUR) {
          report("(recur) ");
          jojo++;
          jojo++;
        }
        else if (jojo[0] == JO_INS_TAIL_CALL) {
          report("(tail-call %s) ", jo2str(jojo[1]));
          jojo++;
          jojo++;
        }
        else {
          report("%s ", jo2str(jojo[0]));
          jojo++;
        }
      }
      report("] ");
    }
    #+end_src

*** print_return_point

    #+begin_src c
    print_return_point(jo* jojo) {
      if (jojo <= current_local_pointer) {
        return;
      }
      report("    - ");
      if (jojo != tos(return_stack)) {
        report("{ %s } ", jo2str(*(jojo - 1)));
      }
      push(data_stack, jojo);
      p_bare_jojo_print();
      report("\n");
    }
    #+end_src

*** p_print_return_stack

    #+begin_src c
    p_print_return_stack() {
      report("  - return-stack :\n");
      stack_traverse_from_bottom(return_stack, print_return_point);
    }
    #+end_src

*** p_debug_repl

    #+begin_src c
    cell debug_repl_level = 0;

    p_debug_repl() {
      while (true) {
        if (!has_jo_p()) {
          return;
        }
        jo jo = read_raw_jo();
        if (jo == str2jo("help")) {
          report("- debug-repl usage :\n");
          report("  - available commands :\n");
          report("    help exit bye\n");
        }
        else if (jo == str2jo("exit")) {
          return;
        }
        else if (jo == str2jo("bye")) {
          p_bye();
          return;
        }
        else if (jo == ROUND_BAR) {
          jo_apply(read_jo());
          p_print_data_stack();
          report("debug[%ld]> ", debug_repl_level);
        }
        else {
          // loop
        }
      }
    }
    #+end_src

*** p_debug

    #+begin_src c
    p_debug() {
      push(reading_stack, input_stack_terminal());

      report("- in debug-repl [level %ld] >_<!\n", debug_repl_level);
      p_print_return_stack();
      p_print_data_stack();
      report("debug[%ld]> ", debug_repl_level);
      debug_repl_level++;
      p_debug_repl();
      debug_repl_level--;
      report("- exit debug-repl [level %ld]\n", debug_repl_level);

      drop(reading_stack);
    }
    #+end_src

*** stepper

    #+begin_src c
    cell stepper_counter = 0;
    cell pending_steps = 0;

    // return will not exit stepper
    // set step_flag to exit stepper
    exit_stepper() {
      step_flag = false;
      stepper_counter = 0;
      pending_steps = 0;
      report("- exit stepper\n");
      drop(reading_stack);
    }

    stepper() {
      push(reading_stack, input_stack_terminal());
      report("stepper> ");
      while (true) {

        if (pending_steps > 0) {
          p_print_return_stack();
          p_print_data_stack();
          stepper_counter++;
          report("- stepper counting : %ld\n", stepper_counter);
          pending_steps--;
          return;
        }

        jo jo = read_raw_jo();
        if (jo == str2jo("help")) {
          report("- stepper usage :\n");
          report("  type '.' to execute one step\n");
          report("  type a numebr to execute the number of steps\n");
          report("  - available commands :\n");
          report("    help exit bye\n");
        }
        else if (jo == str2jo(".")) {
          p_print_return_stack();
          p_print_data_stack();
          stepper_counter++;
          report("- stepper counting : %ld\n", stepper_counter);
          return;
        }
        else if (nat_string_p(jo2str(jo))) {
          p_print_return_stack();
          p_print_data_stack();
          stepper_counter++;
          report("- stepper counting : %ld\n", stepper_counter);
          pending_steps = string_to_int(jo2str(jo)) - 1;
          return;
        }
        else if (jo == str2jo("exit")) {
          exit_stepper();
          return;
        }
        else if (jo == str2jo("bye")) {
          p_bye();
          return;
        }
        else {
          // loop
        }
      }
    }
    #+end_src

*** p_step

    #+begin_src c
    p_step() {
      step_flag = true;
    }
    #+end_src

*** to handle kernel signal

***** [note]

      - A function is said to be reentrant
        if it can safely be simultaneously executed
        by multiple threads of execution in the same process.
        In this context, “safe” means that
        the function achieves its expected result,
        regardless of the state of execution
        of any other thread of execution.

        Because a signal handler may asynchronously interrupt
        the execution of a program at any point in time,
        the main program and the signal handler
        in effect form two independent
        (although not concurrent) threads of execution
        within the same process.

        -- quote from (2010) (michael kerrisk) the linux programming interface

      - thus single handler must be reentrant.

      - since nonreentrant functions in many C libraries [specially stdio],
        and we can call such functions in the debug repl of jojo,
        we should not simply call the debug repl in the kernel_signal_handler.

      - but except introducing runtime overhead,
        I can think of not solutions to this problem.

        thus, after exited the debug repl,
        possibly unnecessary errors that induced by nonreentrant functions,
        might lead you into the debug repl again.

        thus, the debug repl is not reliable to enable you
        to recover from any errors which trigger kernel signal.
        [the debug repl can only debug them.]

***** kernel_signal_handler

      #+begin_src c
      kernel_signal_handler(int sig, siginfo_t *siginfo, void *ucontext) {
        fflush(stdin);
        fflush(stdout);
        fflush(stderr);

        report("- kernel_signal_handler\n");
        psiginfo(siginfo, "  signal ");

        int errno_backup;
        errno_backup = errno;

        p_debug();

        errno = errno_backup;
      }
      #+end_src

***** init_kernel_signal_handler

      #+begin_src c
      init_kernel_signal_handler() {
        struct sigaction kernel_signal_action;

        sigemptyset(&kernel_signal_action.sa_mask);

        kernel_signal_action.sa_flags = SA_SIGINFO | SA_NODEFER | SA_RESTART;
        kernel_signal_action.sa_sigaction = kernel_signal_handler;

        int sig_array[] = { SIGSEGV, SIGBUS, SIGFPE, SIGILL,
                            SIGPIPE, SIGSYS, SIGXCPU, SIGXFSZ};
        int sig_array_length = sizeof(sig_array)/sizeof(sig_array[0]);
        cell i = 0;
        while (i < sig_array_length) {
          if (sigaction(sig_array[i], &kernel_signal_action, NULL) == -1) {
            perror("- init_kernel_signal_handler fail");
          }
          i++;
        }
      }
      #+end_src

*** expose_top_level

    #+begin_src c
    expose_top_level() {
      add_prim_keyword("define", k_define);
      add_prim_keyword("redefine", k_redefine);
      add_prim("defined?", p_defined_p);

      add_prim_keyword("declare", k_declare);
      add_prim("declared?", p_declared_p);

      add_prim_keyword("run", k_run);

      add_prim_keyword("test", k_test);
      add_prim("test-flag", p_test_flag);
      add_prim("test-flag/on", p_test_flag_on);
      add_prim("test-flag/off", p_test_flag_off);

      add_prim("repl", p_repl);
      add_prim("repl-flag", p_repl_flag);
      add_prim("repl-flag/on", p_repl_flag_on);
      add_prim("repl-flag/off", p_repl_flag_off);

      add_prim("bare-jojo/print", p_bare_jojo_print);
      add_prim("print-return-stack", p_print_return_stack);
      add_prim("debug", p_debug);

      add_prim("step", p_step);
    }
    #+end_src

* *keyword*

*** k_ignore

    #+begin_src c
    k_ignore() {
      while (true) {
        jo s = read_raw_jo();
        if (s == ROUND_BAR) {
          k_ignore();
        }
        if (s == ROUND_KET) {
          break;
        }
      }
    }
    #+end_src

*** compile_until_meet_jo

    #+begin_src c
    compile_until_meet_jo(jo ending_jo) {
      while (true) {
        jo jo = read_jo();
        if (jo == ROUND_BAR) {
          jo_apply(read_jo());
        }
        else if (jo == ending_jo) {
          break;
        }
        else if (used_jo_p(jo)) {
          here(jo);
        }
        else {
          // no compile before define
          report("- compile_until_meet_jo undefined : %s\n", jo2str(jo));
          k_ignore();
          p_debug();
          return;
        }
      }
    }
    #+end_src

*** p_compile_until_meet_jo

    #+begin_src c
    p_compile_until_meet_jo() {
      compile_until_meet_jo(pop(data_stack));
    }
    #+end_src

*** compile_until_meet_jo_or_jo

    #+begin_src c
    jo compile_until_meet_jo_or_jo(jo ending_jo1, jo ending_jo2) {
      while (true) {
        jo jo = read_jo();
        if (jo == ROUND_BAR) {
          jo_apply(read_jo());
        }
        else if (jo == ending_jo1 || jo == ending_jo2) {
          return jo;
        }
        else if (used_jo_p(jo)) {
          here(jo);
        }
        else {
          // no compile before define
          report("- compile_until_meet_jo_or_jo undefined : %s\n", jo2str(jo));
          report("- ending_jo1 : %s\n", jo2str(ending_jo1));
          report("- ending_jo2 : %s\n", jo2str(ending_jo2));
          k_ignore();
          p_debug();
          return JO_NULL; // to fool the compiler
        }
      }
    }
    #+end_src

*** p_compile_until_round_ket

    #+begin_src c
    p_compile_until_round_ket() {
      compile_until_meet_jo(ROUND_KET);
    }
    #+end_src

*** i_jump

    #+begin_src c
    i_jump() {
      // {return_stack}
      return_point rp = return_stack_tos();
      jo* jojo = rp.jojo;
      cell offset = jojo[0];
      return_point rp1 = return_stack_pop();
      return_stack_make_point(jojo + offset, rp1.local_pointer);
    }
    #+end_src

*** k_jump

    #+begin_src c
    k_jump() {
      here(JO_INS_JUMP);
      here(string_to_int(jo2str(read_raw_jo())));
      k_ignore();
    }
    #+end_src

*** i_jump_if_false

    #+begin_src c
    i_jump_if_false() {
      // [bool] -> {return_stack}
      return_point rp = return_stack_tos();
      return_stack_inc();
      jo* jojo = rp.jojo;
      cell offset = jojo[0];
      cell b = pop(data_stack);
      if (b == false) {
        return_point rp1 = return_stack_pop();
        return_stack_make_point(jojo + offset, rp1.local_pointer);
      }
    }
    #+end_src

*** k_jump_if_false

    #+begin_src c
    k_jump_if_false() {
      here(JO_INS_JUMP_IF_FALSE);
      here(string_to_int(jo2str(read_raw_jo())));
      k_ignore();
    }
    #+end_src

*** k_if

    #+begin_src c
    // - without else
    //   (if a b p? then c d)
    //   ==>
    //     a b p?
    //     jump_if_false[:end-of-then]
    //     c d
    //   :end-of-then

    // - with else
    //   (if a b p? then c d else e f)
    //   ==>
    //     a b p?
    //     jump_if_false[:end-of-then]
    //     c d
    //     jump[:end-of-else]
    //   :end-of-then
    //     e f
    //   :end-of-else

    k_if() {
      compile_until_meet_jo(JO_THEN);
      here(JO_INS_JUMP_IF_FALSE);
      jo* end_of_then = tos(compiling_stack);
      p_compiling_stack_inc();
      jo ending_jo = compile_until_meet_jo_or_jo(JO_ELSE, ROUND_KET);
      if (ending_jo == ROUND_KET) {
        end_of_then[0] = (jo*)tos(compiling_stack) - end_of_then;
        return;
      }
      else {
        here(JO_INS_JUMP);
        jo* end_of_else = tos(compiling_stack);
        p_compiling_stack_inc();
        end_of_then[0] = (jo*)tos(compiling_stack) - end_of_then;
        p_compile_until_round_ket();
        end_of_else[0] = (jo*)tos(compiling_stack) - end_of_else;
        return;
      }
    }
    #+end_src

*** current_compiling_jojo_stack

    #+begin_src c
    stack current_compiling_jojo_stack; // of jo
    #+end_src

*** p_compile_jojo

    #+begin_src c
    p_compile_jojo() {
      jo* jojo = tos(compiling_stack);
      push(current_compiling_jojo_stack, jojo);
      compile_until_meet_jo(ROUND_KET);
      here(JO_END);
      here(0);
      here(0);
      drop(current_compiling_jojo_stack);
    }
    #+end_src

*** i_tail_call

    #+begin_src c
    i_tail_call() {
      return_point rp = return_stack_pop();
      jo* jojo = rp.jojo;
      jo jo = jojo[0];
      jo_apply_with_local_pointer(jo, rp.local_pointer);
    }
    #+end_src

*** k_tail_call

    #+begin_src c
    k_tail_call() {
      // no check for "no compile before define"
      here(JO_INS_TAIL_CALL);
      here(read_jo());
      k_ignore();
    }
    #+end_src

*** i_loop

    #+begin_src c
    i_loop() {
      return_point rp = return_stack_pop();
      jo* jojo = rp.jojo;
      jo* jojo_self = jojo[0];
      return_stack_make_point(jojo_self, rp.local_pointer);
    }
    #+end_src

*** k_loop

    #+begin_src c
    k_loop() {
      here(JO_INS_LOOP);
      here(tos(current_compiling_jojo_stack));
      k_ignore();
    }
    #+end_src

*** i_recur

    #+begin_src c
    i_recur() {
      return_point rp = return_stack_tos();
      return_stack_inc();
      jo* jojo = rp.jojo;
      jo* jojo_self = jojo[0];
      return_stack_new_point(jojo_self);
    }
    #+end_src

*** k_recur

    #+begin_src c
    k_recur() {
      here(JO_INS_RECUR);
      here(tos(current_compiling_jojo_stack));
      k_ignore();
    }
    #+end_src

*** p_compiling_stack_tos

    #+begin_src c
    p_compiling_stack_tos() {
      push(data_stack, tos(compiling_stack));
    }
    #+end_src

*** i_bare_jojo

    #+begin_src c
    i_bare_jojo() {
      return_point rp = return_stack_pop();
      jo* jojo = rp.jojo;
      cell offset = jojo[0];
      return_stack_make_point(jojo + offset, rp.local_pointer);
      push(data_stack, jojo + 1);
    }
    #+end_src

*** k_bare_jojo

    #+begin_src c
    k_bare_jojo() {
      // (bare-jojo ...)
      here(JO_INS_BARE_JOJO);
      jo* beginning = tos(compiling_stack);
      p_compiling_stack_inc();
      p_compile_jojo();
      beginning[0] = (jo*)tos(compiling_stack) - beginning;
    }
    #+end_src

*** k_jojo

    #+begin_src c
    k_jojo() {
      // (jojo ...)
      k_bare_jojo();
      here(JO_INS_JO);
      here(TAG_JOJO);
    }
    #+end_src

*** k_keyword

    #+begin_src c
    k_keyword() {
      // (keyword ...)
      k_bare_jojo();
      here(JO_INS_JO);
      here(TAG_KEYWORD);
    }
    #+end_src

*** k_data

    - the semantic of this keyword has limitation,
      there can be not 'end' in it.

    #+begin_src c
    k_data() {
      // (data ...)
      p_compile_until_round_ket();
      here(JO_INS_JO);
      here(TAG_DATA);
    }
    #+end_src

*** local_find

    #+begin_src c
    cell local_find(jo name) {
      // return index of local_record
      // -1 -- no found
      return_point rp = return_stack_tos();
      cell cursor = current_local_pointer - 1;
      while (cursor >= rp.local_pointer) {
        if (local_record[cursor].name == name) {
          return cursor;
        }
        else {
          cursor--;
        }
      }
      return -1;
    }
    #+end_src

*** p_local_data_in

    #+begin_src c
    p_local_data_in() {
      cell jo = pop(data_stack);
      cell index = local_find(jo);
      cell data = pop(data_stack);
      if (index != -1) {
        local_record[index].name = jo;
        local_record[index].local_data = data;
      }
      else {
        local_record[current_local_pointer].name = jo;
        local_record[current_local_pointer].local_data = data;
        current_local_pointer = current_local_pointer + 1;
      }
    }
    #+end_src

*** p_local_data_out

    #+begin_src c
    p_local_data_out() {
      cell jo = pop(data_stack);
      cell index = local_find(jo);
      if (index != -1) {
        local_point lp = local_record[index];
        push(data_stack, lp.local_data);
      }
      else {
        report("- p_local_data_out fatal error\n");
        report("  name is not bound\n");
        report("  name : %s\n", jo2str(jo));
        p_debug();
      }
    }
    #+end_src

*** p_local_tag_in

    #+begin_src c
    p_local_tag_in() {
      cell jo = pop(data_stack);
      cell index = local_find(jo);
      cell tag = pop(data_stack);
      if (index != -1) {
        local_record[index].name = jo;
        local_record[index].local_tag = tag;
      }
      else {
        local_record[current_local_pointer].name = jo;
        local_record[current_local_pointer].local_tag = tag;
        current_local_pointer = current_local_pointer + 1;
      }
    }
    #+end_src

*** p_local_tag_out

    #+begin_src c
    p_local_tag_out() {
      cell jo = pop(data_stack);
      cell index = local_find(jo);
      if (index != -1) {
        local_point lp = local_record[index];
        push(data_stack, lp.local_tag);
      }
      else {
        report("- p_local_tag_out fatal error\n");
        report("  name is not bound\n");
        report("  name : %s\n", jo2str(jo));
        p_debug();
      }
    }
    #+end_src

*** p_local_in

    #+begin_src c
    p_local_in() {
      cell jo = pop(data_stack);
      cell index = local_find(jo);
      cell tag = pop(data_stack);
      cell data = pop(data_stack);
      if (index != -1) {
        local_record[index].name = jo;
        local_record[index].local_tag = tag;
        local_record[index].local_data = data;
      }
      else {
        local_record[current_local_pointer].name = jo;
        local_record[current_local_pointer].local_tag = tag;
        local_record[current_local_pointer].local_data = data;
        current_local_pointer = current_local_pointer + 1;
      }
    }
    #+end_src

*** p_local_out

    #+begin_src c
    p_local_out() {
      cell jo = pop(data_stack);
      cell index = local_find(jo);
      if (index != -1) {
        local_point lp = local_record[index];
        push(data_stack, lp.local_data);
        push(data_stack, lp.local_tag);
      }
      else {
        report("- p_local_out fatal error\n");
        report("  name is not bound\n");
        report("  name : %s\n", jo2str(jo));
        p_debug();
      }
    }
    #+end_src

*** k_local_data_in

    #+begin_src c
    k_local_data_in() {
      jo s = read_raw_jo();
      if (s == ROUND_KET) {
        return;
      }
      else {
        k_local_data_in();

        here(JO_INS_JO);
        here(s);
        here(JO_LOCAL_DATA_IN);
      }
    }
    #+end_src

*** k_local_data_out

    #+begin_src c
    k_local_data_out() {
      jo s = read_raw_jo();
      if (s == ROUND_KET) {
        return;
      }
      else {
        here(JO_INS_JO);
        here(s);
        here(JO_LOCAL_DATA_OUT);

        k_local_data_out();
      }
    }
    #+end_src

*** k_local_tag_in

    #+begin_src c
    k_local_tag_in() {
      jo s = read_raw_jo();
      if (s == ROUND_KET) {
        return;
      }
      else {
        k_local_data_in();

        here(JO_INS_JO);
        here(s);
        here(JO_LOCAL_TAG_IN);
      }
    }
    #+end_src

*** k_local_tag_out

    #+begin_src c
    k_local_tag_out() {
      jo s = read_raw_jo();
      if (s == ROUND_KET) {
        return;
      }
      else {
        here(JO_INS_JO);
        here(s);
        here(JO_LOCAL_TAG_OUT);

        k_local_data_out();
      }
    }
    #+end_src

*** k_local_in

    #+begin_src c
    k_local_in() {
      jo s = read_raw_jo();
      if (s == ROUND_KET) {
        return;
      }
      else {
        k_local_data_in();

        here(JO_INS_JO);
        here(s);
        here(JO_LOCAL_IN);
      }
    }
    #+end_src

*** k_local_out

    #+begin_src c
    k_local_out() {
      jo s = read_raw_jo();
      if (s == ROUND_KET) {
        return;
      }
      else {
        here(JO_INS_JO);
        here(s);
        here(JO_LOCAL_OUT);

        k_local_data_out();
      }
    }
    #+end_src

*** p_current_local_pointer

    #+begin_src c
    p_current_local_pointer() {
      push(data_stack, current_local_pointer);
    }
    #+end_src

*** expose_keyword

    #+begin_src c
    expose_keyword() {
      add_prim_keyword("ignore", k_ignore);
      add_prim_keyword("note", k_ignore);

      add_prim("compiling-stack/tos", p_compiling_stack_tos);
      add_prim("compiling-stack/inc", p_compiling_stack_inc);

      add_prim("compile-until-meet-jo", p_compile_until_meet_jo);
      add_prim("compile-until-round-ket", p_compile_until_round_ket);


      add_prim("ins/jump", i_jump);
      add_prim_keyword("jump", k_jump);

      add_prim("ins/jump-if-false", i_jump_if_false);
      add_prim_keyword("jump-if-false", k_jump_if_false);

      add_prim_keyword("if", k_if);
      add_prim_keyword("else", p_compile_until_round_ket);
      add_prim_keyword("el", p_compile_until_round_ket);

      add_prim("compile-jojo", p_compile_jojo);

      add_prim("ins/tail-call", i_tail_call);
      add_prim_keyword("tail-call", k_tail_call);
      add_prim("ins/loop", i_loop);
      add_prim_keyword("loop", k_loop);
      add_prim("ins/recur", i_recur);
      add_prim_keyword("recur", k_recur);

      add_prim_keyword("data", k_data);
      add_prim_keyword("jojo", k_jojo);
      add_prim_keyword("keyword", k_keyword);

      add_prim("ins/bare-jojo", i_bare_jojo);
      add_prim_keyword("bare-jojo", k_bare_jojo);

      add_prim("local-data-in", p_local_data_in);
      add_prim("local-data-out", p_local_data_out);
      add_prim_keyword(">", k_local_data_in);
      add_prim_keyword("<", k_local_data_out);

      add_prim("local-tag-in", p_local_tag_in);
      add_prim("local-tag-out", p_local_tag_out);
      add_prim_keyword("%>", k_local_tag_in);
      add_prim_keyword("<%", k_local_tag_out);

      add_prim("local-in", p_local_in);
      add_prim("local-out", p_local_out);
      add_prim_keyword(">>", k_local_in);
      add_prim_keyword("<<", k_local_out);

      add_prim("current-local-pointer", p_current_local_pointer);
    }
    #+end_src

* *misc*

*** p_here

    #+begin_src c
    p_here() {
      here(pop(data_stack));
    }
    #+end_src

*** bar and ket

    #+begin_src c
    p_round_bar()    { push(data_stack, ROUND_BAR); }
    p_round_ket()    { push(data_stack, ROUND_KET); }
    p_square_bar()   { push(data_stack, SQUARE_BAR); }
    p_square_ket()   { push(data_stack, SQUARE_KET); }
    p_flower_bar()   { push(data_stack, FLOWER_BAR); }
    p_flower_ket()   { push(data_stack, FLOWER_KET); }
    p_double_quote() { push(data_stack, DOUBLE_QUOTE); }
    #+end_src

*** p_cell_size

    #+begin_src c
    p_cell_size() {
      push(data_stack, sizeof(cell));
    }
    #+end_src

*** p_space

    #+begin_src c
    p_space() {
      output_stack_push(tos(writing_stack), ' ');
    }
    #+end_src

*** p_newline

    #+begin_src c
    p_newline() {
      output_stack_push(tos(writing_stack), '\n');
    }
    #+end_src

*** expose_mise

    #+begin_src c
    expose_mise() {
      add_prim("here", p_here);

      add_prim("round-bar", p_round_bar);
      add_prim("round-ket", p_round_ket);
      add_prim("square-bar", p_square_bar);
      add_prim("square-ket", p_square_ket);
      add_prim("flower-bar", p_flower_bar);
      add_prim("flower-ket", p_flower_ket);
      add_prim("double-quote", p_double_quote);

      add_prim("cell-size", p_cell_size);

      add_prim("space", p_space);
      add_prim("newline", p_newline);
    }
    #+end_src

* *play*

*** p1

    #+begin_src c
    p1() {
      int file = open("README", O_RDWR);
      input_stack t0_stack = input_stack_file(file);
      input_stack_push(t0_stack, '\n');
      input_stack_push(t0_stack, '\n');
      input_stack_push(t0_stack, '1');
      input_stack_push(t0_stack, '2');
      input_stack_push(t0_stack, '3');
      input_stack_push(t0_stack, '4');
      input_stack_push(t0_stack, '\n');
      input_stack_push(t0_stack, '\n');
      while (!input_stack_empty_p(t0_stack)) {
        report("%c", input_stack_pop(t0_stack));
      }
      input_stack_free(t0_stack);
      report("- input_stack test0 finished\n");

      input_stack t1_stack = input_stack_terminal();
      while (!input_stack_empty_p(t1_stack)) {
        byte byte = input_stack_pop(t1_stack);
        report("\n> %c", byte);
      }
      input_stack_free(t1_stack);
      report("- input_stack test1 finished\n");

      input_stack t2_stack = input_stack_string("1234567890");
      input_stack_push(t2_stack, '\n');
      input_stack_push(t2_stack, '\n');
      input_stack_push(t2_stack, '1');
      input_stack_push(t2_stack, '2');
      input_stack_push(t2_stack, '3');
      input_stack_push(t2_stack, '4');
      input_stack_push(t2_stack, '\n');
      input_stack_push(t2_stack, '\n');
      while (!input_stack_empty_p(t2_stack)) {
        byte byte = input_stack_pop(t2_stack);
        report("%c", byte);
      }
      input_stack_free(t2_stack);
      report("\n");
      report("- input_stack test2 finished\n");
    }
    #+end_src

*** p2

    #+begin_src c
    p2() {
      int file = open("k1~", O_RDWR);
      output_stack t0_stack = output_stack_file(file);
      output_stack_push(t0_stack, '1'); output_stack_pop(t0_stack);
      output_stack_push(t0_stack, '2');
      output_stack_push(t0_stack, '3'); output_stack_drop(t0_stack);
      output_stack_push(t0_stack, '4');
      output_stack_push(t0_stack, '\n');
      output_stack_file_flush(t0_stack);
      output_stack_push(t0_stack, '1');
      output_stack_push(t0_stack, '2'); output_stack_pop(t0_stack);
      output_stack_push(t0_stack, '3');
      output_stack_push(t0_stack, '4'); output_stack_drop(t0_stack);
      output_stack_push(t0_stack, '\n');
      output_stack_file_flush(t0_stack);
      output_stack_free(t0_stack);
      close(file);
      report("- output_stack test0 finished\n");

      output_stack t1_stack = output_stack_terminal();
      output_stack_push(t1_stack, '\n');
      output_stack_push(t1_stack, '\n');
      output_stack_push(t1_stack, '1');
      output_stack_push(t1_stack, '2');
      output_stack_push(t1_stack, '3');
      output_stack_push(t1_stack, '4');
      output_stack_push(t1_stack, '\n');
      output_stack_push(t1_stack, '\n');
      output_stack_free(t1_stack);
      report("- output_stack test1 finished\n");

      output_stack t2_stack = output_stack_string();
      output_stack_push(t2_stack, '1');
      output_stack_push(t2_stack, '2');
      report("- %c\n", output_stack_pop(t2_stack));
      output_stack_push(t2_stack, '3');
      output_stack_push(t2_stack, '4');
      report("- %c\n", output_stack_pop(t2_stack));
      output_stack_push(t2_stack, '\n');
      char* collected_string = output_stack_string_collect(t2_stack);
      report("- collected_string : %s\n", collected_string);
      output_stack_free(t2_stack);
      report("- output_stack test2 finished\n");
    }
    #+end_src

*** init_play

    #+begin_src c
    init_play() {
    }
    #+end_src

*** expose_play

    #+begin_src c
    expose_play() {
      add_prim("p1", p1);
      add_prim("p2", p2);
    }
    #+end_src

* init

*** init_system

    #+begin_src c
    init_system() {
      setvbuf(stdout, NULL, _IONBF, 0);
      setvbuf(stderr, NULL, _IONBF, 0);
    }
    #+end_src

*** init_jotable

    #+begin_src c
    init_jotable() {
      bzero(jotable, jotable_size * sizeof(jotable_entry));
    }
    #+end_src

*** init_literal_jo

    #+begin_src c
    init_literal_jo() {
      EMPTY_JO = str2jo("");

      TAG_PRIM         = str2jo("<prim>");
      TAG_JOJO         = str2jo("<jojo>");
      TAG_PRIM_KEYWORD = str2jo("<prim-keyword>");
      TAG_KEYWORD      = str2jo("<keyword>");
      TAG_DATA         = str2jo("<data>");

      JO_DECLARED = str2jo("declared");

      ROUND_BAR    =   str2jo("(");
      ROUND_KET    =   str2jo(")");
      SQUARE_BAR   =   str2jo("[");
      SQUARE_KET   =   str2jo("]");
      FLOWER_BAR   =   str2jo("{");
      FLOWER_KET   =   str2jo("}");
      DOUBLE_QUOTE =   str2jo("\"");

      JO_INS_INT  = str2jo("ins/int");
      JO_INS_JO   = str2jo("ins/jo");
      JO_INS_STRING = str2jo("ins/string");
      JO_INS_BYTE = str2jo("ins/byte");
      JO_INS_BARE_JOJO = str2jo("ins/bare-jojo");
      JO_INS_ADDRESS = str2jo("ins/address");

      JO_INS_JUMP = str2jo("ins/jump");
      JO_INS_JUMP_IF_FALSE = str2jo("ins/jump-if-false");

      JO_INS_TAIL_CALL = str2jo("ins/tail-call");
      JO_INS_LOOP = str2jo("ins/loop");
      JO_INS_RECUR = str2jo("ins/recur");

      JO_NULL     = str2jo("null");
      JO_THEN     = str2jo("then");
      JO_ELSE     = str2jo("else");

      JO_APPLY     = str2jo("apply");
      JO_END       = str2jo("end");

      JO_LOCAL_DATA_IN = str2jo("local-data-in");
      JO_LOCAL_DATA_OUT = str2jo("local-data-out");

      JO_LOCAL_TAG_IN = str2jo("local-tag-in");
      JO_LOCAL_TAG_OUT = str2jo("local-tag-out");

      JO_LOCAL_IN = str2jo("local-in");
      JO_LOCAL_OUT = str2jo("local-out");
    }
    #+end_src

*** init_stacks

    #+begin_src c
    jo jojo_area[1024 * 1024];

    init_stacks() {
      data_stack                   = new_stack("data_stack");
      return_stack                 = new_stack("return_stack");
      compiling_stack              = new_stack("compiling_stack");
      reading_stack                = new_stack("reading_stack");
      writing_stack                = new_stack("writing_stack");
      binding_filter_stack         = new_stack("binding_filter_stack");
      keyword_stack                = new_stack("keyword_stack");
      jo_filter_stack              = new_stack("jo_filter_stack");
      current_compiling_jojo_stack = new_stack("current_compiling_jojo_stack");

      push(compiling_stack, jojo_area);
      push(reading_stack, input_stack_terminal());
      push(writing_stack, output_stack_terminal());
      push(jo_filter_stack, str2jo("alias-filter"));
    }
    #+end_src

*** init_jojo

    #+begin_src c
    init_jojo() {
      init_jotable();
      init_literal_jo();
      init_stacks();
      init_kernel_signal_handler();

      expose_name();
      expose_apply();
      expose_stack_operation();
      expose_ending();
      expose_bool();
      expose_int();
      expose_memory();
      expose_byte();
      expose_jo();
      expose_string();
      expose_file();
      expose_keyword();
      expose_system();
      expose_cffi();
      expose_top_level();
      expose_mise();

      expose_play();
    }
    #+end_src

*** init_core

    #+begin_src c
    #include "core/0.0.1/core.h"

    init_core() {
      input_stack input_stack = input_stack_string(core_0_0_1_core_jo);
      push(reading_stack, input_stack);
      p_repl();
      drop(reading_stack);
      input_stack_free(input_stack);
    }
    #+end_src

* main

  #+begin_src c
  int main(int argc, char** argv) {
    cmd_number = argc;
    cmd_string_array = argv;
    init_system();
    init_jojo();
    init_core();
    init_play();
    return p_repl();
  }
  #+end_src
