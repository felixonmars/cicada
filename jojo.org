#+property: tangle jojo.c
#+title:  jojo
- add current size to size of super class
- inherit gc_type form super class
* [todo-stack]

  - gc uses malloc and free
    gc free things during sweep

  - new syntax design

  - single inheritance
    all function as multiple dispatching generic function
    - we can do this, if we assume all function have fixed number of arguments

  - :name for local var
    and (> :name) to set them

  - about gc
    - note about gc
    - move gc to c code
    - gc for string
      and all kinks of data
    - fix the roots of gc
    - re-test the gc

  - low-level syntax macro
    [at reader level]

  - c-like struct
    - by c struct, stack in c is easy.
      the c-like syntax we designed for jojo
      also shall let us implement stack in jojo easily.

* [todo-list]

  - trace and untrace a jo

  - delimited continuation
    to control return_stack [and object_stack]

  - concurrent
    use list to implement return_stack and object_stack in jojo
    thus each group of stacks is a light weight process

  - fix print_return_point
    - we need to add some overhead to local variable
      maybe I will add this,
      when I really need to print local variable with tag.

* [maybe]

  - make BLOCK_SIZE local to object

* [note]

*** data, atom, object

    data := atom | object
    atom := int | string | ...

    - object can not inherit atom

    - from tag of data
      we must be able to know is it a atom or an object

*** gc

    - an object_record
      every object is a pointer to object_record
      object_record_entry :
      | mark |
      | tag  |
      | data |

* [note] old

*** interface convention

    - before trying to get something from somewhere,
      first ask if it is there at all.

    - this convention can only be used
      when condition race will not occur,
      or when condition race is not important.

*** important common sense

    - all programs are changings of state of machine

    - syntax-checker, type-checker, compiler are all special interpreters

*** threaded code interpreter

    - types of threaded code interpreter :
      1. indirect threaded code
      2. direct threaded code
      3. token threaded code
      4. subroutine threaded code
      5. dynamic threaded code
         [jotable] [symbol-hash-table [of lisp]]

    - overhead of eval
      base_pointer test [to be able to return to c function]
      step_flag test

    - overhead of jo_apply
      dispatching [dynamic threaded code]

*** possible static type system

    - type comment in jojo and c code :
      1. change of object_stack -- [...] -> [...]
      2. other effect -- {}
         which can occur in any position in a type comment

    - the type comment in the code suggest a static type system.

      a static type system
      and a compiled verison of jojo
      might be implemented,

      but an untyped and a dynamic typed level are also important.

*** levels of languages

    1. untyped -- ffi to c [thus as low as c]
    2. dynamic typed -- debug and test
    3. static typed
    4. logic
    5. concurrent
    6. dependent type -- type as proof
    7. algebraic topology and combinatorial topology

*** apply and scope

    - apply will create new scope of local names.

    - thus
      p_compile_jojo will create new scope of local names.

    - by the following we can add pre-setted name to a scope :
      current-local-pointer swap
      (< data) (< tag) (jo self) local-in
      apply-with-local-pointer

    - but we can not use old names in the scope outside this scope.

*** limits

    | name                 | length      | unit          |
    |----------------------+-------------+---------------|
    | jojo_area            | 1024 * 1024 | jo            |
    | jotable              | 97 * 1024   | jotable_entry |
    | name_record          | 16 * 1024   | jo            |
    |----------------------+-------------+---------------|
    | object_stack         |             | cell          |
    | return_stack         |             | return_point  |
    | local_record         | 4 * 1024    | local_point   |
    | alias_record         | 1024        | alias_point   |
    |----------------------+-------------+---------------|
    | compiling_stack      |             | jo*           |
    | binding_filter_stack |             | jo            |
    | jo_filter_stack      |             | jo            |
    | keyword_stack        |             | alias_pointer |
    | reading_stack        |             | input_stack   |
    | writing_stack        |             | output_stack  |

*** minimalism

    - to keep the core minimal,
      I only implement the features needed to load other modules.

*** input_stack & output_stack

    - input_stack  push from high address to low address
      pop  -- read
      push -- unread

    - output_stack push from low address to high address
      push -- write
      pop  -- unwrite

* header

  #+begin_src c
  #include <sys/types.h>
  #include <sys/stat.h>
  #include <unistd.h>
  #include <stdio.h>
  #include <stdlib.h>
  #include <errno.h>
  #include <string.h>
  #include <fcntl.h>
  #include <ctype.h>
  #include <stdint.h>
  #include <dlfcn.h>
  #include <dirent.h>
  #include <signal.h>
  #include <limits.h>
  #include <stdarg.h>
  #+end_src

* type

  #+begin_src c
  typedef enum { false, true } bool;
  // typedef intptr_t cell;
  typedef intmax_t cell;
  typedef uint8_t byte;
  typedef void (* primitive)();
  #+end_src

* utility

*** int

    #+begin_src c
    cell max(cell a, cell b) {
      if (a < b) {
        return b;
      }
      else {
        return a;
      }
    }

    cell min(cell a, cell b) {
      if (a > b) {
        return b;
      }
      else {
        return a;
      }
    }

    cell power(cell a, cell n) {
      cell result = 1;
      while (n >= 1) {
        result = result * a;
        n--;
      }
      return result;
    }
    #+end_src

*** char

    #+begin_src c
    bool isbarcket(char c) {
      return (c == '(' ||
              c == ')' ||
              c == '[' ||
              c == ']' ||
              c == '{' ||
              c == '}' ||
              c == '"');
    }
    #+end_src

*** char_to_nat

    #+begin_src c
    cell char_to_nat(char c) {
      if (c >= '0' && c <= '9') {
        return (c - '0');
      }
      else if (c >= 'A' && c <= 'Z') {
        return (c - 'A') + 10;
      }
      else if (c >= 'a' && c <= 'z') {
        return (c - 'a') + 10;
      }
      else {
        return 0;
      }
    }
    #+end_src

*** string

***** string_equal

      #+begin_src c
      bool string_equal(char* s1, char* s2) {
        if (strcmp(s1, s2) == 0) {
          return true;
        }
        else {
          return false;
        }
      }
      #+end_src

***** nat_string_p

      #+begin_src c
      bool nat_string_p(char* str) {
        cell i = 0;
        while (str[i] != 0) {
          if (!isdigit(str[i])) {
            return false;
            }
          i++;
        }
        return true;
      }
      #+end_src

***** int_string_p

      #+begin_src c
      bool int_string_p(char* str) {
        if (str[0] == '-' ||
            str[0] == '+') {
          return nat_string_p(str + 1);
        }
        else {
          return nat_string_p(str);
        }
      }
      #+end_src

***** string_to_based_nat & string_to_based_int & string_to_int

      #+begin_src c
      cell string_to_based_nat(char* str, cell base) {
        cell result = 0;
        cell len = strlen(str);
        cell i = 0;
        while (i < len) {
          result = result + (char_to_nat(str[i]) * power(base, (len - i - 1)));
          i++;
        }
        return result;
      }

      cell string_to_based_int(char* str, cell base) {
        if (str[0] == '-') {
          return - string_to_based_nat(str, base);
        }
        else {
          return string_to_based_nat(str, base);
        }
      }

      cell string_to_int(char* str) { return string_to_based_int(str, 10); }
      #+end_src

*** error

    #+begin_src c
    report(char* format, ...) {
      va_list arg_list;
      va_start(arg_list, format);
      vdprintf(STDERR_FILENO, format, arg_list);
      va_end(arg_list);
    }
    #+end_src

*** literal array of string

    #+begin_src c
    #define S0 (char*[]){NULL}
    #define S1(x1) (char*[]){x1, NULL}
    #define S2(x1, x2) (char*[]){x1, x2, NULL}
    #define S3(x1, x2, x3) (char*[]){x1, x2, x3, NULL}
    #define S4(x1, x2, x3, x4) (char*[]){x1, x2, x3, x4, NULL}
    #define S5(x1, x2, x3, x4, x5) (char*[]){x1, x2, x3, x4, x5, NULL}
    #define S6(x1, x2, x3, x4, x5, x6) (char*[]){x1, x2, x3, x4, x5, x6, NULL}
    #define S7(x1, x2, x3, x4, x5, x6, x7) (char*[]){x1, x2, x3, x4, x5, x6, x7, NULL}
    #define S8(x1, x2, x3, x4, x5, x6, x7, x8) (char*[]){x1, x2, x3, x4, x5, x6, x7, x8, NULL}
    #define S9(x1, x2, x3, x4, x5, x6, x7, x8, x9) (char*[]){x1, x2, x3, x4, x5, x6, x7, x8, x9, NULL}
    #+end_src

* debug

  #+begin_src c
  p_debug() {
  }
  #+end_src

* jotable

*** type

    #+begin_src c
    typedef struct _jotable_entry {
      char *key;
      struct _jotable_entry *tag;
      cell data;
    } jotable_entry;

    typedef jotable_entry *jo;

    // prime table size
    //   1000003   about 976 k
    //   1000033
    //   1000333
    //   100003    about 97 k
    //   100333
    //   997
    #define jotable_size 100003
    jotable_entry jotable[jotable_size];

    // thus (jotable + index) is jo
    #+end_src

*** used_jo_p

    #+begin_src c
    bool used_jo_p(jo jo) {
      return jo->tag != 0;
    }
    #+end_src

*** string_to_sum

    #+begin_src c
    cell string_to_sum(char* str) {
      cell sum = 0;
      cell max_step = 10;
      cell i = 0;
      while (i < strlen(str)) {
        sum = sum + ((byte) str[i]) * (2 << min(i, max_step));
        i++;
      }
      return sum;
    }
    #+end_src

*** jotable_hash

    #+begin_src c
    // a hash an index into jotable
    cell jotable_hash(cell sum, cell counter) {
      return (counter + sum) % jotable_size;
    }
    #+end_src

*** jotable_insert

    #+begin_src c
    p_debug();

    jo jotable_insert(char* key) {
      // in C : [string] -> [jo]
      cell sum = string_to_sum(key);
      cell counter = 0;
      while (true) {
        cell index = jotable_hash(sum, counter);
        jo jo = (jotable + index);
        if (jo->key == 0) {
          key = strdup(key);
          jo->key = key;
          return jo;
        }
        else if (string_equal(key, jo->key)) {
          return jo;
        }
        else if (counter == jotable_size) {
          report("- jotable_insert fail\n");
          report("  the hash_table is filled\n");
          p_debug();
          return NULL;
        }
        else {
          counter++;
        }
      }
    }
    #+end_src

*** str2jo

    #+begin_src c
    jo str2jo(char* str) {
      return jotable_insert(str);
    }
    #+end_src

*** jo2str

    #+begin_src c
    char* jo2str(jo jo) {
      return jo->key;
    }
    #+end_src

*** literal jo

    #+begin_src c
    jo EMPTY_JO;
    jo TAG_PRIM;
    jo TAG_JOJO;
    jo TAG_PRIM_KEYWORD;
    jo TAG_KEYWORD;
    jo TAG_DATA;

    jo JO_DECLARED;

    jo ROUND_BAR;
    jo ROUND_KET;
    jo SQUARE_BAR;
    jo SQUARE_KET;
    jo FLOWER_BAR;
    jo FLOWER_KET;
    jo DOUBLE_QUOTE;

    jo JO_INS_INT;
    jo JO_INS_JO;
    jo JO_INS_STRING;
    jo JO_INS_BYTE;
    jo JO_INS_BARE_JOJO;
    jo JO_INS_ADDRESS;

    jo JO_INS_JUMP;
    jo JO_INS_JUMP_IF_FALSE;

    jo JO_INS_TAIL_CALL;
    jo JO_INS_LOOP;
    jo JO_INS_RECUR;

    jo JO_NULL;
    jo JO_THEN;
    jo JO_ELSE;

    jo JO_APPLY;
    jo JO_END;

    jo JO_LOCAL_DATA_IN;
    jo JO_LOCAL_DATA_OUT;

    jo JO_LOCAL_TAG_IN;
    jo JO_LOCAL_TAG_OUT;

    jo JO_LOCAL_IN;
    jo JO_LOCAL_OUT;
    #+end_src

* stack

*** stack_link

    #+begin_src c
    typedef struct _stack_link__t {
      cell* stack;
      struct _stack_link__t* link;
    } stack_link__t;
    typedef stack_link__t* stack_link;
    #+end_src

*** stack

    #+begin_src c
    typedef struct {
      char* name;
      cell pointer;
      cell* stack;
      stack_link link;
    } stack__t;
    typedef stack__t* stack;

    #define STACK_BLOCK_SIZE 1024
    // #define STACK_BLOCK_SIZE 1 // for test
    #+end_src

*** new_stack

    #+begin_src c
    stack new_stack(char* name) {
      stack stack = (stack__t*)malloc(sizeof(stack__t));
      stack->name = name;
      stack->pointer = 0;
      stack->stack = (cell*)malloc(sizeof(cell) * STACK_BLOCK_SIZE);
      stack->link = NULL;
      return stack;
    }
    #+end_src

*** stack_free

    #+begin_src c
    stack_free_link(stack_link link) {
      if (link == NULL) {
        return;
      }
      else {
        stack_free_link(link->link);
        free(link->stack);
        free(link);
      }
    }

    // ><><><
    // stack->name is not freed
    stack_free(stack stack) {
      stack_free_link(stack->link);
      free(stack->stack);
      free(stack);
    }
    #+end_src

*** stack_block_underflow_check

    #+begin_src c
    // can not pop
    // for stack->pointer can not decrease under 0
    stack_block_underflow_check(stack stack) {
      if (stack->pointer > 0) {
        return;
      }
      else if (stack->link != NULL) {
        free(stack->stack);
        stack->stack = stack->link->stack;
        stack_link old_link = stack->link;
        stack->link = stack->link->link;
        free(old_link);
        stack->pointer = STACK_BLOCK_SIZE;
        return;
      }
      else {
        report("- stack_block_underflow_check fail\n");
        report("  %s underflow\n", stack->name);
        p_debug();
      }
    }
    #+end_src

*** stack_block_overflow_check

    #+begin_src c
    // can not push
    // for stack->pointer can not increase over STACK_BLOCK_SIZE
    stack_block_overflow_check(stack stack) {
      if (stack->pointer < STACK_BLOCK_SIZE) {
        return;
      }
      else {
        stack_link new_link = (stack_link__t*)malloc(sizeof(stack_link__t));
        new_link->stack = stack->stack;
        new_link->link = stack->link;
        stack->link = new_link;
        stack->stack = (cell*)malloc(sizeof(cell) * STACK_BLOCK_SIZE);
        stack->pointer = 0;
      }
    }
    #+end_src

*** stack_empty_p

    #+begin_src c
    bool stack_empty_p(stack stack) {
      return
        stack->pointer == 0 &&
        stack->link == NULL;
    }
    #+end_src

*** stack_length

    #+begin_src c
    cell stack_length_link(cell sum, stack_link link) {
      if (link == NULL) {
        return sum;
      }
      else {
        return stack_length_link(sum + STACK_BLOCK_SIZE, link->link);
      }
    }

    cell stack_length(stack stack) {
      return stack_length_link(stack->pointer, stack->link);
    }
    #+end_src

*** pop

    #+begin_src c
    cell pop(stack stack) {
      stack_block_underflow_check(stack);
      stack->pointer--;
      return stack->stack[stack->pointer];
    }
    #+end_src

*** tos

    #+begin_src c
    cell tos(stack stack) {
      stack_block_underflow_check(stack);
      return stack->stack[stack->pointer - 1];
    }
    #+end_src

*** drop

    #+begin_src c
    drop(stack stack) {
      stack_block_underflow_check(stack);
      stack->pointer--;
    }
    #+end_src

*** push

    #+begin_src c
    push(stack stack, cell data) {
      stack_block_overflow_check(stack);
      stack->stack[stack->pointer] = data;
      stack->pointer++;
    }
    #+end_src

*** stack_peek

    #+begin_src c
    cell stack_peek_link(stack_link link, cell index) {
      if (index < STACK_BLOCK_SIZE) {
        return link->stack[STACK_BLOCK_SIZE - index];
      }
      else {
        return stack_peek_link(link->link, index - STACK_BLOCK_SIZE);
      }
    }

    cell stack_peek(stack stack, cell index) {
      if (index < stack->pointer) {
        return stack->stack[stack->pointer - index];
      }
      else {
        return stack_peek_link(stack->link, index - stack->pointer);
      }
    }
    #+end_src

*** stack_traverse_from_top

    #+begin_src c
    stack_traverse_from_top_help
    (cell cursor,
     cell* stack,
     stack_link link,
     void fun(cell)) {
      while (cursor > 0) {
        fun(stack[cursor - 1]);
        cursor--;
      }
      if (link != NULL) {
        stack_traverse_from_top_help
          (STACK_BLOCK_SIZE,
           link->stack,
           link->link,
           fun);
      }
    }

    stack_traverse_from_top(stack stack, void fun(cell)) {
      stack_traverse_from_top_help
        (stack->pointer,
         stack->stack,
         stack->link,
         fun);
    }
    #+end_src

*** stack_traverse_from_bottom

    #+begin_src c
    stack_traverse_from_bottom_help
    (cell cursor,
     cell* stack,
     stack_link link,
     void fun(cell)) {
      if (link != NULL) {
        stack_traverse_from_bottom_help
          (STACK_BLOCK_SIZE,
           link->stack,
           link->link,
           fun);
      }
      cell i = 0;
      while (i < cursor) {
        fun(stack[i]);
        i++;
      }
    }

    stack_traverse_from_bottom(stack stack, void fun(cell)) {
      stack_traverse_from_bottom_help
        (stack->pointer,
         stack->stack,
         stack->link,
         fun);
    }
    #+end_src

* input_stack

*** [note]

    - free input_stack will not close the file.

*** input_stack_type

    #+begin_src c
    typedef enum {
      INPUT_STACK_REGULAR_FILE,
      INPUT_STACK_STRING,
      INPUT_STACK_TERMINAL,
    } input_stack_type;
    #+end_src

*** input_stack_link

    #+begin_src c
    typedef struct _input_stack_link__t {
      byte* stack;
      cell end_pointer;
      struct _input_stack_link__t* link;
    } input_stack_link__t;
    typedef input_stack_link__t* input_stack_link;
    #+end_src

*** input_stack

    #+begin_src c
    typedef struct {
      cell pointer;
      cell end_pointer;
      byte* stack;
      input_stack_link link;
      input_stack_type type;
      union {
        int   file;
        char* string;
        // int   terminal;
      };
      cell string_pointer;
    } input_stack__t;
    typedef input_stack__t* input_stack;

    // #define INPUT_STACK_BLOCK_SIZE (4 * 1024)
    #define INPUT_STACK_BLOCK_SIZE 1 // for test
    #+end_src

*** input_stack_new

    #+begin_src c
    input_stack input_stack_new(input_stack_type input_stack_type) {
      input_stack input_stack =
        (input_stack__t*)malloc(sizeof(input_stack__t));
      input_stack->pointer = INPUT_STACK_BLOCK_SIZE;
      input_stack->end_pointer = INPUT_STACK_BLOCK_SIZE;
      input_stack->stack = (byte*)malloc(INPUT_STACK_BLOCK_SIZE);
      input_stack->link = NULL;
      input_stack->type = input_stack_type;
      return input_stack;
    }
    #+end_src

*** input_stack_file

    #+begin_src c
    input_stack input_stack_file(int file) {
      int file_flag = fcntl(file, F_GETFL);
      int access_mode = file_flag & O_ACCMODE;
      if (file_flag == -1) {
        report("- input_stack_file fail\n");
        perror("  fcntl error ");
        p_debug();
      }
      input_stack input_stack = input_stack_new(INPUT_STACK_REGULAR_FILE);
      input_stack->file = file;
      return input_stack;
    }
    #+end_src

*** input_stack_string

    #+begin_src c
    input_stack input_stack_string(char* string) {
      input_stack input_stack = input_stack_new(INPUT_STACK_STRING);
      input_stack->string = string;
      input_stack->string_pointer = 0;
      return input_stack;
    }
    #+end_src

*** input_stack_terminal

    #+begin_src c
    input_stack input_stack_terminal() {
      input_stack input_stack = input_stack_new(INPUT_STACK_TERMINAL);
      return input_stack;
    }
    #+end_src

*** input_stack_free

    #+begin_src c
    input_stack_free_link(input_stack_link link) {
      if (link == NULL) {
        return;
      }
      else {
        input_stack_free_link(link->link);
        free(link->stack);
        free(link);
      }
    }

    input_stack_free(input_stack input_stack) {
      input_stack_free_link(input_stack->link);
      free(input_stack->stack);
      free(input_stack);
    }
    #+end_src

*** input_stack_block_underflow_check

    #+begin_src c
    // can not pop
    // for input_stack->pointer can not increase over input_stack->end_pointer
    input_stack_block_underflow_check(input_stack input_stack) {
      if (input_stack->pointer < input_stack->end_pointer) {
        return;
      }

      else if (input_stack->link != NULL) {
        free(input_stack->stack);
        input_stack->stack = input_stack->link->stack;
        input_stack->end_pointer = input_stack->link->end_pointer;
        input_stack_link old_link = input_stack->link;
        input_stack->link = input_stack->link->link;
        free(old_link);
        input_stack->pointer = 0;
        return;
      }

      else if (input_stack->type == INPUT_STACK_REGULAR_FILE) {
        ssize_t real_bytes = read(input_stack->file,
                                  input_stack->stack,
                                  INPUT_STACK_BLOCK_SIZE);
        if (real_bytes == 0) {
          report("- input_stack_block_underflow_check fail\n");
          report("  input_stack underflow\n");
          report("  meet end-of-file when reading a regular_file\n");
          report("  file descriptor : %ld\n", input_stack->file);
          p_debug();
        }
        else {
          input_stack->pointer = 0;
          input_stack->end_pointer = real_bytes;
          return;
        }
      }

      else if (input_stack->type == INPUT_STACK_STRING) {
        byte byte = input_stack->string[input_stack->string_pointer];
        if (byte == '\0') {
          report("- input_stack_block_underflow_check fail\n");
          report("  input_stack underflow\n");
          report("  meet end-of-string when reading a string\n");
          p_debug();
        }
        input_stack->string_pointer++;
        input_stack->end_pointer = INPUT_STACK_BLOCK_SIZE;
        input_stack->pointer = INPUT_STACK_BLOCK_SIZE - 1;
        input_stack->stack[input_stack->pointer] = byte;
        return;
      }

      else if (input_stack->type == INPUT_STACK_TERMINAL) {
        ssize_t real_bytes = read(STDIN_FILENO,
                                  input_stack->stack,
                                  INPUT_STACK_BLOCK_SIZE);
        if (real_bytes == 0) {
          report("- input_stack_block_underflow_check fail\n");
          report("  input_stack underflow\n");
          report("  meet end-of-file when reading from terminal\n");
          p_debug();
        }
        else {
          input_stack->pointer = 0;
          input_stack->end_pointer = real_bytes;
          return;
        }
      }

      else {
        report("- input_stack_block_underflow_check fail\n");
        report("  meet unknow stack type\n");
        report("  stack type number : %ld\n", input_stack->type);
        p_debug();
      }
    }
    #+end_src

*** input_stack_block_overflow_check

    #+begin_src c
    // can not push
    // for input_stack->pointer can not decrease under 0
    input_stack_block_overflow_check(input_stack input_stack) {
      if (input_stack->pointer > 0) {
        return;
      }
      else {
        input_stack_link new_link =
          (input_stack_link__t*)malloc(sizeof(input_stack_link__t));
        new_link->stack = input_stack->stack;
        new_link->link = input_stack->link;
        new_link->end_pointer = input_stack->end_pointer;
        input_stack->link = new_link;
        input_stack->stack = (byte*)malloc(INPUT_STACK_BLOCK_SIZE);
        input_stack->pointer = INPUT_STACK_BLOCK_SIZE;
        input_stack->end_pointer = INPUT_STACK_BLOCK_SIZE;
      }
    }
    #+end_src

*** input_stack_empty_p

    - note the semantic of 'input_stack_empty_p'.

      when one asks 'input_stack_empty_p',
      there is already one byte readed into the input_stack.

    #+begin_src c
    bool input_stack_empty_p(input_stack input_stack) {
      if (input_stack->pointer != input_stack->end_pointer ||
          input_stack->link != NULL) {
        return false;
      }
      if (input_stack->type == INPUT_STACK_REGULAR_FILE) {
        ssize_t real_bytes = read(input_stack->file,
                                  input_stack->stack,
                                  INPUT_STACK_BLOCK_SIZE);
        if (real_bytes == 0) {
          return true;
        }
        else {
          input_stack->pointer = 0;
          input_stack->end_pointer = real_bytes;
          return false;
        }
      }
      else if (input_stack->type == INPUT_STACK_STRING) {
        return input_stack->string[input_stack->string_pointer] == '\0';
      }
      else if (input_stack->type == INPUT_STACK_TERMINAL) {
        ssize_t real_bytes = read(STDIN_FILENO,
                                  input_stack->stack,
                                  INPUT_STACK_BLOCK_SIZE);
        if (real_bytes == 0) {
          return true;
        }
        else {
          input_stack->pointer = 0;
          input_stack->end_pointer = real_bytes;
          return false;
        }
      }
      else {
        report("- input_stack_empty_p meet unknow stack type\n");
        report("  stack type number : %ld\n", input_stack->type);
        p_debug();
      }
    }
    #+end_src

*** input_stack_pop

    #+begin_src c
    byte input_stack_pop(input_stack input_stack) {
      input_stack_block_underflow_check(input_stack);
      byte byte = input_stack->stack[input_stack->pointer];
      input_stack->pointer++;
      return byte;
    }
    #+end_src

*** input_stack_tos

    #+begin_src c
    byte input_stack_tos(input_stack input_stack) {
      input_stack_block_underflow_check(input_stack);
      byte byte = input_stack->stack[input_stack->pointer];
      return byte;
    }
    #+end_src

*** input_stack_drop

    #+begin_src c
    input_stack_drop(input_stack input_stack) {
      input_stack_block_underflow_check(input_stack);
      input_stack->pointer++;
    }
    #+end_src

*** input_stack_push

    #+begin_src c
    input_stack_push(input_stack input_stack, byte byte) {
      input_stack_block_overflow_check(input_stack);
      input_stack->pointer--;
      input_stack->stack[input_stack->pointer] = byte;
    }
    #+end_src

* output_stack

*** [note]

    - I will not seek the real file during pop and push.
      and no undo for the terminal.

    - output to
      1. file     -- the aim is to flush bytes to file
      2. string   -- the aim is to collect bytes to string
      3. terminal -- byte are directly printed to the terminal

    - flush to file or collect to string
      will not free the output_stack.

    - free output_stack will not close the file.

*** output_stack_type

    #+begin_src c
    typedef enum {
      OUTPUT_STACK_REGULAR_FILE,
      OUTPUT_STACK_STRING,
      OUTPUT_STACK_TERMINAL,
    } output_stack_type;
    #+end_src

*** output_stack_link

    #+begin_src c
    typedef struct _output_stack_link__t {
      byte* stack;
      struct _output_stack_link__t* link;
    } output_stack_link__t;
    typedef output_stack_link__t* output_stack_link;
    #+end_src

*** output_stack

    #+begin_src c
    typedef struct {
      cell pointer;
      byte* stack;
      output_stack_link link;
      output_stack_type type;
      union {
        int   file; // with cache
        // char* string;
        //   generate string
        //   instead of output to pre-allocated buffer
        // int   terminal; // no cache
      };
      cell string_pointer;
    } output_stack__t;
    typedef output_stack__t* output_stack;

    // #define OUTPUT_STACK_BLOCK_SIZE (4 * 1024)
    #define OUTPUT_STACK_BLOCK_SIZE 1 // for test
    #+end_src

*** output_stack_new

    #+begin_src c
    output_stack output_stack_new(output_stack_type output_stack_type) {
      output_stack output_stack =
        (output_stack__t*)malloc(sizeof(output_stack__t));
      output_stack->pointer = 0;
      output_stack->stack = (byte*)malloc(OUTPUT_STACK_BLOCK_SIZE);
      output_stack->link = NULL;
      output_stack->type = output_stack_type;
      return output_stack;
    }
    #+end_src

*** output_stack_file

    #+begin_src c
    output_stack output_stack_file(int file) {
      int file_flag = fcntl(file, F_GETFL);
      int access_mode = file_flag & O_ACCMODE;
      if (file_flag == -1) {
        report("- output_stack_file fail\n");
        perror("  fcntl error ");
        p_debug();
      }
      else if (access_mode == O_WRONLY || access_mode == O_RDWR) {
        output_stack output_stack = output_stack_new(OUTPUT_STACK_REGULAR_FILE);
        output_stack->file = file;
        return output_stack;
      }
      else {
        report("- output_stack_file fail\n");
        report("  output_stack_file fail\n");
        p_debug();
      }
    }
    #+end_src

*** output_stack_string

    #+begin_src c
    output_stack output_stack_string() {
      output_stack output_stack = output_stack_new(OUTPUT_STACK_STRING);
      return output_stack;
    }
    #+end_src

*** output_stack_terminal

    #+begin_src c
    output_stack output_stack_terminal() {
      output_stack output_stack = output_stack_new(OUTPUT_STACK_TERMINAL);
      return output_stack;
    }
    #+end_src

*** output_stack_free

    #+begin_src c
    output_stack_free_link(output_stack_link link) {
      if (link == NULL) {
        return;
      }
      else {
        output_stack_free_link(link->link);
        free(link->stack);
        free(link);
      }
    }

    output_stack_free(output_stack output_stack) {
      output_stack_free_link(output_stack->link);
      free(output_stack->stack);
      free(output_stack);
    }
    #+end_src

*** output_stack_file_flush

    #+begin_src c
    output_stack_file_flush_link(int file, output_stack_link link) {
      if (link == NULL) {
        return;
      }
      else {
        output_stack_file_flush_link(file, link->link);
        ssize_t real_bytes = write(file,
                                   link->stack,
                                   OUTPUT_STACK_BLOCK_SIZE);
        if (real_bytes != OUTPUT_STACK_BLOCK_SIZE) {
          report("- output_stack_file_flush_link fail\n");
          report("  file descriptor : %ld\n", file);
          perror("  write error : ");
          p_debug();
        }
      }
    }

    output_stack_file_flush(output_stack output_stack) {
      output_stack_file_flush_link(output_stack->file,
                                   output_stack->link);
      ssize_t real_bytes = write(output_stack->file,
                                 output_stack->stack,
                                 output_stack->pointer);
      if (real_bytes != output_stack->pointer) {
        report("- output_stack_file_flush fail\n");
        report("  file descriptor : %ld\n", output_stack->file);
        perror("  write error : ");
        p_debug();
      }
      else {
        output_stack_free_link(output_stack->link);
        output_stack->link = NULL;
        output_stack->pointer = 0;
      }
    }
    #+end_src

*** output_stack_string_collect

    #+begin_src c
    cell output_stack_string_length_link(cell sum, output_stack_link link) {
      if (link == NULL) {
        return sum;
      }
      else {
        return
          OUTPUT_STACK_BLOCK_SIZE +
          output_stack_string_length_link(sum, link->link);
      }
    }

    cell output_stack_string_length(output_stack output_stack) {
      cell sum = strlen(output_stack->stack);
      return output_stack_string_length_link(sum, output_stack->link);
    }


    byte* output_stack_string_collect_link(byte* buffer, output_stack_link link) {
      if (link == NULL) {
        return buffer;
      }
      else {
        buffer = output_stack_string_collect_link(buffer, link->link);
        memcpy(buffer, link->stack, OUTPUT_STACK_BLOCK_SIZE);
        return buffer + OUTPUT_STACK_BLOCK_SIZE;
      }
    }

    char* output_stack_string_collect(output_stack output_stack) {
      byte* string = (byte*)malloc(1 + output_stack_string_length(output_stack));
      byte* buffer = string;
      buffer = output_stack_string_collect_link(buffer, output_stack->link);
      memcpy(buffer, output_stack->stack, output_stack->pointer);
      buffer[output_stack->pointer] = '\0';
      return string;
    }
    #+end_src

*** output_stack_block_underflow_check

    #+begin_src c
    // can not pop
    // for output_stack->pointer can not decrease under 0
    output_stack_block_underflow_check(output_stack output_stack) {
      if (output_stack->pointer > 0) {
        return;
      }

      else if (output_stack->link != NULL) {
        free(output_stack->stack);
        output_stack->stack = output_stack->link->stack;
        output_stack_link old_link = output_stack->link;
        output_stack->link = output_stack->link->link;
        free(old_link);
        output_stack->pointer = OUTPUT_STACK_BLOCK_SIZE;
        return;
      }

      else if (output_stack->type == OUTPUT_STACK_REGULAR_FILE) {
        report("- output_stack_block_underflow_check fail\n");
        report("  output_stack underflow\n");
        report("  when writing a regular_file\n");
        report("  file descriptor : %ld\n", output_stack->file);
        p_debug();
      }

      else if (output_stack->type == OUTPUT_STACK_STRING) {
        report("- output_stack_block_underflow_check fail\n");
        report("  output_stack underflow\n");
        report("  when writing a string\n");
        p_debug();
      }

      else if (output_stack->type == OUTPUT_STACK_TERMINAL) {
        report("- output_stack_block_underflow_check fail\n");
        report("  output_stack underflow\n");
        report("  when writing to terminal\n");
        p_debug();
      }

      else {
        report("- output_stack_block_underflow_check fail\n");
        report("  meet unknow stack type\n");
        report("  stack type number : %ld\n", output_stack->type);
        p_debug();
      }
    }
    #+end_src

*** output_stack_block_overflow_check

    #+begin_src c
    // can not push
    // for output_stack->pointer can not increase over OUTPUT_STACK_BLOCK_SIZE
    output_stack_block_overflow_check(output_stack output_stack) {
      if (output_stack->pointer < OUTPUT_STACK_BLOCK_SIZE) {
        return;
      }
      else {
        output_stack_link new_link =
          (output_stack_link__t*)malloc(sizeof(output_stack_link__t));
        new_link->stack = output_stack->stack;
        new_link->link = output_stack->link;
        output_stack->link = new_link;
        output_stack->stack = (byte*)malloc(OUTPUT_STACK_BLOCK_SIZE);
        output_stack->pointer = 0;
      }
    }
    #+end_src

*** output_stack_empty_p

    #+begin_src c
    bool output_stack_empty_p(output_stack output_stack) {
      if (output_stack->pointer != 0 ||
          output_stack->link != NULL) {
        return false;
      }
      if (output_stack->type == OUTPUT_STACK_REGULAR_FILE) {
        return true;
      }
      else if (output_stack->type == OUTPUT_STACK_STRING) {
        return true;
      }
      else if (output_stack->type == OUTPUT_STACK_TERMINAL) {
        return true;
      }
      else {
        report("- output_stack_empty_p meet unknow stack type\n");
        report("  stack type number : %ld\n", output_stack->type);
        p_debug();
      }
    }
    #+end_src

*** output_stack_pop

    #+begin_src c
    byte output_stack_pop(output_stack output_stack) {
      output_stack_block_underflow_check(output_stack);
      output_stack->pointer--;
      return output_stack->stack[output_stack->pointer];
    }
    #+end_src

*** output_stack_tos

    #+begin_src c
    byte output_stack_tos(output_stack output_stack) {
      output_stack_block_underflow_check(output_stack);
      return output_stack->stack[output_stack->pointer - 1];
    }
    #+end_src

*** output_stack_drop

    #+begin_src c
    output_stack_drop(output_stack output_stack) {
      output_stack_block_underflow_check(output_stack);
      output_stack->pointer--;
    }
    #+end_src

*** output_stack_push

    #+begin_src c
    output_stack_push(output_stack output_stack, byte b) {
      if (output_stack->type == OUTPUT_STACK_TERMINAL) {
        byte buffer[1];
        buffer[0] = b;
        ssize_t real_bytes = write(STDOUT_FILENO, buffer, 1);
        if (real_bytes != 1) {
          report("- output_stack_push fail\n");
          perror("  write error : ");
          p_debug();
        }
      }
      else {
        output_stack_block_overflow_check(output_stack);
        output_stack->stack[output_stack->pointer] = b;
        output_stack->pointer++;
      }
    }
    #+end_src

* object_stack

*** object_stack

    #+begin_src c
    typedef struct {
      jo tag;
      cell data;
    } object_point;

    stack object_stack;

    object_point object_stack_pop() {
      object_point p;
      p.tag = pop(object_stack);
      p.data = pop(object_stack);
      return p;
    }

    object_point object_stack_tos() {
      object_point p;
      p.tag = pop(object_stack);
      p.data = pop(object_stack);
      push(object_stack, p.data);
      push(object_stack, p.tag);
      return p;
    }

    bool object_stack_empty_p() {
      return stack_empty_p(object_stack);
    }

    object_stack_push(jo tag, cell data) {
      push(object_stack, data);
      push(object_stack, tag);
    }

    jo object_stack_peek_tag(cell index) {
      return stack_peek(object_stack, (index*2) - 1);
    }

    cell object_stack_peek_data(cell index) {
      return stack_peek(object_stack, (index*2));
    }
    #+end_src

* return_stack

*** local

    #+begin_src c
    typedef struct {
      jo name;
      cell local_tag;
      cell local_data;
    } local_point;

    local_point local_record[4 * 1024];
    cell current_local_pointer = 0;
    #+end_src

*** return_stack

    #+begin_src c
    typedef struct {
      jo* jojo;
      cell local_pointer;
    } return_point;

    stack return_stack;

    return_point return_stack_pop() {
      return_point p;
      p.jojo = pop(return_stack);
      p.local_pointer = pop(return_stack);
      return p;
    }

    return_point return_stack_tos() {
      return_point p;
      p.jojo = pop(return_stack);
      p.local_pointer = pop(return_stack);
      push(return_stack, p.local_pointer);
      push(return_stack, p.jojo);
      return p;
    }

    bool return_stack_empty_p() {
      return stack_empty_p(return_stack);
    }

    return_stack_push(jo* jojo, cell local_pointer) {
      push(return_stack, local_pointer);
      push(return_stack, jojo);
    }

    return_stack_push_new(jo* jojo) {
      return_stack_push(jojo, current_local_pointer);
    }

    return_stack_inc() {
      jo* jojo = pop(return_stack);
      push(return_stack, jojo + 1);
    }
    #+end_src

* compiling_stack & here

*** compiling_stack

    - to redirect compiling location

    #+begin_src c
    stack compiling_stack; // of jojo

    p_compiling_stack_inc() {
      jo* jojo = pop(compiling_stack);
      push(compiling_stack, jojo + 1);
    }
    #+end_src

*** here

    #+begin_src c
    here(cell n) {
      jo* jojo = pop(compiling_stack);
      jojo[0] = n;
      push(compiling_stack, jojo + 1);
    }
    #+end_src

* class

*** [note]

    - use 'new' to create object.

    - use special functions to create atom.

*** class

    #+begin_src c
    typedef enum {
      GC_IGNORE,
      GC_CLEANER,
      GC_RECUR,
    } gc_type;
    // typedef void (* cleaner__t)(cell);

    typedef struct {
      jo class_name;
      jo super_name;
      gc_type gc_type;
      // cleaner__t cleaner;
      cell object_size;
    } class__t;
    typedef class__t* class;
    #+end_src

*** define_atom_class

    #+begin_src c
    define_atom_class(char* class_name,
                      char* super_name,
                      gc_type gc_type) {
      class class = (class__t*)malloc(sizeof(class__t));
      class->class_name = str2jo(class_name);
      class->super_name = str2jo(super_name);
      class->gc_type = gc_type;

      jo name = str2jo(class_name);
      name->tag = str2jo("<class>");
      name->data = class;
    }
    #+end_src

*** define_field

    #+begin_src c
    define_field(char* class_name, char* field, cell index) {
      char name_buffer[1024];
      jo name;
      strcpy(name_buffer+1, class_name);
      strcpy(name_buffer+1+strlen(class_name), field);

      name_buffer[0] = '.';
      name = str2jo(name_buffer);
      name->tag = ("<get-object-field>");
      name->data = index;

      name_buffer[0] = '!';
      name = str2jo(name_buffer);
      name->tag = ("<set-object-field>");
      name->data = index;
    }
    #+end_src

*** define_class

    #+begin_src c
    define_class(char* class_name,
                 char* super_name,
                 char* fields[]) {
      class class = (class__t*)malloc(sizeof(class__t));
      class->class_name = str2jo(class_name);
      class->super_name = str2jo(super_name);
      class->gc_type = GC_RECUR;

      cell i = 0;
      while (fields[i] != NULL) {
        define_field(class_name, fields[i], i);
        i++;
      }

      class->object_size = i;

      jo name = str2jo(class_name);
      name->tag = str2jo("<class>");
      name->data = class;
    }
    #+end_src

* object

*** object_record

    #+begin_src c
    typedef struct {
      cell mark;
      jo tag;
      cell pointer;
    } object_record_entry;

    object_record_entry object_record[1024 * 1024];
    #+end_src

*** mark_object_record

    #+begin_src c
    mark_object_record(jo tag, cell pointer) {

    }
    #+end_src

*** sweep_object_record

    #+begin_src c
    sweep_object_record() {

    }
    #+end_src

*** new

    #+begin_src c
    new(class class) {
      cell* data = (cell*)malloc(class->size*2*sizeof(cell));
      object_stack_push(class->class_name, data);
    }
    #+end_src

* function

*** check_function_arity

    #+begin_src c
    bool check_function_arity(char* function_name, cell arity) {
      jo name = str2jo(function_name);
      if (used_jo_p(name)) {
        return name->tag == str2jo("<generic-prototype>") && name->data == arity;
      }
      else {
        name->tag = str2jo("<generic-prototype>");
        name->data = arity;
        return true;
      }
    }
    #+end_src

*** define_prim

    #+begin_src c
    define_prim(char* function_name,
                char* tags[],
                primitive fun) {
      char name_buffer[1024];
      char* cursor = name_buffer;
      cell i = 0;
      while (tags[i] != NULL) {
        strcpy(cursor, tags[i]);
        cursor = cursor + strlen(tags[i]);
        i++;
      }
      strcpy(cursor, function_name);
      jo name = str2jo(name_buffer);
      cell arity = i;
      if (arity == 0) {
        name->tag = TAG_PRIM;
        name->data = fun;
      }
      else if (check_function_arity(function_name, arity)) {
        name->tag = TAG_PRIM;
        name->data = fun;
      }
      else {
        report("- define_primitive fall\n");
        report("  arity of %s should not be %ld\n", function_name, arity);
      }
    }
    #+end_src

* jo_apply & eval

*** [note]

    - be careful when calling jo_apply in primitive,
      because after push a jojo to return_stack,
      one need to exit current primitive to run the jojo.

      if wished follow a 'eval();' after jo_apply
      to return to the primitive function.

    - keyword_stack and alias_record
      form a hook for read_jo.

*** keyword_stack

    #+begin_src c
    stack keyword_stack; // of alias_pointer
    #+end_src

*** alias

    #+begin_src c
    typedef struct {
      jo nick;
      jo name;
    } alias_point;

    alias_point alias_record[1024];
    cell current_alias_pointer = 0;
    #+end_src

*** jo2real_jo

    #+begin_src c
    jo jo2real_jo(jo j) {
      cell arity = j->data;
      if (arity == 0) {
        return j;
      }
      char name_buffer[1024];
      char* cursor = name_buffer;
      cell i = arity;
      jo tag;
      while (i > 0) {
        tag = object_stack_peek_tag(i);
        strcpy(cursor, jo2str(tag));
        cursor = cursor + strlen(jo2str(tag));
        i--;
      }
      return str2jo(name_buffer);
    }
    #+end_src

*** object_tag

    #+begin_src c
    jo object_tag(cell* o, cell index) {
      return o[index*2];
    }
    #+end_src

*** object_data

    #+begin_src c
    jo object_data(cell* o, cell index) {
      return o[index*2+1];
    }
    #+end_src

*** generic_apply

    #+begin_src c
    generic_apply(jo jo) {
      jo = jo2real_jo(jo);
      cell tag = jo->tag;
      if (tag == TAG_PRIM) {
        primitive primitive = jo->data;
        primitive();
      }
      else if (tag == TAG_JOJO) {
        cell jojo = jo->data;
        return_stack_push_new(jojo);
      }
      else if (tag == TAG_PRIM_KEYWORD) {
        push(keyword_stack, current_alias_pointer);
        primitive primitive = jo->data;
        primitive();
        current_alias_pointer = pop(keyword_stack);
      }
      else if (tag == TAG_KEYWORD) {
        // keywords are always evaled
        push(keyword_stack, current_alias_pointer);
        cell jojo = jo->data;
        return_stack_push_new(jojo);
        eval();
        current_alias_pointer = pop(keyword_stack);
      }
      else if (tag == str2jo("<get-object-field>")) {
        cell index = jo->data;
        object_point p = object_stack_pop();
        object_stack_push(object_tag(p.data, index),
                          object_data(p.data, index));
      }
      else if (tag == str2jo("<set-object-field>")) {
        cell index = jo->data;
        //
      }
      else {
        report("- generic_apply meet unknown tag : %s\n", jo2str(tag));
      }
    }
    #+end_src

*** jo_apply

    #+begin_src c
    p_debug();

    jo_apply(jo jo) {
      if (!used_jo_p(jo)) {
        report("- jo_apply meet undefined jo : %s\n", jo2str(jo));
        p_debug();
        return;
      }
      if (jo->tag == str2jo("<generic-prototype>")) {
        generic_apply(jo);
      }
      else {
        push(object_stack, jo->data);
        push(object_stack, jo->tag);
      }
    }
    #+end_src

*** eval

    #+begin_src c
    eval() {
      cell base = return_stack->pointer;
      while (return_stack->pointer >= base) {
        return_point rp = return_stack_tos();
        return_stack_inc();
        jo* jojo = rp.jojo;
        jo jo = jojo[0];
        jo_apply(jo);
      }
    }
    #+end_src

* *stack_operation*

*** p_drop

    #+begin_src c
    p_drop() {
      pop(object_stack);
    }
    #+end_src

*** p_dup

    #+begin_src c
    p_dup() {
      // a a -> a
      cell a = pop(object_stack);
      push(object_stack, a);
      push(object_stack, a);
    }
    #+end_src

*** p_over

    #+begin_src c
    p_over() {
      // b a -> b a b
      cell a = pop(object_stack);
      cell b = pop(object_stack);
      push(object_stack, b);
      push(object_stack, a);
      push(object_stack, b);
    }
    #+end_src

*** p_tuck

    #+begin_src c
    p_tuck() {
      // b a -> a b a
      cell a = pop(object_stack);
      cell b = pop(object_stack);
      push(object_stack, a);
      push(object_stack, b);
      push(object_stack, a);
    }
    #+end_src

*** p_swap

    #+begin_src c
    p_swap() {
      // b a -> a b
      cell a = pop(object_stack);
      cell b = pop(object_stack);
      push(object_stack, a);
      push(object_stack, b);
    }
    #+end_src

*** expose_stack_operation

    #+begin_src c
    expose_stack_operation() {
      define_prim("drop", p_drop);
      define_prim("dup", p_dup);
      define_prim("over", p_over);
      define_prim("tuck", p_tuck);
      define_prim("swap", p_swap);
    }
    #+end_src

* *ending*

*** p_end

    #+begin_src c
    p_end() {
      return_point rp = return_stack_pop();
      current_local_pointer = rp.local_pointer;
    }
    #+end_src

*** p_bye

    #+begin_src c
    p_bye() {
      report("bye bye ^-^/\n");
      exit(0);
    }
    #+end_src

*** expose_ending

    #+begin_src c
    expose_ending() {
      define_prim("end", S0, p_end);
      define_prim("bye", S0, p_bye);
    }
    #+end_src

* *play*

*** p1

    #+begin_src c
    p1() {
      int file = open("README", O_RDWR);
      input_stack t0_stack = input_stack_file(file);
      input_stack_push(t0_stack, '\n');
      input_stack_push(t0_stack, '\n');
      input_stack_push(t0_stack, '1');
      input_stack_push(t0_stack, '2');
      input_stack_push(t0_stack, '3');
      input_stack_push(t0_stack, '4');
      input_stack_push(t0_stack, '\n');
      input_stack_push(t0_stack, '\n');
      while (!input_stack_empty_p(t0_stack)) {
        report("%c", input_stack_pop(t0_stack));
      }
      input_stack_free(t0_stack);
      report("- input_stack test0 finished\n");

      input_stack t1_stack = input_stack_terminal();
      while (!input_stack_empty_p(t1_stack)) {
        byte byte = input_stack_pop(t1_stack);
        report("\n> %c", byte);
      }
      input_stack_free(t1_stack);
      report("- input_stack test1 finished\n");

      input_stack t2_stack = input_stack_string("1234567890");
      input_stack_push(t2_stack, '\n');
      input_stack_push(t2_stack, '\n');
      input_stack_push(t2_stack, '1');
      input_stack_push(t2_stack, '2');
      input_stack_push(t2_stack, '3');
      input_stack_push(t2_stack, '4');
      input_stack_push(t2_stack, '\n');
      input_stack_push(t2_stack, '\n');
      while (!input_stack_empty_p(t2_stack)) {
        byte byte = input_stack_pop(t2_stack);
        report("%c", byte);
      }
      input_stack_free(t2_stack);
      report("\n");
      report("- input_stack test2 finished\n");
    }
    #+end_src

*** p2

    #+begin_src c
    p2() {
      int file = open("k1~", O_RDWR);
      output_stack t0_stack = output_stack_file(file);
      output_stack_push(t0_stack, '1'); output_stack_pop(t0_stack);
      output_stack_push(t0_stack, '2');
      output_stack_push(t0_stack, '3'); output_stack_drop(t0_stack);
      output_stack_push(t0_stack, '4');
      output_stack_push(t0_stack, '\n');
      output_stack_file_flush(t0_stack);
      output_stack_push(t0_stack, '1');
      output_stack_push(t0_stack, '2'); output_stack_pop(t0_stack);
      output_stack_push(t0_stack, '3');
      output_stack_push(t0_stack, '4'); output_stack_drop(t0_stack);
      output_stack_push(t0_stack, '\n');
      output_stack_file_flush(t0_stack);
      output_stack_free(t0_stack);
      close(file);
      report("- output_stack test0 finished\n");

      output_stack t1_stack = output_stack_terminal();
      output_stack_push(t1_stack, '\n');
      output_stack_push(t1_stack, '\n');
      output_stack_push(t1_stack, '1');
      output_stack_push(t1_stack, '2');
      output_stack_push(t1_stack, '3');
      output_stack_push(t1_stack, '4');
      output_stack_push(t1_stack, '\n');
      output_stack_push(t1_stack, '\n');
      output_stack_free(t1_stack);
      report("- output_stack test1 finished\n");

      output_stack t2_stack = output_stack_string();
      output_stack_push(t2_stack, '1');
      output_stack_push(t2_stack, '2');
      report("- %c\n", output_stack_pop(t2_stack));
      output_stack_push(t2_stack, '3');
      output_stack_push(t2_stack, '4');
      report("- %c\n", output_stack_pop(t2_stack));
      output_stack_push(t2_stack, '\n');
      char* collected_string = output_stack_string_collect(t2_stack);
      report("- collected_string : %s\n", collected_string);
      output_stack_free(t2_stack);
      report("- output_stack test2 finished\n");
    }
    #+end_src

*** p3

    #+begin_src c
    p3() {
      define_class("<rectangle>", "<object>", S3("height", "width", "k1"));
    }
    #+end_src

*** init_play

    #+begin_src c
    init_play() {
      p3();
    }
    #+end_src

*** expose_play

    #+begin_src c
    expose_play() {
      define_prim("p1", p1);
      define_prim("p2", p2);
      define_prim("p3", p3);
    }
    #+end_src

* init

*** init_system

    #+begin_src c
    init_system() {
      setvbuf(stdout, NULL, _IONBF, 0);
      setvbuf(stderr, NULL, _IONBF, 0);
    }
    #+end_src

*** init_jotable

    #+begin_src c
    init_jotable() {
      bzero(jotable, jotable_size * sizeof(jotable_entry));
    }
    #+end_src

*** init_literal_jo

    #+begin_src c
    init_literal_jo() {
      EMPTY_JO = str2jo("");

      TAG_PRIM         = str2jo("<prim>");
      TAG_JOJO         = str2jo("<jojo>");
      TAG_PRIM_KEYWORD = str2jo("<prim-keyword>");
      TAG_KEYWORD      = str2jo("<keyword>");
      TAG_DATA         = str2jo("<data>");

      JO_DECLARED = str2jo("declared");

      ROUND_BAR    =   str2jo("(");
      ROUND_KET    =   str2jo(")");
      SQUARE_BAR   =   str2jo("[");
      SQUARE_KET   =   str2jo("]");
      FLOWER_BAR   =   str2jo("{");
      FLOWER_KET   =   str2jo("}");
      DOUBLE_QUOTE =   str2jo("\"");

      JO_INS_INT  = str2jo("ins/int");
      JO_INS_JO   = str2jo("ins/jo");
      JO_INS_STRING = str2jo("ins/string");
      JO_INS_BYTE = str2jo("ins/byte");
      JO_INS_BARE_JOJO = str2jo("ins/bare-jojo");
      JO_INS_ADDRESS = str2jo("ins/address");

      JO_INS_JUMP = str2jo("ins/jump");
      JO_INS_JUMP_IF_FALSE = str2jo("ins/jump-if-false");

      JO_INS_TAIL_CALL = str2jo("ins/tail-call");
      JO_INS_LOOP = str2jo("ins/loop");
      JO_INS_RECUR = str2jo("ins/recur");

      JO_NULL     = str2jo("null");
      JO_THEN     = str2jo("then");
      JO_ELSE     = str2jo("else");

      JO_APPLY     = str2jo("apply");
      JO_END       = str2jo("end");

      JO_LOCAL_DATA_IN = str2jo("local-data-in");
      JO_LOCAL_DATA_OUT = str2jo("local-data-out");

      JO_LOCAL_TAG_IN = str2jo("local-tag-in");
      JO_LOCAL_TAG_OUT = str2jo("local-tag-out");

      JO_LOCAL_IN = str2jo("local-in");
      JO_LOCAL_OUT = str2jo("local-out");
    }
    #+end_src

*** init_stacks

    #+begin_src c
    jo jojo_area[1024 * 1024];

    init_stacks() {
      object_stack                 = new_stack("object_stack");
      return_stack                 = new_stack("return_stack");
      compiling_stack              = new_stack("compiling_stack");
      // reading_stack                = new_stack("reading_stack");
      // writing_stack                = new_stack("writing_stack");
      // binding_filter_stack         = new_stack("binding_filter_stack");
      keyword_stack                = new_stack("keyword_stack");
      // jo_filter_stack              = new_stack("jo_filter_stack");
      // current_compiling_jojo_stack = new_stack("current_compiling_jojo_stack");

      push(compiling_stack, jojo_area);
      // push(reading_stack, input_stack_terminal());
      // push(writing_stack, output_stack_terminal());
      // push(jo_filter_stack, str2jo("alias-filter"));
    }
    #+end_src

*** init_jojo

    #+begin_src c
    init_jojo() {
      init_jotable();
      init_literal_jo();
      init_stacks();

      expose_name();
      expose_apply();
      expose_stack_operation();
      expose_ending();

      expose_play();
    }
    #+end_src

* main

  #+begin_src c
  int main(int argc, char** argv) {
    // cmd_number = argc;
    // cmd_string_array = argv;
    init_system();
    init_jojo();
    init_play();
    return 66;
  }
  #+end_src
