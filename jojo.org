#+property: tangle jojo.c
#+title:  jojo

* todo

  - [debug] print jojo body
  - [debug] print return-stack
  - [debug] debug repl
  - [debug] trace
  - [debug] step

  - [control] full cc and delimited cc

  - [safe] error report for every limited number, jo-max-length
  - [safe] to handle low-level errors

  - [maybe]
    all read_byte or read_jo should ask has_byte_p or has_jo_p first
    - ohterwise bar-ket are assumed to be balanced

* note

*** naming convention

    - "-" phrase
      verb/tag (... -> tag) (... -> [tag])
      tag/verb (tag -> ...) ([tag] -> ...)

*** interface convention

    - before trying to get something from somewhere,
      first ask if it is there at all.

* helper

*** header

    #+begin_src c
    #include <sys/types.h>  /* Type definitions used by many programs */
    #include <stdio.h>      /* Standard I/O functions */
    #include <stdlib.h>     /* Prototypes of commonly used library functions,
                               plus EXIT_SUCCESS and EXIT_FAILURE constants */
    #include <unistd.h>     /* Prototypes for many system calls */
    #include <errno.h>      /* Declares errno and defines error constants */
    #include <string.h>     /* Commonly used string-handling functions */

    #include <fcntl.h>

    #include <sys/stat.h>
    #include <ctype.h>
    #include <stdint.h>

    #include <dlfcn.h>
    #include <dirent.h>
    #+end_src

*** bool

    #+begin_src c
    typedef enum { false, true } bool;
    #+end_src

*** cell

    #+begin_src c
    typedef intptr_t cell;
    #define cell_size (sizeof(cell))
    #+end_src

*** int

    #+begin_src c
    cell max(cell a, cell b) {
      if (a < b) {
        return b;
      }
      else {
        return a;
      }
    }

    cell min(cell a, cell b) {
      if (a > b) {
        return b;
      }
      else {
        return a;
      }
    }

    cell power(cell a, cell n) {
      cell result = 1;
      while (n >= 1) {
        result = result * a;
        n--;
      }
      return result;
    }
    #+end_src

*** byte

    #+begin_src c
    typedef unsigned char byte;
    #+end_src

*** char

    #+begin_src c
    bool isbarcket(char c) {
      return (c == '(' ||
              c == ')' ||
              c == '[' ||
              c == ']' ||
              c == '{' ||
              c == '}' ||
              c == '"');
    }
    #+end_src

*** char_to_nat

    #+begin_src c
    cell char_to_nat(char c) {
      if (c >= '0' && c <= '9') {
        return (c - '0');
      }
      else if (c >= 'A' && c <= 'Z') {
        return (c - 'A') + 10;
      }
      else if (c >= 'a' && c <= 'z') {
        return (c - 'a') + 10;
      }
      else {
        return 0;
      }
    }
    #+end_src

*** string

***** string

      #+begin_src c
      typedef char* string;
      #+end_src

***** string_equal

      #+begin_src c
      bool string_equal(string s1, string s2) {
        if (strcmp(s1, s2) == 0) {
          return true;
        }
        else {
          return false;
        }
      }
      #+end_src

***** nat_string_p

      #+begin_src c
      bool nat_string_p(string str) {
        cell i = 0;
        while (str[i] != 0) {
          if (!isdigit(str[i])) {
            return false;
            }
          i++;
        }
        return true;
      }
      #+end_src

***** int_string_p

      #+begin_src c
      bool int_string_p(string str) {
        if (str[0] == '-' ||
            str[0] == '+') {
          return nat_string_p(str + 1);
        }
        else {
          return nat_string_p(str);
        }
      }
      #+end_src

***** string_to_based_[nat|int]

      #+begin_src c
      cell string_to_based_nat(string str, cell base) {
        cell result = 0;
        cell len = strlen(str);
        cell i = 0;
        while (i < len) {
          result = result + (char_to_nat(str[i]) * power(base, (len - i - 1)));
          i++;
        }
        return result;
      }

      cell string_to_based_int(string str, cell base) {
        if (str[0] == '-') {
          return - string_to_based_nat(str, base);
        }
        else {
          return string_to_based_nat(str, base);
        }
      }
      #+end_src

***** string_to_[dec|bin|oct|hex]

      #+begin_src c
      cell string_to_dec(string str) { return string_to_based_int(str, 10); }
      cell string_to_bin(string str) { return string_to_based_int(str,  2); }
      cell string_to_oct(string str) { return string_to_based_int(str,  8); }
      cell string_to_hex(string str) { return string_to_based_int(str, 16); }
      #+end_src

* jotable

*** primitive

    #+begin_src c
    typedef void (*primitive)();
    #+end_src

*** jo & jojo

    #+begin_src c
    typedef cell jo;

    typedef struct {
      cell size;
      jo* array;
    } jojo;
    #+end_src

*** bind & jotable_entry

    #+begin_src c
    typedef cell bind;

    typedef struct {
      cell index;
      string key;
      jo tag;
      bind value;
      cell orbit_length;
      cell orbiton;
    } jotable_entry;
    #+end_src

*** jotable_entry_[occured|entry_used|no_collision]

    #+begin_src c
    jo JO_NOT_USED;

    bool jotable_entry_occured(jotable_entry e) {
      return e.key != 0;
    }

    bool jotable_entry_used(jotable_entry e) {
      return e.tag != JO_NOT_USED;
    }

    bool jotable_entry_no_collision(jotable_entry e) {
      return e.index == e.orbiton;
    }
    #+end_src

*** jotable

    #+begin_src c
    // prime table size
    //   1000003   about 976 k
    //   1000033
    //   1000333
    //   100003    about 97 k
    //   100333
    //   997
    #define jotable_size 100003
    jotable_entry jotable[jotable_size];
    cell jotable_counter = 0;
    #+end_src

*** string_to_sum

    #+begin_src c
    cell string_to_sum(string str) {
      cell sum = 0;
      cell max_step = 10;
      cell i = 0;
      while (i < strlen(str)) {
        sum = sum + ((byte) str[i]) * (2 << min(i, max_step));
        i++;
      }
      return sum;
    }
    #+end_src

*** jotable_keyeq

    #+begin_src c
    bool jotable_keyeq(string k1, string k2) {
      return string_equal(k1, k2);
    }
    #+end_src

*** jotable_hash

    #+begin_src c
    cell jotable_hash(string key, cell counter) {
      return (counter + string_to_sum(key)) % jotable_size;
    }
    #+end_src

*** string_area

    #+begin_src c
    char string_area[4 * 1024 * 1024];
    cell string_area_counter = 0;
    #+end_src

*** copy_to_string_area

    #+begin_src c
    string copy_to_string_area(string str) {
      char *str1;
      cell i = 0;
      str1 = (string_area + string_area_counter);
      while (true) {
        if (str[i] == 0) {
          str1[i] = str[i];
          i++;
          break;
        }
        else {
          str1[i] = str[i];
          i++;
        }
      }
      string_area_counter = i + string_area_counter;
      return str1;
    }
    #+end_src

j* jotable_insert

    #+begin_src c
    // -1 denotes the hash_table is filled
    cell jotable_insert(string key) {
      cell orbit_index = jotable_hash(key, 0);
      cell counter = 0;
      while (true) {
        cell index = jotable_hash(key, counter);
        if (!jotable_entry_occured(jotable[index])) {
          key = copy_to_string_area(key);
          jotable[index].key = key;
          jotable[index].orbiton = orbit_index;
          jotable[orbit_index].orbit_length = 1 + counter;
          jotable_counter = 1 + jotable_counter;
          return index;
        }
        else if (jotable_keyeq(key, jotable[index].key)) {
          return index;
        }
        else if (counter == jotable_size) {
          return -1;
        }
        else {
          counter = 1 + counter;
        }
      }
    }
    #+end_src

*** jotable_search

    #+begin_src c
    // -1 denotes key not occured
    cell jotable_search(string key) {
      cell counter = 0;
      while (true) {
        cell index = jotable_hash(key, counter);
        if (!jotable_entry_occured(jotable[index])) {
          return -1;
        }
        else if (jotable_keyeq(key, jotable[index].key)) {
          return index;
        }
        else if (counter == jotable_size) {
          return -1;
        }
        else {
          counter = 1 + counter;
        }
      }
    }
    #+end_src

*** jotable_entry_print

    #+begin_src c
    string jo2str (cell index);

    void jotable_entry_print(jotable_entry entry) {
      printf("%s : ", jo2str(entry.tag));
      printf("%ld", entry.value);
    }
    #+end_src

*** jotable_report_orbit

    #+begin_src c
    void jotable_report_orbit(cell index, cell counter) {
      while (counter < jotable[index].orbit_length) {
        string key = jotable[index].key;
        cell next_index = jotable_hash(key, counter);
        if (index == jotable[next_index].orbiton) {
          printf("  | %ld %s\n", next_index, jotable[next_index].key);
        }
        if (jotable_entry_used(jotable[next_index])) {
          printf("    = ");
          jotable_entry_print(jotable[next_index]);
          printf("\n");
        }
        counter = 1 + counter;
      }
    }
    #+end_src

*** jotable_report

    #+begin_src c
    void jotable_report() {
      printf("\n");
      printf("- jotable_report\n");
      printf("  : <index> <key> // <orbit-length>\n");
      cell index = 0;
      while (index < jotable_size) {
        if (jotable_entry_occured(jotable[index]) &&
            jotable_entry_no_collision(jotable[index])) {
          printf("  - %ld %s // %ld\n",
                 index, jotable[index].key, jotable[index].orbit_length);
          if (jotable_entry_used(jotable[index])) {
            printf("    = ");
            jotable_entry_print(jotable[index]);
            printf("\n");
          }
          jotable_report_orbit(index, 1);
        }
        index = 1 + index;
      }
      printf("  : <index> <key> // <orbit-length>\n");
      printf("\n");
      printf("- used : %ld\n", jotable_counter);
      printf("- free : %ld\n", jotable_size - jotable_counter);
    }
    #+end_src

*** jotable_print

    #+begin_src c
    void jotable_print() {
      printf("\n");
      printf("- jotable_print\n");
      cell index = 0;
      while (index < jotable_size) {
        printf("  - %ld %s %ld // %ld\n",
               index,
               jotable[index].key,
               jotable[index].value,
               jotable[index].orbit_length);
        index = 1 + index;
      }
      printf("\n");
      printf("- used : %ld\n", jotable_counter);
      printf("- free : %ld\n", jotable_size - jotable_counter);
    }
    #+end_src

*** str2jo & jo2str

    #+begin_src c
    jo str2jo(string str) {
      return jotable_insert(str);
    }

    string jo2str(cell index) {
      return jotable[index].key;
    }
    #+end_src

*** jojo_area

    #+begin_src c
    jo jojo_area[1024 * 1024];
    #+end_src

*** here

***** compiling_stack

      - to redirect compiling location

      #+begin_src c
      typedef jo* compiling_stack_t[1024];

      compiling_stack_t compiling_stack;
      cell compiling_stack_base = 0;
      cell compiling_stack_pointer = 0;

      void compiling_stack_push(jo* value) {
        compiling_stack[compiling_stack_pointer] = value;
        compiling_stack_pointer++;
      }

      jo* compiling_stack_pop() {
        compiling_stack_pointer--;
        return compiling_stack[compiling_stack_pointer];
      }

      void compiling_stack_inc() {
        compiling_stack[compiling_stack_pointer - 1] =
          compiling_stack[compiling_stack_pointer - 1] + 1;
      }


      jo* compiling_stack_tos() {
        return compiling_stack[compiling_stack_pointer - 1];
      }

      bool compiling_stack_empty_p() {
        return compiling_stack_pointer == compiling_stack_base;
      }
      #+end_src

***** init_compiling_stack

      #+begin_src c
      void init_compiling_stack() {
        compiling_stack_push(jojo_area);
      }
      #+end_src

***** here

      #+begin_src c
      void here(cell n) {
        jo* pointer = compiling_stack_pop();
        pointer[0] = n;
        compiling_stack_push(pointer + 1);
      }
      #+end_src

*** jotable_set_tag_and_value

    #+begin_src c
    void jotable_set_tag_and_value(cell index, jo tag, cell value) {
      jotable[index].tag = tag;
      jotable[index].value = value;
    }
    #+end_src

*** jotable_get_value

    #+begin_src c
    cell jotable_get_value(cell index) {
      return jotable[index].value;
    }
    #+end_src

*** literal jo

    #+begin_src c
    jo EMPTY_JO;
    jo TAG_PRIM;
    jo TAG_JOJO;
    jo TAG_PRIM_KEYWORD;
    jo TAG_KEYWORD;
    jo TAG_DATA;

    jo JO_NOT_USED;
    jo JO_DECLARED;

    jo ROUND_BAR    ;
    jo ROUND_KET    ;
    jo SQUARE_BAR   ;
    jo SQUARE_KET   ;
    jo FLOWER_BAR   ;
    jo FLOWER_KET   ;
    jo DOUBLE_QUOTE ;

    jo JO_INS_INT;
    jo JO_INS_JUMP;
    jo JO_INS_JUMP_IF_FALSE;

    jo JO_NULL;
    jo JO_THEN;
    jo JO_ELSE;

    jo JO_APPLY;
    jo JO_END;

    jo JO_JO_REPLACING_APPLY_WITH_LAST_LOCAL_POINTER;
    jo JO_REPLACING_APPLY_WITH_LAST_LOCAL_POINTER;

    jo JO_LOCAL_DATA_IN;
    jo JO_LOCAL_DATA_OUT;

    jo JO_LOCAL_TAG_IN;
    jo JO_LOCAL_TAG_OUT;

    jo JO_LOCAL_IN;
    jo JO_LOCAL_OUT;
    #+end_src

* as & rs

*** as

    #+begin_src c
    typedef cell argument_stack[1024 * 4];

    argument_stack as;
    cell as_base = 64;
    cell as_pointer = 64;

    void as_push(cell value) {
      as[as_pointer] = value;
      as_pointer++;
    }

    cell as_pop() {
      as_pointer--;
      return as[as_pointer];
    }

    cell as_tos() {
      return as[as_pointer - 1];
    }
    #+end_src

*** local

    #+begin_src c
    typedef struct {
      jo name;
      cell local_tag;
      cell local_data;
    } local_point;

    local_point local_area[1024 * 1024];
    cell current_local_pointer = 0;
    #+end_src

*** rs

    #+begin_src c
    typedef struct {
      jo* array;
      cell local_pointer;
    } return_point;

    typedef return_point return_stack[1024 * 4];

    return_stack rs;
    cell rs_base = 64;
    cell rs_pointer = 64;

    void rs_push(return_point value) {
      rs[rs_pointer] = value;
      rs_pointer++;
    }

    return_point rs_pop() {
      rs_pointer--;
      return rs[rs_pointer];
    }

    return_point rs_tos() {
      return rs[rs_pointer - 1];
    }

    void rs_make_point(jo* array, cell local_pointer) {
      return_point rp = {.array = array, .local_pointer = local_pointer};
      rs[rs_pointer] = rp;
      rs_pointer++;
    }

    void rs_new_point(jo* array) {
      rs_make_point(array, current_local_pointer);
    }

    void rs_inc() {
      return_point rp = rs_pop();
      return_point rp1 = {.array = rp.array + 1, .local_pointer = rp.local_pointer};
      rs_push(rp1);
    }
    #+end_src

* bind_name

*** name_record

    #+begin_src c
    jo name_record[64 * 1024];
    cell name_record_counter = 0;
    #+end_src

*** p_name_record

    #+begin_src c
    void p_name_record() {
      as_push(name_record);
    }
    #+end_src

*** p_name_report

    #+begin_src c
    void p_name_report() {
      printf("- p_name_report // counter : %ld\n", name_record_counter);
      cell i = 0;
      while (i < name_record_counter) {
        printf("  %s\n", jo2str(name_record[i]));
        i++;
      }
      printf("\n");
    }
    #+end_src

*** binding_filter_stack

***** binding_filter_stack

      #+begin_src c
      typedef jo binding_filter;

      typedef binding_filter binding_filter_stack_t[128];
      binding_filter_stack_t binding_filter_stack;

      cell binding_filter_stack_base = 0;
      cell binding_filter_stack_pointer = 0;

      void binding_filter_stack_push(binding_filter value) {
        binding_filter_stack[binding_filter_stack_pointer] = value;
        binding_filter_stack_pointer++;
      }

      binding_filter binding_filter_stack_pop() {
        binding_filter_stack_pointer--;
        return binding_filter_stack[binding_filter_stack_pointer];
      }

      binding_filter binding_filter_stack_tos() {
        return binding_filter_stack[binding_filter_stack_pointer - 1];
      }

      bool binding_filter_stack_empty_p() {
        return binding_filter_stack_pointer == binding_filter_stack_base;
      }
      #+end_src

***** p_binding_filter_stack_push

      #+begin_src c
      void p_binding_filter_stack_push() {
        binding_filter_stack_push(as_pop());
      }
      #+end_src

***** p_binding_filter_stack_pop

      #+begin_src c
      void p_binding_filter_stack_pop() {
        as_push(binding_filter_stack_pop());
      }
      #+end_src

***** run_binding_filter

      #+begin_src c
      void run_binding_filter() {
        cell i = binding_filter_stack_pointer;
        while (i > binding_filter_stack_base) {
          jo_apply_now(binding_filter_stack[i-1]);
          i--;
        }
      }
      #+end_src

*** binding_hook_stack

***** binding_hook_stack

      #+begin_src c
      typedef jo binding_hook;

      typedef binding_hook binding_hook_stack_t[128];
      binding_hook_stack_t binding_hook_stack;

      cell binding_hook_stack_base = 0;
      cell binding_hook_stack_pointer = 0;

      void binding_hook_stack_push(binding_hook value) {
        binding_hook_stack[binding_hook_stack_pointer] = value;
        binding_hook_stack_pointer++;
      }

      binding_hook binding_hook_stack_pop() {
        binding_hook_stack_pointer--;
        return binding_hook_stack[binding_hook_stack_pointer];
      }

      binding_hook binding_hook_stack_tos() {
        return binding_hook_stack[binding_hook_stack_pointer - 1];
      }

      bool binding_hook_stack_empty_p() {
        return binding_hook_stack_pointer == binding_hook_stack_base;
      }
      #+end_src

***** p_binding_hook_stack_push

      #+begin_src c
      void p_binding_hook_stack_push() {
        binding_hook_stack_push(as_pop());
      }
      #+end_src

***** p_binding_hook_stack_pop

      #+begin_src c
      void p_binding_hook_stack_pop() {
        as_push(binding_hook_stack_pop());
      }
      #+end_src

***** run_binding_hook

      #+begin_src c
      void run_binding_hook(cell name, jo tag, cell value) {
        cell i = binding_hook_stack_pointer;
        while (i > binding_hook_stack_base) {
          as_push(value);
          as_push(tag);
          as_push(name);
          jo_apply_now(binding_hook_stack[i-1]);
          i--;
        }
      }
      #+end_src

*** p_bind_name

    after_define (name -> [set-tail tos of defining-stack])

    #+begin_src c
    bool used_jo_p(jo index) {
      return
        jotable[index].tag != JO_NOT_USED;
    }

    bool declared_jo_p(jo index) {
      return
        jotable[index].tag == JO_DECLARED;
    }

    void p_bind_name() {
      run_binding_filter();
      jo name = as_pop();
      jo tag = as_pop();
      cell value = as_pop();
      if (used_jo_p(name) && !declared_jo_p(name)) {
        printf("- p_bind_name can not rebind\n");
        printf("  name : %s\n", jo2str(name));
        printf("  tag : %s\n", jo2str(tag));
        printf("  value : %ld\n", value);
        printf("  it has been bound as a %s\n", jo2str(jotable[name].tag));
        return;
      }
      jotable_set_tag_and_value(name, tag, value);

      run_binding_hook(name, tag, value);

      name_record[name_record_counter] = name;
      name_record_counter++;
      name_record[name_record_counter] = 0;
    }
    #+end_src

*** define_prim

    #+begin_src c
    void define_prim(string str, primitive fun) {
      jo name = str2jo(str);
      as_push(fun);
      as_push(TAG_PRIM);
      as_push(name);
      p_bind_name();
    }
    #+end_src

*** define_primkey

    #+begin_src c
    void define_primkey(string str, primitive fun) {
      jo name = str2jo(str);
      as_push(fun);
      as_push(TAG_PRIM_KEYWORD);
      as_push(name);
      p_bind_name();
    }
    #+end_src

* *bind*

*** export_bind

    #+begin_src c
    void export_bind() {
      define_prim("name-report", p_name_report);
      define_prim("name-record", p_name_record);

      define_prim("binding-filter-stack-push", p_binding_filter_stack_push);
      define_prim("binding-filter-stack-pop", p_binding_filter_stack_pop);

      define_prim("binding-hook-stack-push", p_binding_hook_stack_push);
      define_prim("binding-hook-stack-pop", p_binding_hook_stack_pop);
    }
    #+end_src

* apply & eval

*** note

    - be careful when calling jo_apply in primitive,
      because after rs_push a jojo,
      one need to exit current primitive to run the jojo.

      if wished follow a 'eval();' after jo_apply
      to return to the primitive function.

    - keyword_stack and alias_stack
      form a hook for read_jo.

*** keyword_stack

    #+begin_src c
    typedef cell keyword;
    typedef keyword keyword_stack_t[128];
    keyword_stack_t keyword_stack;

    cell keyword_stack_base = 0;
    cell keyword_stack_pointer = 0;

    void keyword_stack_push(keyword value) {
      keyword_stack[keyword_stack_pointer] = value;
      keyword_stack_pointer++;
    }

    keyword keyword_stack_pop() {
      keyword_stack_pointer--;
      return keyword_stack[keyword_stack_pointer];
    }

    keyword keyword_stack_tos() {
      return keyword_stack[keyword_stack_pointer - 1];
    }

    bool keyword_stack_empty_p() {
      return keyword_stack_pointer == keyword_stack_base;
    }
    #+end_src

*** alias_stack

    #+begin_src c
    typedef struct {
      jo nick;
      jo name;
    } alias;
    typedef alias alias_stack_t[1024];
    alias_stack_t alias_stack;

    cell alias_stack_base = 0;
    cell alias_stack_pointer = 0;

    void alias_stack_push(alias value) {
      alias_stack[alias_stack_pointer] = value;
      alias_stack_pointer++;
    }

    alias alias_stack_pop() {
      alias_stack_pointer--;
      return alias_stack[alias_stack_pointer];
    }

    alias alias_stack_tos() {
      return alias_stack[alias_stack_pointer - 1];
    }

    bool alias_stack_empty_p() {
      return alias_stack_pointer == alias_stack_base;
    }
    #+end_src

*** jo_apply

    #+begin_src c
    void jo_apply(jo jo) {
      if (!jotable_entry_used(jotable[jo])) {
        printf("undefined jo : %s\n", jo2str(jo));
        return;
      }
      cell tag = jotable[jo].tag;

      if (tag == TAG_PRIM) {
        primitive primitive = jotable_get_value(jo);
        primitive();
      }
      else if (tag == TAG_JOJO) {
        cell jojo = jotable_get_value(jo);
        rs_new_point(jojo);
      }

      else if (tag == TAG_PRIM_KEYWORD) {
        keyword_stack_push(alias_stack_pointer);
        primitive primitive = jotable_get_value(jo);
        primitive();
        alias_stack_pointer = keyword_stack_pop();
      }
      else if (tag == TAG_KEYWORD) {
        // keywords are always evaled
        keyword_stack_push(alias_stack_pointer);
        cell jojo = jotable_get_value(jo);
        rs_new_point(jojo);
        eval();
        alias_stack_pointer = keyword_stack_pop();
      }

      else if (tag == TAG_DATA) {
        cell cell = jotable_get_value(jo);
        as_push(cell);
      }
      else {
        cell cell = jotable_get_value(jo);
        as_push(cell);
        as_push(tag);
      }
    }
    #+end_src

*** jo_apply_now

    #+begin_src c
    void jo_apply_now(jo jo) {
      cell tag = jotable[jo].tag;
      if (tag == TAG_JOJO) {
        cell jojo = jotable_get_value(jo);
        rs_new_point(jojo);
        eval();
        return;
      }
      else {
        jo_apply(jo);
        return;
      }
    }
    #+end_src

*** jo_apply_with_local_pointer

    #+begin_src c
    void jo_apply_with_local_pointer(jo jo, cell local_pointer) {
      cell tag = jotable[jo].tag;
      if (tag == TAG_JOJO) {
        cell jojo = jotable_get_value(jo);
        rs_make_point(jojo, local_pointer);
        return;
      }
      else {
        jo_apply(jo);
        return;
      }
    }
    #+end_src

*** eval

    #+begin_src c
    void eval() {
      cell rs_base = rs_pointer;
      while (rs_pointer >= rs_base) {
        return_point rp = rs_tos();
        rs_inc();
        cell jo = *(cell*)rp.array;
        jo_apply(jo);
      }
    }
    #+end_src

* *apply*

*** p_apply

    #+begin_src c
    void p_apply() {
      rs_new_point(as_pop());
    }
    #+end_src

*** p_apply_with_local_pointer

    #+begin_src c
    void p_apply_with_local_pointer() {
      jo* jojo = as_pop();
      cell local_pointer = as_pop();
      rs_make_point(jojo, local_pointer);
    }
    #+end_src

*** p_replacing_apply_with_last_local_pointer

    #+begin_src c
    void p_replacing_apply_with_last_local_pointer() {
      jo jojo = as_pop();
      return_point rp = rs_pop();
      rs_make_point(jojo, rp.local_pointer);
    }
    #+end_src

*** p_jo_apply

    #+begin_src c
    void p_jo_apply() {
      jo_apply(as_pop());
    }
    #+end_src

*** p_jo_apply_with_local_pointer

    #+begin_src c
    void p_jo_apply_with_local_pointer() {
      jo jo = as_pop();
      cell local_pointer = as_pop();
      jo_apply_with_local_pointer(jo, local_pointer);
    }
    #+end_src

*** p_jo_replacing_apply_with_last_local_pointer

    #+begin_src c
    void p_jo_replacing_apply_with_last_local_pointer() {
      jo jo = as_pop();
      return_point rp = rs_pop();
      jo_apply_with_local_pointer(jo, rp.local_pointer);
    }
    #+end_src

*** export_apply

    #+begin_src c
    void export_apply() {
      define_prim("apply", p_apply);
      define_prim("apply-with-local-pointer", p_apply_with_local_pointer);
      define_prim("replacing-apply-with-last-local-pointer", p_replacing_apply_with_last_local_pointer);

      define_prim("jo/apply", p_jo_apply);
      define_prim("jo/apply-with-local-pointer", p_jo_apply_with_local_pointer);
      define_prim("jo/replacing-apply-with-last-local-pointer", p_jo_replacing_apply_with_last_local_pointer);
    }
    #+end_src

* *stack_operation*

*** cell_copy

    #+begin_src c
    void cell_copy(cell length, cell* from, cell* to) {
      cell i = 0;
      while (i < length) {
        to[i] = from[i];
        i++;
      }
    }
    #+end_src

*** p_drop

    #+begin_src c
    void p_drop() {
      as_pop();
    }
    #+end_src

*** p_2drop

    #+begin_src c
    void p_2drop() {
      as_pop();
      as_pop();
    }
    #+end_src

*** p_dup

    #+begin_src c
    void p_dup() {
      // (a a -> a)
      cell a = as_pop();
      as_push(a);
      as_push(a);
    }
    #+end_src

*** p_2dup

    #+begin_src c
    void p_2dup() {
      // (b a -> b a b a)
      cell a = as_pop();
      cell b = as_pop();
      as_push(b);
      as_push(a);
      as_push(b);
      as_push(a);
    }
    #+end_src

*** p_over

    #+begin_src c
    void p_over() {
      // (b a -> b a b)
      cell a = as_pop();
      cell b = as_pop();
      as_push(b);
      as_push(a);
      as_push(b);
    }
    #+end_src

*** p_2over

    #+begin_src c
    void p_2over() {
      // (d c  b a -> d c  b a  d c)
      cell a = as_pop();
      cell b = as_pop();
      cell c = as_pop();
      cell d = as_pop();
      as_push(d);
      as_push(c);
      as_push(b);
      as_push(a);
      as_push(d);
      as_push(c);
    }
    #+end_src

*** p_tuck

    #+begin_src c
    void p_tuck() {
      // (b a -> a b a)
      cell a = as_pop();
      cell b = as_pop();
      as_push(a);
      as_push(b);
      as_push(a);
    }
    #+end_src

*** p_2tuck

    #+begin_src c
    void p_2tuck() {
      // (d c  b a -> b a  d c  b a)
      cell a = as_pop();
      cell b = as_pop();
      cell c = as_pop();
      cell d = as_pop();
      as_push(b);
      as_push(a);
      as_push(d);
      as_push(c);
      as_push(b);
      as_push(a);
    }
    #+end_src

*** p_swap

    #+begin_src c
    void p_swap() {
      // (b a -> a b)
      cell a = as_pop();
      cell b = as_pop();
      as_push(a);
      as_push(b);
    }
    #+end_src

*** p_2swap

    #+begin_src c
    void p_2swap() {
      // (d c  b a -> b a  d c)
      cell a = as_pop();
      cell b = as_pop();
      cell c = as_pop();
      cell d = as_pop();
      as_push(b);
      as_push(a);
      as_push(d);
      as_push(c);
    }
    #+end_src

*** p_xy_swap

    #+begin_src c
    void p_xy_swap() {
      // (xxx yyy x y -> yyy xxx)
      cell y = as_pop();
      cell x = as_pop();
      cell* yp = calloc(y, cell_size);
      cell* xp = calloc(x, cell_size);
      cell_copy(y, (as + (as_pointer - y)), yp);
      cell_copy(x, (as + (as_pointer - y - x)), xp);
      cell_copy(y, yp, (as + (as_pointer - y - x)));
      cell_copy(x, xp, (as + (as_pointer - x)));
      free(yp);
      free(xp);
    }
    #+end_src

*** p_as_print

    #+begin_src c
    void p_as_print() {
      // ([io] ->)
      printf("\n");
      if (as_pointer < as_base) {
        printf("  * %ld *  ", (as_pointer - as_base));
        printf("-- below the stack --\n");
      }
      else {
        printf("  * %ld *  ", (as_pointer - as_base));
        printf("-- ");
        cell i = as_base;
        while (i < as_pointer) {
          printf("%ld ", as[i]);
          i++;
        }
        printf("--\n");
      }
    }
    #+end_src

*** p_stack_base

    #+begin_src c
    void p_stack_base() {
      as_push(as + as_base);
    }
    #+end_src

*** p_stack_pointer

    #+begin_src c
    void p_stack_pointer() {
      as_push(as + as_pointer);
    }
    #+end_src

*** export_stack_operation

    #+begin_src c
    void export_stack_operation() {
      define_prim("drop", p_drop);
      define_prim("2drop", p_2drop);
      define_prim("dup", p_dup);
      define_prim("2dup", p_2dup);
      define_prim("over", p_over);
      define_prim("2over", p_2over);
      define_prim("tuck", p_tuck);
      define_prim("2tuck", p_2tuck);
      define_prim("swap", p_swap);
      define_prim("2swap", p_2swap);
      define_prim("xy-swap", p_xy_swap);
      define_prim("as/print", p_as_print);
      define_prim("stack-pointer", p_stack_pointer);
      define_prim("stack-base", p_stack_base);
    }
    #+end_src

* *ending*

*** p_end

    #+begin_src c
    void p_end() {
      // (rs: addr ->)
      return_point rp = rs_pop();
      current_local_pointer = rp.local_pointer;
    }
    #+end_src

*** p_bye

    #+begin_src c
    void p_bye() {
      // (-> [exit])
      printf("bye bye ^-^/\n");
      exit(0);
    }
    #+end_src

*** export_ending

    #+begin_src c
    void export_ending() {
      define_prim("end", p_end);
      define_prim("bye", p_bye);
    }
    #+end_src

* *control*

*** i_lit

    #+begin_src c
    void i_lit() {
      // ([rs] -> int)
      return_point rp = rs_tos();
      rs_inc();
      cell jo = *(cell*)rp.array;
      as_push(jo);
    }
    #+end_src

*** i_jump_if_false

    #+begin_src c
    void i_jump_if_false() {
      // (bool [rs] -> [rs])
      return_point rp = rs_tos();
      rs_inc();
      jo* a = *(cell*)rp.array;
      cell b = as_pop();
      if (b == 0) {
        return_point rp1 = rs_pop();
        rs_make_point(a, rp1.local_pointer);
      }
    }
    #+end_src

*** i_jump

    #+begin_src c
    void i_jump() {
      // ([rs] -> [rs])
      return_point rp = rs_tos();
      jo* a = *(cell*)rp.array;
      return_point rp1 = rs_pop();
      rs_make_point(a, rp1.local_pointer);
    }
    #+end_src

*** export_control

    #+begin_src c
    void export_control() {
      define_prim("ins/lit", i_lit);
      define_prim("ins/jump-if-false", i_jump_if_false);
      define_prim("ins/jump", i_jump);
    }
    #+end_src

* *bool*

*** p_true

    #+begin_src c
    void p_true() {
      as_push(1);
    }
    #+end_src

*** p_false

    #+begin_src c
    void p_false() {
      as_push(0);
    }
    #+end_src

*** p_not

    #+begin_src c
    void p_not() {
      // (bool -> bool)
      cell a = as_pop();
      as_push(!a);
    }
    #+end_src

*** p_and

    #+begin_src c
    void p_and() {
      // (bool bool -> bool)
      cell a = as_pop();
      cell b = as_pop();
      as_push(a&&b);
    }
    #+end_src

*** p_or

    #+begin_src c
    void p_or() {
      // (bool bool -> bool)
      cell a = as_pop();
      cell b = as_pop();
      as_push(a||b);
    }
    #+end_src

*** export_bool

    #+begin_src c
    void export_bool() {
      define_prim("true", p_true);
      define_prim("false", p_false);
      define_prim("not", p_not);
      define_prim("and", p_and);
      define_prim("or", p_or);
    }
    #+end_src

* *bit*

*** p_true_bit

    #+begin_src c
    void p_true_bit() {
      // (-> cell)
      cell i = -1;
      as_push(i);
    }
    #+end_src

*** p_false_bit

    #+begin_src c
    void p_false_bit() {
      // (-> cell)
      as_push(0);
    }
    #+end_src

*** p_bit_and

    #+begin_src c
    void p_bit_and() {
      // (cell cell -> cell)
      cell b = as_pop();
      cell a = as_pop();
      as_push(a&b);
    }
    #+end_src

*** p_bit_or

    #+begin_src c
    void p_bit_or() {
      // (cell cell -> cell)
      cell b = as_pop();
      cell a = as_pop();
      as_push(a|b);
    }
    #+end_src

*** p_bit_xor

    #+begin_src c
    void p_bit_xor() {
      // (cell cell -> cell)
      cell b = as_pop();
      cell a = as_pop();
      as_push(a^b);
    }
    #+end_src

*** p_bit_not

    #+begin_src c
    void p_bit_not() {
      // (cell -> cell)
      cell a = as_pop();
      as_push(~a);
    }
    #+end_src

*** p_bit_shift_left

    #+begin_src c
    void p_bit_shift_left() {
      // (cell step -> cell)
      cell s = as_pop();
      cell a = as_pop();
      as_push(a<<s);
    }
    #+end_src

*** note shift_right & arithmetic_shift_right

    - must not use >> because its meaning is not sure in c

*** export_bit

    #+begin_src c
    void export_bit() {
      define_prim("true/bit", p_true_bit);
      define_prim("false/bit", p_false_bit);
      define_prim("bit/not", p_bit_not);
      define_prim("bit/and", p_bit_and);
      define_prim("bit/xor", p_bit_xor);
      define_prim("bit/or", p_bit_or);
      define_prim("bit/shift-left", p_bit_shift_left);
      // define_prim("bit/shift-right", p_bit_shift_right);
      // define_prim("bit/arithmetic-shift-right", p_bit_arithmetic_shift_right);
    }
    #+end_src

* *int*

*** p_inc

    #+begin_src c
    void p_inc() {
      cell a = as_pop();
      as_push(a + 1);
    }
    #+end_src

*** p_dec

    #+begin_src c
    void p_dec() {
      cell a = as_pop();
      as_push(a - 1);
    }
    #+end_src

*** p_neg

    #+begin_src c
    void p_neg() {
      cell a = as_pop();
      as_push(- a);
    }
    #+end_src

*** p_add

    #+begin_src c
    void p_add() {
      // (cell cell -> int)
      cell b = as_pop();
      cell a = as_pop();
      as_push(a + b);
    }
    #+end_src

*** p_sub

    #+begin_src c
    void p_sub() {
      // (cell cell -> int)
      cell b = as_pop();
      cell a = as_pop();
      as_push(a - b);
    }
    #+end_src

*** p_mul

    #+begin_src c
    void p_mul() {
      // (cell cell -> int)
      cell b = as_pop();
      cell a = as_pop();
      as_push(a * b);
    }
    #+end_src

*** p_div

    #+begin_src c
    void p_div() {
      // (cell cell -> int)
      cell b = as_pop();
      cell a = as_pop();
      as_push(a / b);
    }
    #+end_src

*** p_mod

    #+begin_src c
    void p_mod() {
      // (cell cell -> int)
      cell b = as_pop();
      cell a = as_pop();
      as_push(a % b);
    }
    #+end_src

*** p_n_eq_p

    #+begin_src c
    void p_n_eq_p() {
      // (a ... b ... n -> bool)
      cell n = as_pop();
      cell old_n = n;
      cell* cursor1 = (as + as_pointer - n);
      cell* cursor2 = (as + as_pointer - n - n);
      while (n > 0) {
        if (cursor1[n-1] != cursor2[n-1]) {
          as_pointer = as_pointer - old_n - old_n;
          as_push(false);
          return;
        }
        n--;
      }
      as_pointer = as_pointer - old_n - old_n;
      as_push(true);
    }
    #+end_src

*** p_eq_p

    #+begin_src c
    void p_eq_p() {
      // (cell cell -> bool)
      cell b = as_pop();
      cell a = as_pop();
      as_push(a == b);
    }
    #+end_src

*** p_gt_p

    #+begin_src c
    void p_gt_p() {
      // (cell cell -> bool)
      cell b = as_pop();
      cell a = as_pop();
      as_push(a > b);
    }
    #+end_src

*** p_lt_p

    #+begin_src c
    void p_lt_p() {
      // (cell cell -> bool)
      cell b = as_pop();
      cell a = as_pop();
      as_push(a < b);
    }
    #+end_src

*** p_gteq_p

    #+begin_src c
    void p_gteq_p() {
      // (cell cell -> bool)
      cell b = as_pop();
      cell a = as_pop();
      as_push(a >= b);
    }
    #+end_src

*** p_lteq_p

    #+begin_src c
    void p_lteq_p() {
      // (cell cell -> bool)
      cell b = as_pop();
      cell a = as_pop();
      as_push(a <= b);
    }
    #+end_src

*** k_int

    #+begin_src c
    jo read_raw_jo();

    void k_int() {
      // ([io] -> [compile])
      while (true) {
        jo s = read_raw_jo();
        if (s == ROUND_KET) {
          break;
        }
        else {
          here(JO_INS_INT);
          here(string_to_dec(jo2str(s)));
        }
      }
    }
    #+end_src

*** p_int_print

    #+begin_src c
    void p_int_print() { printf("%ld", as_pop()); }
    #+end_src

*** p_dot & p_int_dot

    #+begin_src c
    void p_dot() { printf("%ld ", as_pop()); }
    void p_int_dot() { printf("%ld ", as_pop()); }
    #+end_src

*** export_int

    #+begin_src c
    void export_int() {
      define_prim("inc", p_inc);
      define_prim("dec", p_dec);
      define_prim("neg", p_neg);

      define_prim("add", p_add);
      define_prim("sub", p_sub);

      define_prim("mul", p_mul);
      define_prim("div", p_div);
      define_prim("mod", p_mod);

      define_prim("n-eq?", p_n_eq_p);

      define_prim("eq?", p_eq_p);
      define_prim("gt?", p_gt_p);
      define_prim("lt?", p_lt_p);
      define_prim("gteq?", p_gteq_p);
      define_prim("lteq?", p_lteq_p);

      define_primkey("int", k_int);

      define_prim("int/print", p_int_print);

      define_prim("dot", p_dot);
      define_prim("int/dot", p_int_dot);
    }
    #+end_src

* *memory*

*** p_allocate

    #+begin_src c
    void p_allocate () {
      // (size -> addr)
      as_push(calloc(as_pop(), 1));
    }
    #+end_src

*** p_free

    #+begin_src c
    void p_free () {
      // (addr ->)
      free(as_pop());
    }
    #+end_src

*** k_address

    #+begin_src c
    void k_address() {
      // ([io] -> [compile])
      here(JO_INS_INT);
      jo index = read_raw_jo();
      here(&(jotable[index].value));
      k_ignore();
    }
    #+end_src

*** p_jo_as_var

    #+begin_src c
    void p_jo_as_var() {
      jo jo = as_pop();
      as_push(&(jotable[jo].value));
    }
    #+end_src

*** p_set_cell

    #+begin_src c
    void p_set_cell() {
      // (cell address ->)
      cell* address = as_pop();
      cell value = as_pop();
      address[0] = value;
    }
    #+end_src

*** p_get_cell

    #+begin_src c
    void p_get_cell() {
      // (address -> cell)
      cell* address = as_pop();
      as_push(address[0]);
    }
    #+end_src

*** p_set_byte

    #+begin_src c
    void p_set_byte() {
      // (byte address ->)
      char* address = as_pop();
      cell value = as_pop();
      address[0] = value;
    }
    #+end_src

*** p_get_byte

    #+begin_src c
    void p_get_byte() {
      // (address -> byte)
      char* address = as_pop();
      as_push(address[0]);
    }
    #+end_src

*** export_memory

    #+begin_src c
    void export_memory() {
      define_prim("allocate", p_allocate);
      define_prim("free", p_free);
      define_primkey("address", k_address);
      define_prim("jo-as-var", p_jo_as_var);
      define_prim("set-cell", p_set_cell);
      define_prim("get-cell", p_get_cell);
      define_prim("set-byte", p_set_byte);
      define_prim("get-byte", p_get_byte);
    }
    #+end_src

* *byte*

*** reading_stack

    #+begin_src c
    typedef struct {
      FILE* file_handle;
      string file;
      string dir;
    } reading_point;

    typedef reading_point reading_stack_t[64];

    reading_stack_t reading_stack;
    cell reading_stack_base = 0;
    cell reading_stack_pointer = 0;

    void reading_stack_push(reading_point value) {
      reading_stack[reading_stack_pointer] = value;
      reading_stack_pointer++;
    }

    reading_point reading_stack_pop() {
      reading_stack_pointer--;
      return reading_stack[reading_stack_pointer];
    }

    reading_point reading_stack_tos() {
      return reading_stack[reading_stack_pointer - 1];
    }

    bool reading_stack_empty_p() {
      return reading_stack_pointer == reading_stack_base;
    }
    #+end_src

*** real_reading_path

    #+begin_src c
    void real_reading_path(string path, char* buffer) {
      if (path[0] == '/') {
        realpath(path, buffer);
        return;
      }
      else if (reading_stack_empty_p()) {
        realpath(path, buffer);
        return;
      }
      else {
        buffer[0] = 0;
        strcat(buffer, reading_stack_tos().dir);
        strcat(buffer, "/");
        strcat(buffer, path);
        return;
      }
    }
    #+end_src

*** has_byte_p

    #+begin_src c
    bool has_byte_p() {
      FILE* fd;
      if (reading_stack_empty_p()) {
        fd = stdin;
      }
      else {
        fd = reading_stack_tos().file_handle;
      }

      if (feof(fd) == 0) {
        return true;
      }
      else {
        return false;
      }
    }
    #+end_src

*** p_has_byte_p

    #+begin_src c
    void p_has_byte_p() {
      as_push(has_byte_p());
    }
    #+end_src

*** read_byte

    #+begin_src c
    bool exit_repl();

    byte read_byte() {
      if (reading_stack_empty_p()) {
        return fgetc(stdin);
      }
      else {
        return fgetc(reading_stack_tos().file_handle);
      }
    }
    #+end_src

*** byte_unread

    #+begin_src c
    void byte_unread(byte c) {
      if (reading_stack_empty_p()) {
        ungetc(c, stdin);
      }
      else {
        ungetc(c, reading_stack_tos().file_handle);
      }
    }
    #+end_src

*** p_read_byte

    #+begin_src c
    void p_read_byte() {
      // (-> byte)
      as_push(read_byte());
    }
    #+end_src

*** p_byte_unread

    #+begin_src c
    void p_byte_unread() {
      // (byte -> [reading_stack])
      byte_unread(as_pop());
    }
    #+end_src

*** p_byte_print

    #+begin_src c
    void p_byte_print() {
      // (byte ->)
      printf("%c", as_pop());
    }
    #+end_src

*** export_byte

    #+begin_src c
    void export_byte() {
      define_prim("has-byte?", p_has_byte_p);
      define_prim("read/byte", p_read_byte);
      define_prim("byte/unread", p_byte_unread);
      define_prim("byte/print", p_byte_print);
    }
    #+end_src

* *string*

*** k_one_string

    #+begin_src c
    void k_one_string() {
      // ([io] -> [compile])
      char buffer[1024 * 1024];
      cell cursor = 0;
      while (true) {
        char c = read_byte();
        if (c == '"') {
          buffer[cursor] = 0;
          cursor++;
          break;
        }
        else {
          buffer[cursor] = c;
          cursor++;
        }
      }
      string str = malloc(cursor);
      strcpy(str, buffer);
      here(JO_INS_INT);
      here(str);
    }
    #+end_src

*** k_string

    #+begin_src c
    void k_string() {
      // ([io] -> [compile])
      while (true) {
        jo s = read_raw_jo();
        if (s == ROUND_KET) {
          return;
        }
        else if (s == DOUBLE_QUOTE) {
          k_one_string();
        }
        else {
          // do nothing
        }
      }
    }
    #+end_src

*** p_string_length

    #+begin_src c
    void p_string_length() {
      // (string -> length)
      as_push(strlen(as_pop()));
    }
    #+end_src

*** p_string_print

    #+begin_src c
    void p_string_print() {
      // (string -> [io])
      printf("%s", as_pop());
    }
    #+end_src

*** p_string_dot

    #+begin_src c
    void p_string_dot() {
      // (string -> [io])
      printf("\"%s \"", as_pop());
    }
    #+end_src

*** p_string_append_to_buffer

    #+begin_src c
    void p_string_append_to_buffer() {
      // (buffer, string -> buffer)
      string str = as_pop();
      string buffer = as_tos();
      strcat(buffer, str);
    }
    #+end_src

*** p_string_first_byte

    #+begin_src c
    void p_string_first_byte() {
      string s = as_pop();
      as_push(s[0]);
    }
    #+end_src

*** p_string_last_byte

    #+begin_src c
    void p_string_last_byte() {
      string s = as_pop();
      cell i = 0;
      while (s[i+1] != 0) {
        i++;
      }
      as_push(s[i]);
    }
    #+end_src

*** p_string_member_p

    #+begin_src c
    void p_string_member_p() {
      // (byte[not 0] string -> true or false)
      string s = as_pop();
      byte b = as_pop();
      cell i = 0;
      while (s[i] != 0) {
        if (s[i] == b) {
          as_push(true);
          return;
        }
        else {
          i++;
        }
      }
      as_push(false);
    }
    #+end_src

*** p_string_find_byte

    #+begin_src c
    void p_string_find_byte() {
      // (byte string -> [index true] or [false])
      string s = as_pop();
      byte b = as_pop();
      cell i = 0;
      while (s[i] != 0) {
        if (s[i] == b) {
          as_push(i);
          as_push(true);
          return;
        }
        else {
          i++;
        }
      }
      as_push(false);
    }
    #+end_src

*** export_string

    #+begin_src c
    void export_string() {
      define_primkey("string", k_string);
      define_primkey("one-string", k_one_string);
      define_prim("string/print", p_string_print);
      define_prim("string/dot", p_string_dot);
      define_prim("string/length", p_string_length);
      define_prim("string/append-to-buffer", p_string_append_to_buffer);
      define_prim("string/first-byte", p_string_first_byte);
      define_prim("string/last-byte", p_string_last_byte);
      define_prim("string/member?", p_string_member_p);
      define_prim("string/find-byte", p_string_find_byte);
    }
    #+end_src

* *jo*

*** p_alias_push

    #+begin_src c
    void p_alias_push() {
      jo name = as_pop();
      jo nick = as_pop();
      alias a = {.nick = nick, .name = name};
      alias_stack_push(a);
    }
    #+end_src

*** p_alias_filter

    #+begin_src c
    void p_alias_filter() {
      jo nick = as_pop();
      cell base = keyword_stack_tos();
      cell i = alias_stack_pointer;
      while (i >= base) {
        if (alias_stack[i].nick == nick) {
          as_push(alias_stack[i].name);
          return;
        }
        else {
          i--;
        }
      }
      as_push(nick);
    }
    #+end_src

*** has_jo_p

    #+begin_src c
    bool has_jo_p() {
      byte c;
      while (true) {

        if (!has_byte_p()) {
          return false;
        }

        c = read_byte();

        if (isspace(c)) {
          // loop
        }
        else {
          byte_unread(c);
          return true;
        }
      }
    }
    #+end_src

*** p_has_jo_p

    #+begin_src c
    void p_has_jo_p() {
      as_push(has_jo_p());
    }
    #+end_src

*** p_read_raw_jo

    #+begin_src c
    void p_read_raw_jo() {
      // ([io] -> jo)
      byte buf[1024];
      cell cur = 0;
      cell collecting = false;
      byte c;
      byte go = true;

      while (go) {

        if (!has_byte_p()) {
          if (!collecting) {
            printf("- p_read_raw_jo meet end-of-file\n");
            return;
          }
          else {
            break;
          }
        }

        c = read_byte();

        if (!collecting) {
          if (isspace(c)) {
            // loop
          }
          else {
            collecting = true;
            buf[cur] = c;
            cur++;
            if (isbarcket(c)) {
              go = false;
            }
          }
        }

        else {
          if (isbarcket(c) ||
              isspace(c)) {
            byte_unread(c);
            go = false;
          }
          else {
            buf[cur] = c;
            cur++;
          }
        }
      }

      buf[cur] = 0;
      as_push(str2jo(buf));
    }
    #+end_src

*** jo_filter_stack

***** jo_filter_stack

      #+begin_src c
      typedef jo reading_filter;

      typedef reading_filter jo_filter_stack_t[128];
      jo_filter_stack_t jo_filter_stack;

      cell jo_filter_stack_base = 0;
      cell jo_filter_stack_pointer = 0;

      void jo_filter_stack_push(reading_filter value) {
        jo_filter_stack[jo_filter_stack_pointer] = value;
        jo_filter_stack_pointer++;
      }

      reading_filter jo_filter_stack_pop() {
        jo_filter_stack_pointer--;
        return jo_filter_stack[jo_filter_stack_pointer];
      }

      reading_filter jo_filter_stack_tos() {
        return jo_filter_stack[jo_filter_stack_pointer - 1];
      }

      bool jo_filter_stack_empty_p() {
        return jo_filter_stack_pointer == jo_filter_stack_base;
      }
      #+end_src

***** p_jo_filter_stack_push

      #+begin_src c
      void p_jo_filter_stack_push() {
        jo_filter_stack_push(as_pop());
      }
      #+end_src

***** p_jo_filter_stack_pop

      #+begin_src c
      void p_jo_filter_stack_pop() {
        as_push(jo_filter_stack_pop());
      }
      #+end_src

***** run_jo_filter

      #+begin_src c
      void run_jo_filter() {
        cell i = jo_filter_stack_pointer;
        while (i > jo_filter_stack_base) {
          jo_apply_now(jo_filter_stack[i-1]);
          i--;
        }
      }
      #+end_src

***** init_jo_filter_stack

      #+begin_src c
      void init_jo_filter_stack() {
        jo_filter_stack_push(str2jo("alias-filter"));
      }
      #+end_src

*** p_read_jo

    #+begin_src c
    void p_read_jo() {
      p_read_raw_jo();
      run_jo_filter();
    }
    #+end_src

*** read_jo

    #+begin_src c
    jo read_jo() {
      p_read_jo();
      return as_pop();
    }
    #+end_src

*** read_raw_jo

    #+begin_src c
    jo read_raw_jo() {
      p_read_raw_jo();
      return as_pop();
    }
    #+end_src

*** cat_2_jo

    #+begin_src c
    jo cat_2_jo(jo x, jo y) {
      char str[2 * 1024];
      str[0] = 0;
      strcat(str, jo2str(x));
      strcat(str, jo2str(y));
      return str2jo(str);
    }
    #+end_src

*** cat_3_jo

    #+begin_src c
    jo cat_3_jo(jo x, jo y, jo z) {
      char str[3 * 1024];
      str[0] = 0;
      strcat(str, jo2str(x));
      strcat(str, jo2str(y));
      strcat(str, jo2str(z));
      return str2jo(str);
    }
    #+end_src

*** p_jo_append

    #+begin_src c
    void p_jo_append() {
      jo jo2 = as_pop();
      jo jo1 = as_pop();
      as_push(cat_2_jo(jo1, jo2));
    }
    #+end_src

*** p_empty_jo

    #+begin_src c
    void p_empty_jo() {
      as_push(EMPTY_JO);
    }
    #+end_src

*** p_jo_used_p

    #+begin_src c
    void p_jo_used_p() {
      // (jo -> bool)
      jo jo = as_pop();
      as_push(jotable_entry_used(jotable[jo]));
    }
    #+end_src

*** p_jo_to_string

    #+begin_src c
    void p_jo_to_string() {
      // (jo -> string)
      jo jo = as_pop();
      as_push(jo2str(jo));
    }
    #+end_src

*** p_string_length_to_jo

    #+begin_src c
    void p_string_length_to_jo() {
      // (string length -> jo)
      cell len = as_pop();
      cell str = as_pop();
      char buffer[2 * 1024];
      strncpy(buffer, str, len);
      buffer[len] = 0;
      as_push(str2jo(buffer));
    }
    #+end_src

*** p_string_to_jo

    #+begin_src c
    void p_string_to_jo() {
      // (string -> jo)
      string str = as_pop();
      as_push(str2jo(str));
    }
    #+end_src

*** p_null

    #+begin_src c
    void p_null() {
      as_push(JO_NULL);
    }
    #+end_src

*** k_raw_jo

    #+begin_src c
    void k_raw_jo() {
      // ([io] -> [compile])
      while (true) {
        jo s = read_raw_jo();
        if (s == ROUND_BAR) {
          jo_apply(read_jo());
        }
        else if (s == ROUND_KET) {
          break;
        }
        else {
          here(JO_INS_INT);
          here(s);
        }
      }
    }
    #+end_src

*** k_jo

    #+begin_src c
    void k_jo() {
      // ([io] -> [compile])
      while (true) {
        jo s = read_jo();
        if (s == ROUND_BAR) {
          jo_apply(read_jo());
        }
        else if (s == ROUND_KET) {
          break;
        }
        else {
          here(JO_INS_INT);
          here(s);
        }
      }
    }
    #+end_src

*** p_jo_print

    #+begin_src c
    void p_jo_print() {
      // (jo -> [io])
      printf("%s", jo2str(as_pop()));
    }
    #+end_src

*** p_jo_dot

    #+begin_src c
    void p_jo_dot() {
      // (jo -> [io])
      printf("%s ", jo2str(as_pop()));
    }
    #+end_src

*** p_generate_jo

    #+begin_src c
    cell p_generate_jo_counter = 0;
    void p_generate_jo() {
      string s = as_pop();
      char buffer [1024];
      sprintf(buffer, "%s:generated-jo#%ld", jo2str(s), p_generate_jo_counter);
      p_generate_jo_counter++;
      as_push(str2jo(buffer));
    }
    #+end_src

*** p_jo_find_byte

    #+begin_src c
    void p_jo_find_byte() {
      // (byte jo -> [index true] or [false])
      p_jo_to_string();
      p_string_find_byte();
    }
    #+end_src

*** p_jo_right_part

    #+begin_src c
    void p_jo_right_part() {
      // (index jo -> jo)
      jo jo = as_pop();
      cell index = as_pop();
      string s = jo2str(jo);
      as_push(str2jo(s + index));
    }
    #+end_src

*** p_jo_left_part

    #+begin_src c
    void p_jo_left_part() {
      // (index jo -> jo)
      char target[1024];
      jo jo = as_pop();
      cell index = as_pop();
      string source = jo2str(jo);
      cell i = 0;
      while (i < index) {
        target[i] = source[i];
        i++;
      }
      target[index] = 0;
      as_push(str2jo(target));
    }
    #+end_src

*** p_jo_part

    #+begin_src c
    void p_jo_part() {
      // (index-begin index-end jo -> jo)
      char target[1024];
      jo jo = as_pop();
      cell index_end = as_pop();
      cell index_begin = as_pop();
      string source = jo2str(jo);
      cell i = index_begin;
      while (i < index_end) {
        target[i] = source[i];
        i++;
      }
      target[index_end] = 0;
      as_push(str2jo(target + index_begin));
    }
    #+end_src

*** export_jo

    #+begin_src c
    void export_jo() {
      define_prim("null", p_null);

      define_prim("jo-filter-stack-push", p_jo_filter_stack_push);
      define_prim("jo-filter-stack-pop", p_jo_filter_stack_pop);

      define_prim("alias-push", p_alias_push);
      define_prim("alias-filter", p_alias_filter);

      define_prim("has-jo?", p_has_jo_p);

      define_prim("read/raw-jo", p_read_raw_jo);
      define_prim("read/jo", p_read_jo);
      define_primkey("jo", k_jo);
      define_primkey("raw-jo", k_raw_jo);

      define_prim("jo/used?", p_jo_used_p);
      define_prim("jo/append", p_jo_append);
      define_prim("empty-jo", p_empty_jo);
      define_prim("jo->string", p_jo_to_string);
      define_prim("string->jo", p_string_to_jo);
      define_prim("string/length->jo", p_string_length_to_jo);
      define_prim("jo/print", p_jo_print);
      define_prim("jo/dot", p_jo_dot);
      define_prim("generate-jo", p_generate_jo);

      define_prim("jo/find-byte", p_jo_find_byte);
      define_prim("jo/left-part", p_jo_left_part);
      define_prim("jo/right-part", p_jo_right_part);
      define_prim("jo/part", p_jo_part);
    }
    #+end_src

* *file*

*** p_open_for_reading

    #+begin_src c
    void p_open_for_reading() {
      string pathname = as_pop();
      FILE* fd = open(pathname, O_RDONLY);
      if (fd == -1) {
        perror("- p_open_for_reading fail\n");
      }
      as_push(fd);
    }
    #+end_src

*** file_readable_p

    #+begin_src c
    bool file_readable_p(string path) {
      FILE* fp = fopen(path, "r");
      if (!fp) {
        return false;
      }
      else {
        fclose(fp);
        return true;
      }
    }
    #+end_src

*** p_file_readable_p

    #+begin_src c
    void p_file_readable_p() {
      // (path -> bool)
      as_push(file_readable_p(as_pop()));
    }
    #+end_src

*** dir_ok_p

    #+begin_src c
    bool dir_ok_p(string path) {
      DIR* dir = opendir(path);
      if (!dir) {
        return false;
      }
      else {
        closedir(dir);
        return true;
      }
    }
    #+end_src

*** p_dir_ok_p

    #+begin_src c
    void p_dir_ok_p() {
      // (dir -> bool)
      as_push(dir_ok_p(as_pop()));
    }
    #+end_src

*** file_size

    - abstract "struct stat" out

    #+begin_src c
    cell file_size(string file_name) {
      struct stat st;
      stat(file_name, &st);
      return st.st_size;
    }
    #+end_src

*** p_file_size

    #+begin_src c
    void p_file_size() {
      as_push(file_size(as_pop()));
    }
    #+end_src

*** p_file_copy_to_buffer

    #+begin_src c
    void p_file_copy_to_buffer() {
      // (file-name addr -> number)
      cell buffer = as_pop();
      cell path = as_pop();
      cell limit = file_size(path);
      FILE* fp = fopen(path, "r");
      if(!fp) {
        printf("- p_file_copy_to_buffer file to open file : %s\n", path);
        perror("  ");
        as_push(0);
        return;
      }
      cell read_counter = fread(buffer, 1, limit, fp);
      fclose(fp);
      as_push(read_counter);
    }
    #+end_src

*** load_file

    #+begin_src c
    void load_file(string path) {
      // [reading_stack]
      FILE* fp = fopen(path, "r");
      if(!fp) {
        perror("File opening failed");
        printf("load_file fail : %s\n", path);
        return;
      }
      char* file_buffer = malloc(PATH_MAX);
      char* dir_buffer = malloc(PATH_MAX);
      realpath(path, file_buffer);
      realpath(path, dir_buffer);
      char* dir_addr = dirname(dir_buffer);
      reading_point rp = {
        .file_handle = fp,
        .file = file_buffer,
        .dir = dir_addr
      };
      reading_stack_push(rp);

      // {
      //   printf("- load_file start\n");
      //   printf("  fp: %d\n", fp);
      //   printf("  file: %s\n", file_buffer);
      //   printf("  dir_buffer: %s #%ld\n", dir_buffer, dir_buffer);
      //   printf("  dir_addr: %s #%ld\n", dir_addr, dir_addr);
      // }

      p_top_repl();

      reading_stack_pop();
      fclose(rp.file_handle);
      free(rp.file);
      free(rp.dir);

      // {
      //   printf("- load_file finished\n");
      //   printf("  fp: %d\n", fp);
      //   printf("  file: %s\n", file_buffer);
      //   printf("  dir_buffer: %s #%ld\n", dir_buffer, dir_buffer);
      //   printf("  dir_addr: %s #%ld\n", dir_addr, dir_addr);
      // }
    }
    #+end_src

*** p_load_file

    #+begin_src c
    void p_load_file() {
      load_file(as_pop());
    }
    #+end_src

*** k_include_one

    #+begin_src c
    void k_include_one() {
      // ([io] -> *)
      char buffer[PATH_MAX];
      cell cursor = 0;
      while (true) {
        char c = read_byte();
        if (c == '"') {
          buffer[cursor] = 0;
          cursor++;
          break;
        }
        else {
          buffer[cursor] = c;
          cursor++;
        }
      }
      char buffer1[PATH_MAX];
      real_reading_path(buffer, buffer1);
      load_file(buffer1);
    }
    #+end_src

*** k_include

    #+begin_src c
    void k_include() {
      // ([io] -> [compile])
      while (true) {
        jo s = read_raw_jo();
        if (s == ROUND_KET) {
          return;
        }
        else if (s == ROUND_BAR) {
          jo_apply(read_jo());
        }
        else if (s == DOUBLE_QUOTE) {
          k_include_one();
        }
        else {
          // do nothing
        }
      }
    }
    #+end_src

*** export_file

    #+begin_src c
    void export_file() {
      define_prim("open-for-reading", p_open_for_reading);
      define_prim("file/readable?", p_file_readable_p);
      define_prim("dir/ok?", p_dir_ok_p);
      define_prim("file/size", p_file_size);
      define_prim("file/copy-to-buffer", p_file_copy_to_buffer);

      define_prim("load-file", p_load_file);

      define_primkey("include", k_include);
    }
    #+end_src

* *system*

*** p_current_dir

    #+begin_src c
    void p_current_dir() {
      // (-> string)
      char buf[1024];
      as_push(getcwd(buf, 1024));
    }
    #+end_src

*** p_command_run

    #+begin_src c
    void p_command_run() {
      // (string -> *)
      system(as_pop());
    }
    #+end_src

*** p_n_command_run

    #+begin_src c
    void p_n_command_run() {
      // (..., string, n -> *)
      cell n = as_pop();
      cell i = 0;
      string str = malloc(4 * 1024);
      str[0] = 0;
      while (i < n) {
        strcat(str, as[as_pointer - n + i]);
        i++;
      }
      as_pointer = as_pointer - n;
      system(str);
      free(str);
    }
    #+end_src

*** p_argument_counter

    #+begin_src c
    cell argument_counter;

    void p_argument_counter() {
      // (-> argument_counter)
      as_push(argument_counter);
    }
    #+end_src

*** p_index_to_argument_string

    #+begin_src c
    string* argument_string_array;

    void p_index_to_argument_string() {
      // (index -> string)
      cell index = as_pop();
      string argument_string = argument_string_array[index];
      as_push(argument_string);
    }
    #+end_src

*** p_get_env_string

    #+begin_src c
    void p_get_env_string() {
      // (string -> string)
      string var_string = as_pop();
      string env_string = getenv(var_string);
      as_push(env_string);
    }
    #+end_src

*** export_system

    #+begin_src c
    void export_system() {
      define_prim("current-dir", p_current_dir);
      define_prim("command/run", p_command_run);
      define_prim("n-command/run", p_n_command_run);
      define_prim("argument-counter", p_argument_counter);
      define_prim("index->argument-string", p_index_to_argument_string);
      define_prim("get-env-string", p_get_env_string);
    }
    #+end_src

* *cffi*

*** ccall

    #+begin_src c
    void ccall (string str, void* lib) {
      primitive fun = dlsym(lib, str);
      if (fun == NULL) {
        printf("can not find %s function lib : %s\n",
               str, dlerror());
      };
      fun();
    }
    #+end_src

*** get_clib

    #+begin_src c
    void* get_clib(string rel_path) {
      char path[PATH_MAX];
      real_reading_path(rel_path, path);
      void* lib = dlopen(path, RTLD_LAZY);
      if (lib == NULL) {
        printf("fail to open library : %s : %s\n",
               path, dlerror());
      };
      return lib;
    }
    #+end_src

*** k_clib_one

    #+begin_src c
    void k_clib_one() {
      // ([io] -> [compile])
      char buffer[PATH_MAX];
      cell cursor = 0;
      while (true) {
        char c = read_byte();
        if (c == '"') {
          buffer[cursor] = 0;
          cursor++;
          break;
        }
        else {
          buffer[cursor] = c;
          cursor++;
        }
      }
      ccall("export", get_clib(buffer));
    }
    #+end_src

*** k_clib

    #+begin_src c
    void k_clib() {
      // ([io] -> [compile])
      while (true) {
        jo s = read_raw_jo();
        if (s == ROUND_KET) {
          return;
        }
        else if (s == DOUBLE_QUOTE) {
          k_clib_one();
        }
        else {
          // do nothing
        }
      }
    }
    #+end_src

*** export_cffi

    #+begin_src c
    void export_cffi() {
      define_prim("clib", k_clib);
    }
    #+end_src

* *top_level*

*** k_define

    #+begin_src c
    void k_define() {
      jo name = read_jo();
      k_run();
      as_push(name);
      p_bind_name();
    }
    #+end_src

*** k_declare

***** note

      - no compile before define
        declare helps mutual recursive function

***** k_declare_one

      #+begin_src c
      void k_declare_one() {
        jo index = read_jo();
        jotable[index].tag = JO_DECLARED;
        k_ignore();
      }
      #+end_src

***** k_declare

      #+begin_src c
      void k_declare() {
        while (true) {
          jo s = read_jo();
          if (s == ROUND_KET) {
            return;
          }
          else if (s == ROUND_BAR) {
            k_declare_one();
          }
          else {
            // do nothing
          }
        }
      }
      #+end_src

*** k_run

    #+begin_src c
    void p_compile_jojo();

    void k_run() {
      // ([io] -> *)
      jo* jojo = compiling_stack_tos();
      p_compile_jojo();
      rs_new_point(jojo);
      eval();
    }
    #+end_src

*** testing_flag

    #+begin_src c
    bool testing_flag = false;
    void p_testing_flag() { as_push(testing_flag); }
    void p_testing_flag_on() { testing_flag = true; }
    void p_testing_flag_off() { testing_flag = false; }
    #+end_src

*** about test

    #+begin_src c
    void k_test() {
      if (testing_flag) {
        k_run();
      }
      else {
        k_ignore();
      }
    }
    #+end_src

*** p_top_repl

    #+begin_src c
    bool top_repl_printing_flag = false;

    void p_as_print_by_flag() {
      if (top_repl_printing_flag) {
        p_as_print();
      }
    }

    void p_top_repl() {
      while (true) {
        if (!has_jo_p()) {
          return;
        }
        jo s = read_jo();
        if (s == ROUND_BAR) {
          jo_apply(read_jo());
          p_as_print_by_flag();
        }
        else {
          // loop
        }
      }
    }
    #+end_src

*** p_top_repl_printing_flag

    #+begin_src c
    void p_top_repl_printing_flag() { as_push(top_repl_printing_flag); }
    void p_top_repl_printing_flag_on() { top_repl_printing_flag = true; }
    void p_top_repl_printing_flag_off() { top_repl_printing_flag = false; }
    #+end_src

*** export_top_level

    #+begin_src c
    void export_top_level() {
      define_primkey("define", k_define);
      define_primkey("bind-name", p_bind_name);
      define_primkey("declare", k_declare);

      define_primkey("run", k_run);

      define_primkey("test", k_test);
      define_prim("testing-flag", p_testing_flag);
      define_prim("testing-flag/on", p_testing_flag_on);
      define_prim("testing-flag/off", p_testing_flag_off);


      define_prim("as/print-by-flag", p_as_print_by_flag);
      define_prim("top-repl", p_top_repl);
      define_prim("top-repl/printing-flag", p_top_repl_printing_flag);
      define_prim("top-repl/printing-flag/on", p_top_repl_printing_flag_on);
      define_prim("top-repl/printing-flag/off", p_top_repl_printing_flag_off);
    }
    #+end_src

* *keyword*

*** k_ignore

    #+begin_src c
    void k_ignore() {
      // ([io] ->)
      while (true) {
        jo s = read_raw_jo();
        if (s == ROUND_BAR) {
          k_ignore();
        }
        if (s == ROUND_KET) {
          break;
        }
      }
    }
    #+end_src

*** compile_until_meet_jo

    #+begin_src c
    void compile_until_meet_jo(jo ending_jo) {
      // ([io] -> [compile])
      while (true) {
        jo s = read_jo();
        if (s == ROUND_BAR) {
          jo_apply(read_jo());
        }
        else if (s == ending_jo) {
          break;
        }
        else if (jotable_entry_used(jotable[s])) {
          here(s);
        }
        else {
          // no compile before define
          printf("- compile_until_meet_jo undefined : %s\n", jo2str(s));
          k_ignore();
          return;
        }
      }
    }
    #+end_src

*** p_compile_until_meet_jo

    #+begin_src c
    void p_compile_until_meet_jo() {
      // (jo -> [compile])
      compile_until_meet_jo(as_pop());
    }
    #+end_src

*** compile_until_meet_jo_or_jo

    #+begin_src c
    jo compile_until_meet_jo_or_jo(jo ending_jo1, jo ending_jo2) {
      while (true) {
        jo s = read_jo();
        if (s == ROUND_BAR) {
          jo_apply(read_jo());
        }
        else if (s == ending_jo1 || s == ending_jo2) {
          return s;
        }
        else if (jotable_entry_used(jotable[s])) {
          here(s);
        }
        else {
          // no compile before define
          printf("- compile_until_meet_jo_or_jo undefined : %s\n", jo2str(s));
          printf("- ending_jo1 : %s\n", jo2str(ending_jo1));
          printf("- ending_jo2 : %s\n", jo2str(ending_jo2));
          k_ignore();
          return;
        }
      }
    }
    #+end_src

*** p_compile_until_round_ket

    #+begin_src c
    void p_compile_until_round_ket() {
      // ([io] -> [compile])
      compile_until_meet_jo(ROUND_KET);
    }
    #+end_src

*** k_if

    #+begin_src c
    // - without else
    //   (if a b p? then c d)
    //   ==>
    //     a b p?
    //     jump_if_false[:end-of-then]
    //     c d
    //   :end-of-then

    // - with else
    //   (if a b p? then c d else e f)
    //   ==>
    //     a b p?
    //     jump_if_false[:end-of-then]
    //     c d
    //     jump[:end-of-else]
    //   :end-of-then
    //     e f
    //   :end-of-else

    void k_if() {
      // ([io] -> [compile])
      compile_until_meet_jo(JO_THEN);
      here(JO_INS_JUMP_IF_FALSE);
      cell* end_of_then = compiling_stack_tos();
      compiling_stack_inc();
      jo ending_jo = compile_until_meet_jo_or_jo(JO_ELSE, ROUND_KET);
      if (ending_jo == ROUND_KET) {
        end_of_then[0] = compiling_stack_tos();
        return;
      }
      else {
        here(JO_INS_JUMP);
        cell* end_of_else = compiling_stack_tos();
        compiling_stack_inc();
        end_of_then[0] = compiling_stack_tos();
        p_compile_until_round_ket();
        end_of_else[0] = compiling_stack_tos();
        return;
      }
    }
    #+end_src

*** k_tail_call

    #+begin_src c
    void k_tail_call() {
      // no check for "no compile before define"
      here(JO_INS_INT);
      here(read_jo());
      here(JO_JO_REPLACING_APPLY_WITH_LAST_LOCAL_POINTER);
      k_ignore();
    }
    #+end_src

*** current_compiling_jojo_stack

    #+begin_src c
    typedef jo current_compiling_jojo_stack_t[1024];

    current_compiling_jojo_stack_t current_compiling_jojo_stack;
    cell current_compiling_jojo_stack_base = 0;
    cell current_compiling_jojo_stack_pointer = 0;

    void current_compiling_jojo_stack_push(jo* value) {
      current_compiling_jojo_stack[current_compiling_jojo_stack_pointer] = value;
      current_compiling_jojo_stack_pointer++;
    }

    jo* current_compiling_jojo_stack_pop() {
      current_compiling_jojo_stack_pointer--;
      return current_compiling_jojo_stack[current_compiling_jojo_stack_pointer];
    }

    void current_compiling_jojo_stack_inc() {
      current_compiling_jojo_stack[current_compiling_jojo_stack_pointer - 1] =
        current_compiling_jojo_stack[current_compiling_jojo_stack_pointer - 1] + 1;
    }


    jo* current_compiling_jojo_stack_tos() {
      return current_compiling_jojo_stack[current_compiling_jojo_stack_pointer - 1];
    }

    bool current_compiling_jojo_stack_empty_p() {
      return current_compiling_jojo_stack_pointer == current_compiling_jojo_stack_base;
    }
    #+end_src

*** p_compile_jojo

    #+begin_src c
    void p_compile_jojo() {
      // ([io] -> [compile])
      jo* jojo = compiling_stack_tos();
      current_compiling_jojo_stack_push(jojo);
      compile_until_meet_jo(ROUND_KET);
      here(JO_END);
      current_compiling_jojo_stack_pop();
    }
    #+end_src

*** k_loop

    #+begin_src c
    void k_loop() {
      here(JO_INS_INT);
      here(current_compiling_jojo_stack_tos());
      here(JO_REPLACING_APPLY_WITH_LAST_LOCAL_POINTER);
      k_ignore();
    }
    #+end_src

*** k_recur

    #+begin_src c
    void k_recur() {
      here(JO_INS_INT);
      here(current_compiling_jojo_stack_tos());
      here(JO_APPLY);
      k_ignore();
    }
    #+end_src

*** p_compiling_stack_tos

    #+begin_src c
    void p_compiling_stack_tos() {
      as_push(compiling_stack_tos());
    }
    #+end_src

*** k_bare_jojo

    #+begin_src c
    void k_bare_jojo() {
      // ([io] -> [compile])
      here(JO_INS_JUMP);
      cell* offset_place = compiling_stack_tos();
      compiling_stack_inc();
      p_compile_jojo();
      offset_place[0] = compiling_stack_tos();
      here(JO_INS_INT);
      here(offset_place + 1);
    }
    #+end_src

*** k_jojo

    #+begin_src c
    void k_jojo() {
      // ([io] -> [compile])
      here(JO_INS_JUMP);
      cell* offset_place = compiling_stack_tos();
      compiling_stack_inc();
      p_compile_jojo();
      offset_place[0] = compiling_stack_tos();
      here(JO_INS_INT);
      here(offset_place + 1);
      here(JO_INS_INT);
      here(TAG_JOJO);
    }
    #+end_src

*** k_keyword

    #+begin_src c
    void k_keyword() {
      // ([io] -> [compile])
      here(JO_INS_JUMP);
      cell* offset_place = compiling_stack_tos();
      compiling_stack_inc();
      p_compile_jojo();
      offset_place[0] = compiling_stack_tos();
      here(JO_INS_INT);
      here(offset_place + 1);
      here(JO_INS_INT);
      here(TAG_KEYWORD);
    }
    #+end_src

*** k_data

    #+begin_src c
    void k_data() {
      // ([io] -> [compile])
      p_compile_until_round_ket();
      here(JO_INS_INT);
      here(TAG_DATA);
    }
    #+end_src

*** local_find

    #+begin_src c
    cell local_find(jo name) {
      // return index of local_area
      // -1 -- no found
      return_point rp = rs_tos();
      cell cursor = current_local_pointer - 1;
      while (cursor >= rp.local_pointer) {
        if (local_area[cursor].name == name) {
          return cursor;
        }
        else {
          cursor--;
        }
      }
      return -1;
    }
    #+end_src

*** p_local_data_in

    #+begin_src c
    void p_local_data_in() {
      cell jo = as_pop();
      cell index = local_find(jo);
      cell data = as_pop();
      if (index != -1) {
        local_area[index].name = jo;
        local_area[index].local_data = data;
      }
      else {
        local_area[current_local_pointer].name = jo;
        local_area[current_local_pointer].local_data = data;
        current_local_pointer = current_local_pointer + 1;
      }
    }
    #+end_src

*** p_local_data_out

    #+begin_src c
    void p_local_data_out() {
      cell jo = as_pop();
      cell index = local_find(jo);
      if (index != -1) {
        local_point lp = local_area[index];
        as_push(lp.local_data);
      }
      else {
        printf("- p_local_data_out fatal error\n");
        printf("  name is not bound\n");
        printf("  name : %s\n", jo2str(jo));
      }
    }
    #+end_src

*** p_local_tag_in

    #+begin_src c
    void p_local_tag_in() {
      cell jo = as_pop();
      cell index = local_find(jo);
      cell tag = as_pop();
      if (index != -1) {
        local_area[index].name = jo;
        local_area[index].local_tag = tag;
      }
      else {
        local_area[current_local_pointer].name = jo;
        local_area[current_local_pointer].local_tag = tag;
        current_local_pointer = current_local_pointer + 1;
      }
    }
    #+end_src

*** p_local_tag_out

    #+begin_src c
    void p_local_tag_out() {
      cell jo = as_pop();
      cell index = local_find(jo);
      if (index != -1) {
        local_point lp = local_area[index];
        as_push(lp.local_tag);
      }
      else {
        printf("- p_local_tag_out fatal error\n");
        printf("  name is not bound\n");
        printf("  name : %s\n", jo2str(jo));
      }
    }
    #+end_src

*** p_local_in

    #+begin_src c
    void p_local_in() {
      cell jo = as_pop();
      cell index = local_find(jo);
      cell tag = as_pop();
      cell data = as_pop();
      if (index != -1) {
        local_area[index].name = jo;
        local_area[index].local_tag = tag;
        local_area[index].local_data = data;
      }
      else {
        local_area[current_local_pointer].name = jo;
        local_area[current_local_pointer].local_tag = tag;
        local_area[current_local_pointer].local_data = data;
        current_local_pointer = current_local_pointer + 1;
      }
    }
    #+end_src

*** p_local_out

    #+begin_src c
    void p_local_out() {
      cell jo = as_pop();
      cell index = local_find(jo);
      if (index != -1) {
        local_point lp = local_area[index];
        as_push(lp.local_data);
        as_push(lp.local_tag);
      }
      else {
        printf("- p_local_out fatal error\n");
        printf("  name is not bound\n");
        printf("  name : %s\n", jo2str(jo));
      }
    }
    #+end_src

*** k_local_data_in

    #+begin_src c
    void k_local_data_in() {
      jo s = read_raw_jo();
      if (s == ROUND_KET) {
        return;
      }
      else {
        k_local_data_in();

        here(JO_INS_INT);
        here(s);
        here(JO_LOCAL_DATA_IN);
      }
    }
    #+end_src

*** k_local_data_out

    #+begin_src c
    void k_local_data_out() {
      jo s = read_raw_jo();
      if (s == ROUND_KET) {
        return;
      }
      else {
        here(JO_INS_INT);
        here(s);
        here(JO_LOCAL_DATA_OUT);

        k_local_data_out();
      }
    }
    #+end_src

*** k_local_tag_in

    #+begin_src c
    void k_local_tag_in() {
      jo s = read_raw_jo();
      if (s == ROUND_KET) {
        return;
      }
      else {
        k_local_data_in();

        here(JO_INS_INT);
        here(s);
        here(JO_LOCAL_TAG_IN);
      }
    }
    #+end_src

*** k_local_tag_out

    #+begin_src c
    void k_local_tag_out() {
      jo s = read_raw_jo();
      if (s == ROUND_KET) {
        return;
      }
      else {
        here(JO_INS_INT);
        here(s);
        here(JO_LOCAL_TAG_OUT);

        k_local_data_out();
      }
    }
    #+end_src

*** k_local_in

    #+begin_src c
    void k_local_in() {
      jo s = read_raw_jo();
      if (s == ROUND_KET) {
        return;
      }
      else {
        k_local_data_in();

        here(JO_INS_INT);
        here(s);
        here(JO_LOCAL_IN);
      }
    }
    #+end_src

*** k_local_out

    #+begin_src c
    void k_local_out() {
      jo s = read_raw_jo();
      if (s == ROUND_KET) {
        return;
      }
      else {
        here(JO_INS_INT);
        here(s);
        here(JO_LOCAL_OUT);

        k_local_data_out();
      }
    }
    #+end_src

*** p_current_local_pointer

    #+begin_src c
    void p_current_local_pointer() {
      as_push(current_local_pointer);
    }
    #+end_src

*** export_keyword

    #+begin_src c
    void export_keyword() {
      define_primkey("ignore", k_ignore);
      define_primkey("note", k_ignore);

      define_prim("compiling-stack/tos", p_compiling_stack_tos);
      define_prim("compiling-stack/inc", compiling_stack_inc);

      define_primkey("if", k_if);
      define_prim("compile-until-meet-jo", p_compile_until_meet_jo);
      define_prim("compile-until-round-ket", p_compile_until_round_ket);

      define_primkey("else", p_compile_until_round_ket);
      define_primkey("el", p_compile_until_round_ket);

      define_prim("compile-jojo", p_compile_jojo);

      define_primkey("tail-call", k_tail_call);
      define_primkey("loop", k_loop);
      define_primkey("recur", k_recur);

      define_primkey("data", k_data);
      define_primkey("jojo", k_jojo);
      define_primkey("keyword", k_keyword);

      define_primkey("bare-jojo", k_bare_jojo);

      define_prim("local-data-in", p_local_data_in);
      define_prim("local-data-out", p_local_data_out);
      define_primkey(">", k_local_data_in);
      define_primkey("<", k_local_data_out);

      define_prim("local-tag-in", p_local_tag_in);
      define_prim("local-tag-out", p_local_tag_out);
      define_primkey("%>", k_local_tag_in);
      define_primkey("<%", k_local_tag_out);

      define_prim("local-in", p_local_in);
      define_prim("local-out", p_local_out);
      define_primkey(">>", k_local_in);
      define_primkey("<<", k_local_out);

      define_prim("current-local-pointer", p_current_local_pointer);
    }
    #+end_src

* *misc*

*** do_nothing

    #+begin_src c
    void do_nothing() {
    }
    #+end_src

*** p_here

    #+begin_src c
    void p_here() {
      here(as_pop());
    }
    #+end_src

*** p_address_of_here

    #+begin_src c
    void p_address_of_here() {
     as_push(compiling_stack_tos());
    }
    #+end_src

*** bar and ket

    #+begin_src c
    void p_round_bar()    { as_push(ROUND_BAR); }
    void p_round_ket()    { as_push(ROUND_KET); }
    void p_square_bar()   { as_push(SQUARE_BAR); }
    void p_square_ket()   { as_push(SQUARE_KET); }
    void p_flower_bar()   { as_push(FLOWER_BAR); }
    void p_flower_ket()   { as_push(FLOWER_KET); }
    void p_double_quote() { as_push(DOUBLE_QUOTE); }
    #+end_src

*** p_cell_size

    #+begin_src c
    void p_cell_size() {
      // (-> cell)
      as_push(cell_size);
    }
    #+end_src

*** p_newline

    #+begin_src c
    void p_newline() {
      printf("\n");
    }
    #+end_src

*** export_mise

    #+begin_src c
    void export_mise() {
      define_prim("here", p_here);
      define_prim("address-of-here", p_address_of_here);

      define_prim("jotable/report", jotable_report);

      define_prim("round-bar", p_round_bar);
      define_prim("round-ket", p_round_ket);
      define_prim("square-bar", p_square_bar);
      define_prim("square-ket", p_square_ket);
      define_prim("flower-bar", p_flower_bar);
      define_prim("flower-ket", p_flower_ket);
      define_prim("double-quote", p_double_quote);

      define_prim("cell-size", p_cell_size);

      define_prim("newline", p_newline);
    }
    #+end_src

* *play*

*** p1

    #+begin_src c
    void p1() {
      printf("- p1\n");
      printf("  %ld %ld %ld\n", sizeof(void*), cell_size, sizeof(unsigned));
      printf("  %ld %ld\n", sizeof((cell)-1), sizeof(-1));
      printf("  %x %x\n", 1<<cell_size, 32>>6);
      printf("  %x %x %x\n", -1>>2, (cell)-1>>2, (unsigned)-1>>2);
      printf("  %ld %ld\n", string_to_bin("1000"), string_to_hex("ffff"));
      printf("  %ld %ld %ld %ld\n", '0', '1', 'A', 'a');

      printf("  %ld\n", EOF);
      printf("  %ld\n", PATH_MAX);

      struct stat st;
      stat("READM", &st);
      printf("  file-size of README : %ld\n", st.st_size);
      printf("  sizeof &st : %ld\n", sizeof(&st));
      printf("  sizeof st : %ld\n", sizeof(st));
    }
    #+end_src

*** p2

    #+begin_src c
    void p2() {
      printf("- p2\n");
      printf("  sizeof local_point : %ld\n", sizeof(local_point));
      printf("  sizeof local_area : %ld\n", sizeof(local_area));
      printf("  sizeof EOF : %ld\n", sizeof(EOF));
      printf("  sizeof byte : %ld\n", sizeof(byte));
      printf("  EOF as number : %ld\n", EOF);
    }
    #+end_src

*** p3

    #+begin_src c
    cell string_to_sum_test(string str) {
      cell sum = 0;
      cell max_step = 10;
      cell i = 0;
      while (i < strlen(str)) {
        sum = sum + ((unsigned char) str[i]) * (2 << min(i, max_step));
        printf("| char: %ld | unsigned char: %ld | sum: %ld |\n", str[i], (unsigned char) str[i], sum);
        i++;
      }
      return sum;
    }

    void p3() {
      printf("- p3\n");
      printf("  %ld\n", string_to_sum_test("abcabcabc"));
      printf("  %ld\n", string_to_sum_test("中中"));
      printf("  %ld\n", string_to_sum_test("中中中"));
    }
    #+end_src

*** export_play

    #+begin_src c
    void export_play() {
      define_prim("p1", p1);
      define_prim("p2", p2);
      define_prim("p3", p3);
    }
    #+end_src

* main

*** init_jotable

    #+begin_src c
    jotable_entry proto_jotable_entry(cell index) {
      jotable_entry e = {
        .index = index,
        .key = 0,
        .tag = str2jo("not-used"),
        .value = 0,
        .orbit_length = 0,
        .orbiton = 0
      };
      return e;
    }

    void init_jotable() {
      cell i = 0;
      while (i < jotable_size) {
        jotable[i] = proto_jotable_entry(i);
        i++;
      }
    }
    #+end_src

*** init_literal_jo

    #+begin_src c
    void init_literal_jo() {
      EMPTY_JO = str2jo("");

      TAG_PRIM         = str2jo("<prim>");
      TAG_JOJO         = str2jo("<jojo>");
      TAG_PRIM_KEYWORD = str2jo("<prim-keyword>");
      TAG_KEYWORD      = str2jo("<keyword>");
      TAG_DATA         = str2jo("<data>");

      JO_NOT_USED = str2jo("not-used");
      JO_DECLARED = str2jo("declared");

      ROUND_BAR    =   str2jo("(");
      ROUND_KET    =   str2jo(")");
      SQUARE_BAR   =   str2jo("[");
      SQUARE_KET   =   str2jo("]");
      FLOWER_BAR   =   str2jo("{");
      FLOWER_KET   =   str2jo("}");
      DOUBLE_QUOTE =   str2jo("\"");

      JO_INS_INT  = str2jo("ins/lit");
      JO_INS_JUMP = str2jo("ins/jump");
      JO_INS_JUMP_IF_FALSE = str2jo("ins/jump-if-false");

      JO_NULL     = str2jo("null");
      JO_THEN     = str2jo("then");
      JO_ELSE     = str2jo("else");

      JO_APPLY     = str2jo("apply");
      JO_END       = str2jo("end");

      JO_JO_REPLACING_APPLY_WITH_LAST_LOCAL_POINTER = str2jo("jo/replacing-apply-with-last-local-pointer");
      JO_REPLACING_APPLY_WITH_LAST_LOCAL_POINTER = str2jo("replacing-apply-with-last-local-pointer");

      JO_LOCAL_DATA_IN = str2jo("local-data-in");
      JO_LOCAL_DATA_OUT = str2jo("local-data-out");

      JO_LOCAL_TAG_IN = str2jo("local-tag-in");
      JO_LOCAL_TAG_OUT = str2jo("local-tag-out");

      JO_LOCAL_IN = str2jo("local-in");
      JO_LOCAL_OUT = str2jo("local-out");
    }
    #+end_src

*** init_top_repl

    #+begin_src c
    void init_top_repl() {

      init_jotable();
      init_literal_jo();

      init_compiling_stack();
      init_jo_filter_stack();

      p_empty_jo();
      p_drop();

      export_bind();
      export_apply();
      export_stack_operation();
      export_ending();
      export_control();
      export_bool();
      export_bit();
      export_int();
      export_memory();
      export_byte();
      export_jo();
      export_string();
      export_file();
      export_keyword();
      export_system();
      export_cffi();
      export_top_level();
      export_mise();
      export_play();
    }
    #+end_src

*** main

    #+begin_src c
    int main(int argc, string* argv) {
      argument_counter = argc;
      argument_string_array = argv;

      init_top_repl();

      if (argc != 1) {
        if (file_readable_p(argv[1])) {
          load_file(argv[1]);
        }
        else {
          printf("- jojo can not load file: %s\n", argv[1]);
          printf("  it is not readable\n");
          return 69;
        }
      }

      p_top_repl();
    }
    #+end_src
