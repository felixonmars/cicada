#+property: tangle libjojo.c
#+title:  jojo

- rebind-name and redefine
  also defined?

- trace and untrace a jo

- fix to let step-ed function be used in file

* todo

  - delimited continuation
    to control return_stack [and data_stack]

  - concurrent
    use list to implement return_stack and data_stack in jojo
    thus each group of stacks is a light weight process

* note

*** interface convention

    - before trying to get something from somewhere,
      first ask if it is there at all.

    - this convention can only be used
      when condition race will not occur,
      or when condition race is not important.

*** important common sense

    - all programs are changings of state of machine

    - syntax-checker, type-checker, compiler are all special interpreters

*** threaded code interpreter

    - types of threaded code interpreter :
      1. indirect threaded code
      2. direct threaded code
      3. token threaded code
      4. subroutine threaded code
      5. dynamic threaded code
         [jotable] [symbol-hash-table [of lisp]]

    - overhead of eval
      base_pointer test [to be able to return to c function]
      step_flag test

    - overhead of jo_apply
      dispatching [dynamic threaded code]

*** possible static type system

    - type comment in jojo and c code :
      1. change of data_stack -- [...] -> [...]
      2. other effect -- {}
         which can occur in any position in a type comment

    - the type comment in the code suggest a static type system.

      a static type system
      and a compiled verison of jojo
      might be implemented,

      but an untyped and a dynamic typed level are also important.

*** levels of languages

    1. untyped -- ffi to c [thus as low as c]
    2. dynamic typed -- debug and test
    3. static typed
    4. logic
    5. concurrent
    6. dependent type -- type as proof
    7. algebraic topology and combinatorial topology

*** apply and scope

    - apply will create new scope of local names.

    - thus
      p_compile_jojo will create new scope of local names.

    - by the following we can add pre-setted name to a scope :
      current-local-pointer swap
      (< data) (< tag) (jo self) local-in
      apply-with-local-pointer

    - but we can not use old names in the scope outside this scope.

*** limits

    | name                 | length      | unit          |
    |----------------------+-------------+---------------|
    | string_area          | 1024 * 1024 | byte          |
    | jotable              | 97 * 1024   | jotable_entry |
    | compiling_stack      | 1024        | jo*           |
    | jojo_area            | 1024 * 1024 | jo            |
    |----------------------+-------------+---------------|
    | data_stack           | 4 * 1024    | cell          |
    | return_stack         | 4 * 1024    | return_point  |
    | local_area           | 1024 * 1024 | local_point   |
    |----------------------+-------------+---------------|
    | name_record          | 16 * 1024   | jo            |
    | binding_filter_stack | 128         | jo            |
    | keyword_stack        | 128         | jo            |
    | alias_stack          | 1024        | alias         |
    | reading_stack        | 64          | FILE*         |
    | jo_filter_stack      | 128         | jo            |

* header

  #+begin_src c
  #include <sys/types.h>
  #include <sys/stat.h>
  #include <unistd.h>
  #include <stdio.h>
  #include <stdlib.h>
  #include <errno.h>
  #include <string.h>
  #include <fcntl.h>
  #include <ctype.h>
  #include <stdint.h>
  #include <dlfcn.h>
  #include <dirent.h>
  #include <signal.h>
  #include <limits.h>
  #+end_src

* type

  #+begin_src c
  typedef enum { false, true } bool;
  typedef intptr_t cell;
  typedef unsigned char byte;
  typedef void (*primitive)();

  #define CELL_SIZE (sizeof(cell))
  #+end_src

* utility

*** int

    #+begin_src c
    cell max(cell a, cell b) {
      if (a < b) {
        return b;
      }
      else {
        return a;
      }
    }

    cell min(cell a, cell b) {
      if (a > b) {
        return b;
      }
      else {
        return a;
      }
    }

    cell power(cell a, cell n) {
      cell result = 1;
      while (n >= 1) {
        result = result * a;
        n--;
      }
      return result;
    }
    #+end_src

*** char

    #+begin_src c
    bool isbarcket(char c) {
      return (c == '(' ||
              c == ')' ||
              c == '[' ||
              c == ']' ||
              c == '{' ||
              c == '}' ||
              c == '"');
    }
    #+end_src

*** char_to_nat

    #+begin_src c
    cell char_to_nat(char c) {
      if (c >= '0' && c <= '9') {
        return (c - '0');
      }
      else if (c >= 'A' && c <= 'Z') {
        return (c - 'A') + 10;
      }
      else if (c >= 'a' && c <= 'z') {
        return (c - 'a') + 10;
      }
      else {
        return 0;
      }
    }
    #+end_src

*** string

***** string_equal

      #+begin_src c
      bool string_equal(char* s1, char* s2) {
        if (strcmp(s1, s2) == 0) {
          return true;
        }
        else {
          return false;
        }
      }
      #+end_src

***** nat_string_p

      #+begin_src c
      bool nat_string_p(char* str) {
        cell i = 0;
        while (str[i] != 0) {
          if (!isdigit(str[i])) {
            return false;
            }
          i++;
        }
        return true;
      }
      #+end_src

***** int_string_p

      #+begin_src c
      bool int_string_p(char* str) {
        if (str[0] == '-' ||
            str[0] == '+') {
          return nat_string_p(str + 1);
        }
        else {
          return nat_string_p(str);
        }
      }
      #+end_src

***** string_to_based_nat & string_to_based_int & string_to_int

      #+begin_src c
      cell string_to_based_nat(char* str, cell base) {
        cell result = 0;
        cell len = strlen(str);
        cell i = 0;
        while (i < len) {
          result = result + (char_to_nat(str[i]) * power(base, (len - i - 1)));
          i++;
        }
        return result;
      }

      cell string_to_based_int(char* str, cell base) {
        if (str[0] == '-') {
          return - string_to_based_nat(str, base);
        }
        else {
          return string_to_based_nat(str, base);
        }
      }

      cell string_to_int(char* str) { return string_to_based_int(str, 10); }
      #+end_src

* string_area

*** string_area

    #+begin_src c
    char string_area[1024 * 1024];
    cell string_area_counter = 0;
    #+end_src

*** copy_to_string_area

    #+begin_src c
    char* copy_to_string_area(char* str) {
      char *str1;
      cell i = 0;
      str1 = (string_area + string_area_counter);
      while (true) {
        if (str[i] == 0) {
          str1[i] = str[i];
          i++;
          break;
        }
        else {
          str1[i] = str[i];
          i++;
        }
      }
      string_area_counter = i + string_area_counter;
      return str1;
    }
    #+end_src

* jotable

*** type

    #+begin_src c
    typedef struct jo_entry {
      char *key;
      struct jo_entry *tag;
      cell value;
    } jotable_entry;

    typedef jotable_entry *jo;

    // prime table size
    //   1000003   about 976 k
    //   1000033
    //   1000333
    //   100003    about 97 k
    //   100333
    //   997
    #define jotable_size 100003
    jotable_entry jotable[jotable_size];

    // thus (jotable + index) is jo
    #+end_src

*** jotable_entry_[occured|entry_used|no_collision]

    #+begin_src c
    bool used_jo_p(jo jo) {
      return jo->tag != 0;
    }
    #+end_src

*** string_to_sum

    #+begin_src c
    cell string_to_sum(char* str) {
      cell sum = 0;
      cell max_step = 10;
      cell i = 0;
      while (i < strlen(str)) {
        sum = sum + ((byte) str[i]) * (2 << min(i, max_step));
        i++;
      }
      return sum;
    }
    #+end_src

*** jotable_hash

    #+begin_src c
    // a hash an index into jotable
    cell jotable_hash(cell sum, cell counter) {
      return (counter + sum) % jotable_size;
    }
    #+end_src

*** jotable_insert

    #+begin_src c
    p_debug();

    jo jotable_insert(char* key) {
      // in C : [string] -> [jo]
      cell sum = string_to_sum(key);
      cell counter = 0;
      while (true) {
        cell index = jotable_hash(sum, counter);
        jo jo = (jotable + index);
        if (jo->key == 0) {
          key = copy_to_string_area(key);
          jo->key = key;
          return jo;
        }
        else if (string_equal(key, jo->key)) {
          return jo;
        }
        else if (counter == jotable_size) {
          printf("- jotable_insert fail\n");
          printf("  the hash_table is filled\n");
          p_debug();
          return NULL;
        }
        else {
          counter++;
        }
      }
    }
    #+end_src

*** str2jo

    #+begin_src c
    jo str2jo(char* str) {
      return jotable_insert(str);
    }
    #+end_src

*** jo2str

    #+begin_src c
    char* jo2str(jo jo) {
      return jo->key;
    }
    #+end_src

*** literal jo

    #+begin_src c
    jo EMPTY_JO;
    jo TAG_PRIM;
    jo TAG_JOJO;
    jo TAG_PRIM_KEYWORD;
    jo TAG_KEYWORD;
    jo TAG_DATA;

    jo JO_DECLARED;

    jo ROUND_BAR;
    jo ROUND_KET;
    jo SQUARE_BAR;
    jo SQUARE_KET;
    jo FLOWER_BAR;
    jo FLOWER_KET;
    jo DOUBLE_QUOTE;

    jo JO_INS_INT;
    jo JO_INS_JO;
    jo JO_INS_STRING;
    jo JO_INS_BYTE;
    jo JO_INS_BARE_JOJO;
    jo JO_INS_ADDRESS;

    jo JO_INS_JUMP;
    jo JO_INS_JUMP_IF_FALSE;

    jo JO_INS_TAIL_CALL;
    jo JO_INS_LOOP;
    jo JO_INS_RECUR;

    jo JO_NULL;
    jo JO_THEN;
    jo JO_ELSE;

    jo JO_APPLY;
    jo JO_END;

    jo JO_LOCAL_DATA_IN;
    jo JO_LOCAL_DATA_OUT;

    jo JO_LOCAL_TAG_IN;
    jo JO_LOCAL_TAG_OUT;

    jo JO_LOCAL_IN;
    jo JO_LOCAL_OUT;
    #+end_src

* compiling_stack & here

*** compiling_stack

    - to redirect compiling location

    #+begin_src c
    typedef jo* compiling_stack_t[1024];

    compiling_stack_t compiling_stack;
    cell compiling_stack_base = 0;
    cell compiling_stack_pointer = 0;

    compiling_stack_push(jo* value) {
      compiling_stack[compiling_stack_pointer] = value;
      compiling_stack_pointer++;
    }

    jo* compiling_stack_pop() {
      compiling_stack_pointer--;
      return compiling_stack[compiling_stack_pointer];
    }

    compiling_stack_inc() {
      compiling_stack[compiling_stack_pointer - 1] =
        compiling_stack[compiling_stack_pointer - 1] + 1;
    }


    jo* compiling_stack_tos() {
      return compiling_stack[compiling_stack_pointer - 1];
    }

    bool compiling_stack_empty_p() {
      return compiling_stack_pointer == compiling_stack_base;
    }
    #+end_src

*** here

    #+begin_src c
    here(cell n) {
      jo* pointer = compiling_stack_pop();
      pointer[0] = n;
      compiling_stack_push(pointer + 1);
    }
    #+end_src

*** jojo_area & init_compiling_stack

    #+begin_src c
    jo jojo_area[1024 * 1024];

    init_compiling_stack() {
      compiling_stack_push(jojo_area);
    }
    #+end_src

* data_stack & return_stack

*** data_stack

    #+begin_src c
    typedef cell data_stack_t[1024 * 4];

    data_stack_t data_stack;
    cell data_stack_base = 64;
    cell data_stack_pointer = 64;

    data_stack_push(cell value) {
      data_stack[data_stack_pointer] = value;
      data_stack_pointer++;
    }

    void* data_stack_pop() {
      data_stack_pointer--;
      return data_stack[data_stack_pointer];
    }

    cell data_stack_tos() {
      return data_stack[data_stack_pointer - 1];
    }

    bool data_stack_empty_p() {
      return data_stack_base == data_stack_pointer;
    }
    #+end_src

*** local

    #+begin_src c
    typedef struct {
      jo name;
      cell local_tag;
      cell local_data;
    } local_point;

    local_point local_area[1024 * 1024];
    cell current_local_pointer = 0;
    #+end_src

*** return_stack

    #+begin_src c
    typedef struct {
      jo* jojo;
      cell local_pointer;
    } return_point;

    typedef return_point return_stack_t[1024 * 4];

    return_stack_t return_stack;
    cell return_stack_base = 64;
    cell return_stack_pointer = 64;

    return_stack_push(return_point value) {
      return_stack[return_stack_pointer] = value;
      return_stack_pointer++;
    }

    return_point return_stack_pop() {
      return_stack_pointer--;
      return return_stack[return_stack_pointer];
    }

    return_point return_stack_tos() {
      return return_stack[return_stack_pointer - 1];
    }

    bool return_stack_empty_p() {
      return return_stack_base == return_stack_pointer;
    }

    return_stack_make_point(jo* jojo, cell local_pointer) {
      return_point rp = {.jojo = jojo, .local_pointer = local_pointer};
      return_stack[return_stack_pointer] = rp;
      return_stack_pointer++;
    }

    return_stack_new_point(jo* jojo) {
      return_stack_make_point(jojo, current_local_pointer);
    }

    return_stack_inc() {
      return_point rp = return_stack_pop();
      return_point rp1 = {.jojo = rp.jojo + 1,
                          .local_pointer = rp.local_pointer};
      return_stack_push(rp1);
    }
    #+end_src

* name

*** name_record

    #+begin_src c
    jo name_record[16 * 1024];
    cell name_record_counter = 0;
    #+end_src

*** p_name_record

    #+begin_src c
    p_name_record() {
      data_stack_push(name_record);
    }
    #+end_src

*** p_name_report

    #+begin_src c
    p_name_report() {
      printf("- p_name_report // counter : %ld\n", name_record_counter);
      cell i = 0;
      while (i < name_record_counter) {
        printf("  %s\n", jo2str(name_record[i]));
        i++;
      }
      printf("\n");
    }
    #+end_src

*** binding_filter_stack

***** binding_filter_stack

      #+begin_src c
      typedef jo binding_filter_stack_t[128];
      binding_filter_stack_t binding_filter_stack;

      cell binding_filter_stack_base = 0;
      cell binding_filter_stack_pointer = 0;

      binding_filter_stack_push(jo value) {
        binding_filter_stack[binding_filter_stack_pointer] = value;
        binding_filter_stack_pointer++;
      }

      jo binding_filter_stack_pop() {
        binding_filter_stack_pointer--;
        return binding_filter_stack[binding_filter_stack_pointer];
      }

      jo binding_filter_stack_tos() {
        return binding_filter_stack[binding_filter_stack_pointer - 1];
      }

      bool binding_filter_stack_empty_p() {
        return binding_filter_stack_pointer == binding_filter_stack_base;
      }
      #+end_src

***** p_binding_filter_stack_push

      #+begin_src c
      p_binding_filter_stack_push() {
        binding_filter_stack_push(data_stack_pop());
      }
      #+end_src

***** p_binding_filter_stack_pop

      #+begin_src c
      p_binding_filter_stack_pop() {
        data_stack_push(binding_filter_stack_pop());
      }
      #+end_src

***** run_binding_filter

      #+begin_src c
      jo_apply_now(jo jo);

      run_binding_filter() {
        // [name] -> [name]
        cell i = binding_filter_stack_pointer;
        while (i > binding_filter_stack_base) {
          jo_apply_now(binding_filter_stack[i-1]);
          i--;
        }
      }
      #+end_src

*** name_can_bind_p

    #+begin_src c
    bool name_can_bind_p(jo name) {
      if (name->tag == JO_DECLARED) {
        return true;
      }
      else if (used_jo_p(name)) {
        return false;
      }
      else {
        return true;
      }
    }
    #+end_src

*** p_rebind_name

    #+begin_src c
    p_rebind_name() {
      // [data tag name] -> {set-jotable}
      run_binding_filter();

      jo name = data_stack_pop();
      jo tag = data_stack_pop();
      cell data = data_stack_pop();

      if (!used_jo_p(name)) {
        name_record[name_record_counter] = name;
        name_record_counter++;
        name_record[name_record_counter] = 0;
      }

      name->tag = tag;
      name->value = data;
    }
    #+end_src

*** p_bind_name

    #+begin_src c
    p_bind_name() {
      // [data tag name] -> {set-jotable}
      run_binding_filter();

      jo name = data_stack_pop();
      jo tag = data_stack_pop();
      cell data = data_stack_pop();

      if (!name_can_bind_p(name)) {
        printf("- p_bind_name can not rebind\n");
        printf("  name : %s\n", jo2str(name));
        printf("  tag : %s\n", jo2str(tag));
        printf("  data : %ld\n", data);
        printf("  it has been bound as a %s\n", jo2str(name->tag));
        return;
      }

      name_record[name_record_counter] = name;
      name_record_counter++;
      name_record[name_record_counter] = 0;

      name->tag = tag;
      name->value = data;
    }
    #+end_src

*** define_prim

    #+begin_src c
    define_prim(char* str, primitive fun) {
      jo name = str2jo(str);
      data_stack_push(fun);
      data_stack_push(TAG_PRIM);
      data_stack_push(name);
      p_bind_name();
    }
    #+end_src

*** define_primkey

    #+begin_src c
    define_primkey(char* str, primitive fun) {
      jo name = str2jo(str);
      data_stack_push(fun);
      data_stack_push(TAG_PRIM_KEYWORD);
      data_stack_push(name);
      p_bind_name();
    }
    #+end_src

* *bind*

*** expose_bind

    #+begin_src c
    expose_bind() {
      define_prim("name-report", p_name_report);
      define_prim("name-record", p_name_record);

      define_prim("binding-filter-stack-push", p_binding_filter_stack_push);
      define_prim("binding-filter-stack-pop", p_binding_filter_stack_pop);
    }
    #+end_src

* *apply* & eval

*** note

    - be careful when calling jo_apply in primitive,
      because after return_stack_push a jojo,
      one need to exit current primitive to run the jojo.

      if wished follow a 'eval();' after jo_apply
      to return to the primitive function.

    - keyword_stack and alias_stack
      form a hook for read_jo.

*** keyword_stack

    #+begin_src c
    typedef jo keyword_stack_t[128];
    keyword_stack_t keyword_stack;

    cell keyword_stack_base = 0;
    cell keyword_stack_pointer = 0;

    keyword_stack_push(jo value) {
      keyword_stack[keyword_stack_pointer] = value;
      keyword_stack_pointer++;
    }

    jo keyword_stack_pop() {
      keyword_stack_pointer--;
      return keyword_stack[keyword_stack_pointer];
    }

    jo keyword_stack_tos() {
      return keyword_stack[keyword_stack_pointer - 1];
    }

    bool keyword_stack_empty_p() {
      return keyword_stack_pointer == keyword_stack_base;
    }
    #+end_src

*** alias_stack

    #+begin_src c
    typedef struct {
      jo nick;
      jo name;
    } alias;
    typedef alias alias_stack_t[1024];
    alias_stack_t alias_stack;

    cell alias_stack_base = 0;
    cell alias_stack_pointer = 0;

    alias_stack_push(alias value) {
      alias_stack[alias_stack_pointer] = value;
      alias_stack_pointer++;
    }

    alias alias_stack_pop() {
      alias_stack_pointer--;
      return alias_stack[alias_stack_pointer];
    }

    alias alias_stack_tos() {
      return alias_stack[alias_stack_pointer - 1];
    }

    bool alias_stack_empty_p() {
      return alias_stack_pointer == alias_stack_base;
    }
    #+end_src

*** jo_apply

    #+begin_src c
    eval();
    p_debug();

    jo_apply(jo jo) {
      if (!used_jo_p(jo)) {
        printf("- jo_apply meet undefined jo : %s\n", jo2str(jo));
        p_debug();
        return;
      }

      cell tag = jo->tag;

      if (tag == TAG_PRIM) {
        primitive primitive = jo->value;
        primitive();
      }
      else if (tag == TAG_JOJO) {
        cell jojo = jo->value;
        return_stack_new_point(jojo);
      }

      else if (tag == TAG_PRIM_KEYWORD) {
        keyword_stack_push(alias_stack_pointer);
        primitive primitive = jo->value;
        primitive();
        alias_stack_pointer = keyword_stack_pop();
      }
      else if (tag == TAG_KEYWORD) {
        // keywords are always evaled
        keyword_stack_push(alias_stack_pointer);
        cell jojo = jo->value;
        return_stack_new_point(jojo);
        eval();
        alias_stack_pointer = keyword_stack_pop();
      }

      else if (tag == TAG_DATA) {
        cell cell = jo->value;
        data_stack_push(cell);
      }
      else {
        cell cell = jo->value;
        data_stack_push(cell);
        data_stack_push(tag);
      }
    }
    #+end_src

*** jo_apply_now

    #+begin_src c
    jo_apply_now(jo jo) {
      cell tag = jo->tag;
      if (tag == TAG_JOJO) {
        cell jojo = jo->value;
        return_stack_new_point(jojo);
        eval();
        return;
      }
      else {
        jo_apply(jo);
        return;
      }
    }
    #+end_src

*** jo_apply_with_local_pointer

    #+begin_src c
    jo_apply_with_local_pointer(jo jo, cell local_pointer) {
      cell tag = jo->tag;
      if (tag == TAG_JOJO) {
        cell jojo = jo->value;
        return_stack_make_point(jojo, local_pointer);
        return;
      }
      else {
        jo_apply(jo);
        return;
      }
    }
    #+end_src

*** eval

    #+begin_src c
    bool step_flag = false;

    stepper();

    eval() {
      cell return_stack_base = return_stack_pointer;
      while (return_stack_pointer >= return_stack_base) {
        return_point rp = return_stack_tos();
        return_stack_inc();
        jo* jojo = rp.jojo;
        jo jo = jojo[0];
        jo_apply(jo);
        if (step_flag == true) {
          stepper();
        }
      }
    }
    #+end_src

*** p_apply

    #+begin_src c
    p_apply() {
      return_stack_new_point(data_stack_pop());
    }
    #+end_src

*** p_apply_with_local_pointer

    #+begin_src c
    p_apply_with_local_pointer() {
      // [local_pointer jojo] -> [*]
      jo* jojo = data_stack_pop();
      cell local_pointer = data_stack_pop();
      return_stack_make_point(jojo, local_pointer);
    }
    #+end_src

*** p_jo_apply

    #+begin_src c
    p_jo_apply() {
      jo_apply(data_stack_pop());
    }
    #+end_src

*** p_jo_apply_with_local_pointer

    #+begin_src c
    p_jo_apply_with_local_pointer() {
      jo jo = data_stack_pop();
      cell local_pointer = data_stack_pop();
      jo_apply_with_local_pointer(jo, local_pointer);
    }
    #+end_src

*** expose_apply

    #+begin_src c
    expose_apply() {
      define_prim("apply", p_apply);
      define_prim("apply-with-local-pointer", p_apply_with_local_pointer);

      define_prim("jo/apply", p_jo_apply);
      define_prim("jo/apply-with-local-pointer", p_jo_apply_with_local_pointer);
    }
    #+end_src

* *stack_operation*

*** p_drop

    #+begin_src c
    p_drop() {
      data_stack_pop();
    }
    #+end_src

*** p_2drop

    #+begin_src c
    p_2drop() {
      data_stack_pop();
      data_stack_pop();
    }
    #+end_src

*** p_dup

    #+begin_src c
    p_dup() {
      // a a -> a
      cell a = data_stack_pop();
      data_stack_push(a);
      data_stack_push(a);
    }
    #+end_src

*** p_2dup

    #+begin_src c
    p_2dup() {
      // b a -> b a b a
      cell a = data_stack_pop();
      cell b = data_stack_pop();
      data_stack_push(b);
      data_stack_push(a);
      data_stack_push(b);
      data_stack_push(a);
    }
    #+end_src

*** p_over

    #+begin_src c
    p_over() {
      // b a -> b a b
      cell a = data_stack_pop();
      cell b = data_stack_pop();
      data_stack_push(b);
      data_stack_push(a);
      data_stack_push(b);
    }
    #+end_src

*** p_2over

    #+begin_src c
    p_2over() {
      // d c  b a -> d c  b a  d c
      cell a = data_stack_pop();
      cell b = data_stack_pop();
      cell c = data_stack_pop();
      cell d = data_stack_pop();
      data_stack_push(d);
      data_stack_push(c);
      data_stack_push(b);
      data_stack_push(a);
      data_stack_push(d);
      data_stack_push(c);
    }
    #+end_src

*** p_tuck

    #+begin_src c
    p_tuck() {
      // b a -> a b a
      cell a = data_stack_pop();
      cell b = data_stack_pop();
      data_stack_push(a);
      data_stack_push(b);
      data_stack_push(a);
    }
    #+end_src

*** p_2tuck

    #+begin_src c
    p_2tuck() {
      // d c  b a -> b a  d c  b a
      cell a = data_stack_pop();
      cell b = data_stack_pop();
      cell c = data_stack_pop();
      cell d = data_stack_pop();
      data_stack_push(b);
      data_stack_push(a);
      data_stack_push(d);
      data_stack_push(c);
      data_stack_push(b);
      data_stack_push(a);
    }
    #+end_src

*** p_swap

    #+begin_src c
    p_swap() {
      // b a -> a b
      cell a = data_stack_pop();
      cell b = data_stack_pop();
      data_stack_push(a);
      data_stack_push(b);
    }
    #+end_src

*** p_2swap

    #+begin_src c
    p_2swap() {
      // d c  b a -> b a  d c
      cell a = data_stack_pop();
      cell b = data_stack_pop();
      cell c = data_stack_pop();
      cell d = data_stack_pop();
      data_stack_push(b);
      data_stack_push(a);
      data_stack_push(d);
      data_stack_push(c);
    }
    #+end_src

*** p_print_data_stack

    #+begin_src c
    p_print_data_stack() {
      // {terminal-output}
      if (data_stack_pointer < data_stack_base) {
        printf("  * %ld *  ", (data_stack_pointer - data_stack_base));
        printf("-- below the stack --\n");
      }
      else {
        printf("  * %ld *  ", (data_stack_pointer - data_stack_base));
        printf("-- ");
        cell i = data_stack_base;
        while (i < data_stack_pointer) {
          printf("%ld ", data_stack[i]);
          i++;
        }
        printf("--\n");
      }
    }
    #+end_src

*** p_stack_base

    #+begin_src c
    p_stack_base() {
      data_stack_push(data_stack + data_stack_base);
    }
    #+end_src

*** p_stack_pointer

    #+begin_src c
    p_stack_pointer() {
      data_stack_push(data_stack + data_stack_pointer);
    }
    #+end_src

*** expose_stack_operation

    #+begin_src c
    expose_stack_operation() {
      define_prim("drop", p_drop);
      define_prim("2drop", p_2drop);
      define_prim("dup", p_dup);
      define_prim("2dup", p_2dup);
      define_prim("over", p_over);
      define_prim("2over", p_2over);
      define_prim("tuck", p_tuck);
      define_prim("2tuck", p_2tuck);
      define_prim("swap", p_swap);
      define_prim("2swap", p_2swap);
      define_prim("print-data-stack", p_print_data_stack);
      define_prim("stack-pointer", p_stack_pointer);
      define_prim("stack-base", p_stack_base);
    }
    #+end_src

* *ending*

*** p_end

    #+begin_src c
    p_end() {
      return_point rp = return_stack_pop();
      current_local_pointer = rp.local_pointer;
    }
    #+end_src

*** p_bye

    #+begin_src c
    p_bye() {
      printf("bye bye ^-^/\n");
      exit(0);
    }
    #+end_src

*** expose_ending

    #+begin_src c
    expose_ending() {
      define_prim("end", p_end);
      define_prim("bye", p_bye);
    }
    #+end_src

* *bool*

*** p_true

    #+begin_src c
    p_true() {
      data_stack_push(true);
    }
    #+end_src

*** p_false

    #+begin_src c
    p_false() {
      data_stack_push(false);
    }
    #+end_src

*** p_not

    #+begin_src c
    p_not() {
      // bool -> bool
      cell a = data_stack_pop();
      data_stack_push(!a);
    }
    #+end_src

*** p_and

    #+begin_src c
    p_and() {
      // bool bool -> bool
      cell a = data_stack_pop();
      cell b = data_stack_pop();
      data_stack_push(a&&b);
    }
    #+end_src

*** p_or

    #+begin_src c
    p_or() {
      // bool bool -> bool
      cell a = data_stack_pop();
      cell b = data_stack_pop();
      data_stack_push(a||b);
    }
    #+end_src

*** expose_bool

    #+begin_src c
    expose_bool() {
      define_prim("true", p_true);
      define_prim("false", p_false);
      define_prim("not", p_not);
      define_prim("and", p_and);
      define_prim("or", p_or);
    }
    #+end_src

* *int*

*** p_inc

    #+begin_src c
    p_inc() {
      cell a = data_stack_pop();
      data_stack_push(a + 1);
    }
    #+end_src

*** p_dec

    #+begin_src c
    p_dec() {
      cell a = data_stack_pop();
      data_stack_push(a - 1);
    }
    #+end_src

*** p_neg

    #+begin_src c
    p_neg() {
      cell a = data_stack_pop();
      data_stack_push(- a);
    }
    #+end_src

*** p_add

    #+begin_src c
    p_add() {
      cell b = data_stack_pop();
      cell a = data_stack_pop();
      data_stack_push(a + b);
    }
    #+end_src

*** p_sub

    #+begin_src c
    p_sub() {
      cell b = data_stack_pop();
      cell a = data_stack_pop();
      data_stack_push(a - b);
    }
    #+end_src

*** p_mul

    #+begin_src c
    p_mul() {
      cell b = data_stack_pop();
      cell a = data_stack_pop();
      data_stack_push(a * b);
    }
    #+end_src

*** p_div

    #+begin_src c
    p_div() {
      cell b = data_stack_pop();
      cell a = data_stack_pop();
      data_stack_push(a / b);
    }
    #+end_src

*** p_mod

    #+begin_src c
    p_mod() {
      cell b = data_stack_pop();
      cell a = data_stack_pop();
      data_stack_push(a % b);
    }
    #+end_src

*** p_n_eq_p

    #+begin_src c
    p_n_eq_p() {
      // a ... b ... n -> bool
      cell n = data_stack_pop();
      cell old_n = n;
      cell* cursor1 = (data_stack + data_stack_pointer - n);
      cell* cursor2 = (data_stack + data_stack_pointer - n - n);
      while (n > 0) {
        if (cursor1[n-1] != cursor2[n-1]) {
          data_stack_pointer = data_stack_pointer - old_n - old_n;
          data_stack_push(false);
          return;
        }
        n--;
      }
      data_stack_pointer = data_stack_pointer - old_n - old_n;
      data_stack_push(true);
    }
    #+end_src

*** p_eq_p

    #+begin_src c
    p_eq_p() {
      cell b = data_stack_pop();
      cell a = data_stack_pop();
      data_stack_push(a == b);
    }
    #+end_src

*** p_gt_p

    #+begin_src c
    p_gt_p() {
      cell b = data_stack_pop();
      cell a = data_stack_pop();
      data_stack_push(a > b);
    }
    #+end_src

*** p_lt_p

    #+begin_src c
    p_lt_p() {
      cell b = data_stack_pop();
      cell a = data_stack_pop();
      data_stack_push(a < b);
    }
    #+end_src

*** p_gteq_p

    #+begin_src c
    p_gteq_p() {
      cell b = data_stack_pop();
      cell a = data_stack_pop();
      data_stack_push(a >= b);
    }
    #+end_src

*** p_lteq_p

    #+begin_src c
    p_lteq_p() {
      cell b = data_stack_pop();
      cell a = data_stack_pop();
      data_stack_push(a <= b);
    }
    #+end_src

*** i_int

    #+begin_src c
    i_int() {
      // [] -> [cell] {return_stack}
      return_point rp = return_stack_tos();
      return_stack_inc();
      jo* jojo = rp.jojo;
      jo jo = jojo[0];
      data_stack_push(jo);
    }
    #+end_src

*** k_int

    #+begin_src c
    jo read_raw_jo();

    k_int() {
      // (int ...)
      while (true) {
        jo s = read_raw_jo();
        if (s == ROUND_KET) {
          break;
        }
        else {
          here(JO_INS_INT);
          here(string_to_int(jo2str(s)));
        }
      }
    }
    #+end_src

*** p_int_print

    #+begin_src c
    p_int_print() { printf("%ld", data_stack_pop()); }
    #+end_src

*** p_dot & p_int_dot

    #+begin_src c
    p_dot() { printf("%ld ", data_stack_pop()); }
    p_int_dot() { printf("%ld ", data_stack_pop()); }
    #+end_src

*** expose_int

    #+begin_src c
    expose_int() {
      define_prim("inc", p_inc);
      define_prim("dec", p_dec);
      define_prim("neg", p_neg);

      define_prim("add", p_add);
      define_prim("sub", p_sub);

      define_prim("mul", p_mul);
      define_prim("div", p_div);
      define_prim("mod", p_mod);

      define_prim("n-eq?", p_n_eq_p);

      define_prim("eq?", p_eq_p);
      define_prim("gt?", p_gt_p);
      define_prim("lt?", p_lt_p);
      define_prim("gteq?", p_gteq_p);
      define_prim("lteq?", p_lteq_p);

      define_prim("ins/int", i_int);
      define_primkey("int", k_int);

      define_prim("int/print", p_int_print);

      define_prim("dot", p_dot);
      define_prim("int/dot", p_int_dot);
    }
    #+end_src

* *memory*

*** p_allocate

    #+begin_src c
    p_allocate () {
      // size -> addr
      data_stack_push(calloc(data_stack_pop(), 1));
    }
    #+end_src

*** p_free

    #+begin_src c
    p_free () {
      // addr ->
      free(data_stack_pop());
    }
    #+end_src

*** k_address

    #+begin_src c
    k_ignore();

    k_address() {
      // (address ...)
      here(JO_INS_ADDRESS);
      jo name = read_raw_jo();
      here(&(name->value));
      k_ignore();
    }
    #+end_src

*** p_jo_as_var

    #+begin_src c
    p_jo_as_var() {
      jo jo = data_stack_pop();
      data_stack_push(&(jo->value));
    }
    #+end_src

*** p_set_cell

    #+begin_src c
    p_set_cell() {
      // cell address ->
      cell* address = data_stack_pop();
      cell value = data_stack_pop();
      address[0] = value;
    }
    #+end_src

*** p_get_cell

    #+begin_src c
    p_get_cell() {
      // address -> cell
      cell* address = data_stack_pop();
      data_stack_push(address[0]);
    }
    #+end_src

*** p_set_byte

    #+begin_src c
    p_set_byte() {
      // byte address ->
      char* address = data_stack_pop();
      cell value = data_stack_pop();
      address[0] = value;
    }
    #+end_src

*** p_get_byte

    #+begin_src c
    p_get_byte() {
      // address -> byte
      char* address = data_stack_pop();
      data_stack_push(address[0]);
    }
    #+end_src

*** expose_memory

    #+begin_src c
    expose_memory() {
      define_prim("allocate", p_allocate);
      define_prim("free", p_free);

      define_prim("ins/address", i_int);
      define_primkey("address", k_address);

      define_prim("jo-as-var", p_jo_as_var);
      define_prim("set-cell", p_set_cell);
      define_prim("get-cell", p_get_cell);
      define_prim("set-byte", p_set_byte);
      define_prim("get-byte", p_get_byte);
    }
    #+end_src

* *byte*

*** reading_stack

    #+begin_src c
    typedef FILE* reading_stack_t[64];

    reading_stack_t reading_stack;
    cell reading_stack_base = 0;
    cell reading_stack_pointer = 0;

    reading_stack_push(FILE* value) {
      reading_stack[reading_stack_pointer] = value;
      reading_stack_pointer++;
    }

    FILE* reading_stack_pop() {
      reading_stack_pointer--;
      return reading_stack[reading_stack_pointer];
    }

    FILE* reading_stack_tos() {
      return reading_stack[reading_stack_pointer - 1];
    }

    bool reading_stack_empty_p() {
      return reading_stack_pointer == reading_stack_base;
    }
    #+end_src

*** get_real_reading_path

    #+begin_src c
    erase_real_path_to_dir(char* path) {
      cell cursor = strlen(path);
      while (path[cursor] != '/') {
        path[cursor] = '\0';
        cursor--;
      }
      path[cursor] = '\0';
    }

    char* get_real_reading_path(char* path) {
      // caller of this function
      // should free its return value
      char* real_reading_path = malloc(PATH_MAX);
      if (path[0] == '/' ||
          reading_stack_empty_p() ||
          reading_stack_tos() == stdin) {
        realpath(path, real_reading_path);
        return real_reading_path;
      }
      else {
        char* proc_link_path = malloc(PATH_MAX);
        sprintf(proc_link_path, "/proc/self/fd/%d", fileno(reading_stack_tos()));
        ssize_t real_bytes = readlink(proc_link_path, real_reading_path, PATH_MAX);
        if (real_bytes == -1) {
          printf("- get_real_reading_path fail to readlink\n");
          printf("  proc_link_path : %s\n", proc_link_path);
          perror("  readlink : ");
          free(proc_link_path);
          free(real_reading_path);
          p_debug();
          return NULL; // to fool the compiler
        }
        free(proc_link_path);
        real_reading_path[real_bytes] = '\0';
        erase_real_path_to_dir(real_reading_path);
        strcat(real_reading_path, "/");
        strcat(real_reading_path, path);
        return real_reading_path;
      }
    }
    #+end_src

*** has_byte_p

    #+begin_src c
    bool has_byte_p() {
    FILE* file;
      if (reading_stack_empty_p()) {
        file = stdin;
      }
      else {
        file = reading_stack_tos();
      }

      if (feof(file) == 0) {
        return true;
      }
      else {
        return false;
      }
    }
    #+end_src

*** p_has_byte_p

    #+begin_src c
    p_has_byte_p() {
      data_stack_push(has_byte_p());
    }
    #+end_src

*** read_byte

    #+begin_src c
    byte read_byte() {
      if (reading_stack_empty_p()) {
        return fgetc(stdin);
      }
      else {
        return fgetc(reading_stack_tos());
      }
    }
    #+end_src

*** byte_unread

    #+begin_src c
    byte_unread(byte c) {
      if (reading_stack_empty_p()) {
        ungetc(c, stdin);
      }
      else {
        ungetc(c, reading_stack_tos());
      }
    }
    #+end_src

*** p_read_byte

    #+begin_src c
    p_read_byte() {
      // -> byte
      data_stack_push(read_byte());
    }
    #+end_src

*** p_byte_unread

    #+begin_src c
    p_byte_unread() {
      // byte -> {reading_stack}
      byte_unread(data_stack_pop());
    }
    #+end_src

*** p_byte_print

    #+begin_src c
    p_byte_print() {
      // byte ->
      printf("%c", data_stack_pop());
    }
    #+end_src

*** p_ignore_until_double_quote

    #+begin_src c
    p_ignore_until_double_quote() {
      while (true) {
        jo jo = read_raw_jo();
        if (jo == DOUBLE_QUOTE) {
          return;
        }
        else {
          // loop
        }
      }
    }
    #+end_src

*** k_one_byte

    #+begin_src c
    k_one_byte() {
      byte byte = read_byte();
      p_ignore_until_double_quote();
      here(JO_INS_BYTE);
      here(byte);
    }
    #+end_src

*** k_byte

    #+begin_src c
    k_byte() {
      // (byte ...)
      while (true) {
        jo jo = read_raw_jo();
        if (jo == ROUND_KET) {
          return;
        }
        else if (jo == DOUBLE_QUOTE) {
          k_one_byte();
          // loop
        }
        else {
          // loop
        }
      }
    }
    #+end_src

*** expose_byte

    #+begin_src c
    expose_byte() {
      define_prim("has-byte?", p_has_byte_p);
      define_prim("read/byte", p_read_byte);
      define_prim("byte/unread", p_byte_unread);
      define_prim("byte/print", p_byte_print);
      define_prim("ignore-until-double-quote", p_ignore_until_double_quote);

      define_prim("ins/byte", i_int);
      define_primkey("byte", k_byte);
    }
    #+end_src

* *string*

*** k_one_string

    #+begin_src c
    k_one_string() {
      // "..."
      char buffer[1024 * 1024];
      cell cursor = 0;
      while (true) {
        char c = read_byte();
        if (c == '"') {
          buffer[cursor] = 0;
          cursor++;
          break;
        }
        else {
          buffer[cursor] = c;
          cursor++;
        }
      }
      char* str = malloc(cursor);
      strcpy(str, buffer);
      here(JO_INS_STRING);
      here(str);
    }
    #+end_src

*** k_string

    #+begin_src c
    k_string() {
      // (string "...")
      while (true) {
        jo s = read_raw_jo();
        if (s == ROUND_KET) {
          return;
        }
        else if (s == DOUBLE_QUOTE) {
          k_one_string();
        }
        else {
          // do nothing
        }
      }
    }
    #+end_src

*** p_string_length

    #+begin_src c
    p_string_length() {
      // string -> length
      data_stack_push(strlen(data_stack_pop()));
    }
    #+end_src

*** p_string_print

    #+begin_src c
    p_string_print() {
      // string -> {terminal-output}
      printf("%s", data_stack_pop());
    }
    #+end_src

*** p_string_dot

    #+begin_src c
    p_string_dot() {
      // string -> {terminal-output}
      printf("\"%s \"", data_stack_pop());
    }
    #+end_src

*** p_string_append_to_buffer

    #+begin_src c
    p_string_append_to_buffer() {
      // buffer string -> buffer
      char* str = data_stack_pop();
      char* buffer = data_stack_tos();
      strcat(buffer, str);
    }
    #+end_src

***** p_string_first_byte

    #+begin_src c
    p_string_first_byte() {
      char* s = data_stack_pop();
      data_stack_push(s[0]);
    }
    #+end_src

*** p_string_last_byte

    #+begin_src c
    p_string_last_byte() {
      char* s = data_stack_pop();
      cell i = 0;
      while (s[i+1] != 0) {
        i++;
      }
      data_stack_push(s[i]);
    }
    #+end_src

*** p_string_member_p

    #+begin_src c
    p_string_member_p() {
      // non-zero-byte string -> true or false
      char* s = data_stack_pop();
      byte b = data_stack_pop();
      cell i = 0;
      while (s[i] != 0) {
        if (s[i] == b) {
          data_stack_push(true);
          return;
        }
        else {
          i++;
        }
      }
      data_stack_push(false);
    }
    #+end_src

*** p_string_find_byte

    #+begin_src c
    p_string_find_byte() {
      // byte string -> [index true] or [false]
      char* s = data_stack_pop();
      byte b = data_stack_pop();
      cell i = 0;
      while (s[i] != 0) {
        if (s[i] == b) {
          data_stack_push(i);
          data_stack_push(true);
          return;
        }
        else {
          i++;
        }
      }
      data_stack_push(false);
    }
    #+end_src

*** p_string_equal_p

    #+begin_src c
    p_string_equal_p() {
      data_stack_push(string_equal(data_stack_pop(), data_stack_pop()));
    }
    #+end_src

*** expose_string

    #+begin_src c
    expose_string() {
      define_prim("ins/string", i_int);
      define_primkey("string", k_string);
      define_primkey("one-string", k_one_string);
      define_prim("string/print", p_string_print);
      define_prim("string/dot", p_string_dot);
      define_prim("string/length", p_string_length);
      define_prim("string/append-to-buffer", p_string_append_to_buffer);
      define_prim("string/first-byte", p_string_first_byte);
      define_prim("string/last-byte", p_string_last_byte);
      define_prim("string/member?", p_string_member_p);
      define_prim("string/find-byte", p_string_find_byte);
      define_prim("string/equal?", p_string_equal_p);
    }
    #+end_src

* *jo*

*** p_alias_push

    #+begin_src c
    p_alias_push() {
      jo name = data_stack_pop();
      jo nick = data_stack_pop();
      alias a = {.nick = nick, .name = name};
      alias_stack_push(a);
    }
    #+end_src

*** p_alias_filter

    #+begin_src c
    p_alias_filter() {
      jo nick = data_stack_pop();
      cell base = keyword_stack_tos();
      cell i = alias_stack_pointer;
      while (i >= base) {
        if (alias_stack[i].nick == nick) {
          data_stack_push(alias_stack[i].name);
          return;
        }
        else {
          i--;
        }
      }
      data_stack_push(nick);
    }
    #+end_src

*** has_jo_p

    #+begin_src c
    bool has_jo_p() {
      byte c;
      while (true) {

        if (!has_byte_p()) {
          return false;
        }

        c = read_byte();

        if (isspace(c)) {
          // loop
        }
        else {
          byte_unread(c);
          return true;
        }
      }
    }
    #+end_src

*** p_has_jo_p

    #+begin_src c
    p_has_jo_p() {
      data_stack_push(has_jo_p());
    }
    #+end_src

*** p_read_raw_jo

    #+begin_src c
    p_read_raw_jo() {
      // {reading_stack} -> jo
      byte buf[1024];
      cell cur = 0;
      cell collecting = false;
      byte c;
      byte go = true;

      while (go) {

        if (!has_byte_p()) {
          if (!collecting) {
            printf("- p_read_raw_jo meet end-of-file\n");
            return;
          }
          else {
            break;
          }
        }

        c = read_byte();

        if (!collecting) {
          if (isspace(c)) {
            // loop
          }
          else {
            collecting = true;
            buf[cur] = c;
            cur++;
            if (isbarcket(c)) {
              go = false;
            }
          }
        }

        else {
          if (isbarcket(c) ||
              isspace(c)) {
            byte_unread(c);
            go = false;
          }
          else {
            buf[cur] = c;
            cur++;
          }
        }
      }

      buf[cur] = 0;
      data_stack_push(str2jo(buf));
    }
    #+end_src

*** jo_filter_stack

***** jo_filter_stack

      #+begin_src c
      typedef jo reading_filter;

      typedef reading_filter jo_filter_stack_t[128];
      jo_filter_stack_t jo_filter_stack;

      cell jo_filter_stack_base = 0;
      cell jo_filter_stack_pointer = 0;

      jo_filter_stack_push(reading_filter value) {
        jo_filter_stack[jo_filter_stack_pointer] = value;
        jo_filter_stack_pointer++;
      }

      reading_filter jo_filter_stack_pop() {
        jo_filter_stack_pointer--;
        return jo_filter_stack[jo_filter_stack_pointer];
      }

      reading_filter jo_filter_stack_tos() {
        return jo_filter_stack[jo_filter_stack_pointer - 1];
      }

      bool jo_filter_stack_empty_p() {
        return jo_filter_stack_pointer == jo_filter_stack_base;
      }
      #+end_src

***** p_jo_filter_stack_push

      #+begin_src c
      p_jo_filter_stack_push() {
        jo_filter_stack_push(data_stack_pop());
      }
      #+end_src

***** p_jo_filter_stack_pop

      #+begin_src c
      p_jo_filter_stack_pop() {
        data_stack_push(jo_filter_stack_pop());
      }
      #+end_src

***** run_jo_filter

      #+begin_src c
      run_jo_filter() {
        cell i = jo_filter_stack_pointer;
        while (i > jo_filter_stack_base) {
          jo_apply_now(jo_filter_stack[i-1]);
          i--;
        }
      }
      #+end_src

***** init_jo_filter_stack

      #+begin_src c
      init_jo_filter_stack() {
        jo_filter_stack_push(str2jo("alias-filter"));
      }
      #+end_src

*** p_read_jo

    #+begin_src c
    p_read_jo() {
      p_read_raw_jo();
      run_jo_filter();
    }
    #+end_src

*** read_jo

    #+begin_src c
    jo read_jo() {
      p_read_jo();
      return data_stack_pop();
    }
    #+end_src

*** read_raw_jo

    #+begin_src c
    jo read_raw_jo() {
      p_read_raw_jo();
      return data_stack_pop();
    }
    #+end_src

*** cat_2_jo

    #+begin_src c
    jo cat_2_jo(jo x, jo y) {
      char str[2 * 1024];
      str[0] = 0;
      strcat(str, jo2str(x));
      strcat(str, jo2str(y));
      return str2jo(str);
    }
    #+end_src

*** cat_3_jo

    #+begin_src c
    jo cat_3_jo(jo x, jo y, jo z) {
      char str[3 * 1024];
      str[0] = 0;
      strcat(str, jo2str(x));
      strcat(str, jo2str(y));
      strcat(str, jo2str(z));
      return str2jo(str);
    }
    #+end_src

*** p_jo_append

    #+begin_src c
    p_jo_append() {
      jo jo2 = data_stack_pop();
      jo jo1 = data_stack_pop();
      data_stack_push(cat_2_jo(jo1, jo2));
    }
    #+end_src

*** p_empty_jo

    #+begin_src c
    p_empty_jo() {
      data_stack_push(EMPTY_JO);
    }
    #+end_src

*** p_jo_used_p

    #+begin_src c
    p_jo_used_p() {
      // jo -> bool
      jo jo = data_stack_pop();
      data_stack_push(used_jo_p(jo));
    }
    #+end_src

*** p_jo_to_string

    #+begin_src c
    p_jo_to_string() {
      // jo -> string
      jo jo = data_stack_pop();
      data_stack_push(jo2str(jo));
    }
    #+end_src

*** p_string_length_to_jo

    #+begin_src c
    p_string_length_to_jo() {
      // string length -> jo
      cell len = data_stack_pop();
      cell str = data_stack_pop();
      char buffer[2 * 1024];
      strncpy(buffer, str, len);
      buffer[len] = 0;
      data_stack_push(str2jo(buffer));
    }
    #+end_src

*** p_string_to_jo

    #+begin_src c
    p_string_to_jo() {
      // string -> jo
      char* str = data_stack_pop();
      data_stack_push(str2jo(str));
    }
    #+end_src

*** p_null

    #+begin_src c
    p_null() {
      data_stack_push(JO_NULL);
    }
    #+end_src

*** k_raw_jo

    #+begin_src c
    k_raw_jo() {
      // (raw-jo ...)
      while (true) {
        jo s = read_raw_jo();
        if (s == ROUND_BAR) {
          jo_apply(read_jo());
        }
        else if (s == ROUND_KET) {
          break;
        }
        else {
          here(JO_INS_JO);
          here(s);
        }
      }
    }
    #+end_src

*** k_jo

    #+begin_src c
    k_jo() {
      // (jo ...)
      while (true) {
        jo s = read_jo();
        if (s == ROUND_BAR) {
          jo_apply(read_jo());
        }
        else if (s == ROUND_KET) {
          break;
        }
        else {
          here(JO_INS_JO);
          here(s);
        }
      }
    }
    #+end_src

*** p_jo_print

    #+begin_src c
    p_jo_print() {
      // jo -> {terminal-output}
      printf("%s", jo2str(data_stack_pop()));
    }
    #+end_src

*** p_jo_dot

    #+begin_src c
    p_jo_dot() {
      // jo -> {terminal-output}
      printf("%s ", jo2str(data_stack_pop()));
    }
    #+end_src

*** p_generate_jo

    #+begin_src c
    cell p_generate_jo_counter = 0;
    p_generate_jo() {
      char* s = data_stack_pop();
      char buffer [1024];
      sprintf(buffer, "%s:generated-jo#%ld", jo2str(s), p_generate_jo_counter);
      p_generate_jo_counter++;
      data_stack_push(str2jo(buffer));
    }
    #+end_src

*** p_jo_find_byte

    #+begin_src c
    p_jo_find_byte() {
      // byte jo -> [index true] or [false]
      p_jo_to_string();
      p_string_find_byte();
    }
    #+end_src

*** p_jo_right_part

    #+begin_src c
    p_jo_right_part() {
      // index jo -> jo
      jo jo = data_stack_pop();
      cell index = data_stack_pop();
      char* s = jo2str(jo);
      data_stack_push(str2jo(s + index));
    }
    #+end_src

*** p_jo_left_part

    #+begin_src c
    p_jo_left_part() {
      // index jo -> jo
      char target[1024];
      jo jo = data_stack_pop();
      cell index = data_stack_pop();
      char* source = jo2str(jo);
      cell i = 0;
      while (i < index) {
        target[i] = source[i];
        i++;
      }
      target[index] = 0;
      data_stack_push(str2jo(target));
    }
    #+end_src

*** p_jo_part

    #+begin_src c
    p_jo_part() {
      // index-begin index-end jo -> jo
      char target[1024];
      jo jo = data_stack_pop();
      cell index_end = data_stack_pop();
      cell index_begin = data_stack_pop();
      char* source = jo2str(jo);
      cell i = index_begin;
      while (i < index_end) {
        target[i] = source[i];
        i++;
      }
      target[index_end] = 0;
      data_stack_push(str2jo(target + index_begin));
    }
    #+end_src

*** expose_jo

    #+begin_src c
    expose_jo() {
      define_prim("null", p_null);

      define_prim("jo-filter-stack-push", p_jo_filter_stack_push);
      define_prim("jo-filter-stack-pop", p_jo_filter_stack_pop);

      define_prim("alias-push", p_alias_push);
      define_prim("alias-filter", p_alias_filter);

      define_prim("has-jo?", p_has_jo_p);

      define_prim("read/raw-jo", p_read_raw_jo);
      define_prim("read/jo", p_read_jo);

      define_prim("ins/jo", i_int);
      define_primkey("jo", k_jo);
      define_primkey("raw-jo", k_raw_jo);

      define_prim("jo/used?", p_jo_used_p);
      define_prim("jo/append", p_jo_append);
      define_prim("empty-jo", p_empty_jo);
      define_prim("jo->string", p_jo_to_string);
      define_prim("string->jo", p_string_to_jo);
      define_prim("string/length->jo", p_string_length_to_jo);
      define_prim("jo/print", p_jo_print);
      define_prim("jo/dot", p_jo_dot);
      define_prim("generate-jo", p_generate_jo);

      define_prim("jo/find-byte", p_jo_find_byte);
      define_prim("jo/left-part", p_jo_left_part);
      define_prim("jo/right-part", p_jo_right_part);
      define_prim("jo/part", p_jo_part);
    }
    #+end_src

* *file*

*** p_error_number_print

    #+begin_src c
    p_error_number_print() {
      // errno -> {terminal-output}
      int no = data_stack_pop();
      printf("%s", strerror(no));
    }
    #+end_src

*** p_path_open_read

    #+begin_src c
    p_path_open_read() {
      // [path] -> [file true] or [errno false]
      char* path = data_stack_pop();

      FILE* file = fopen(path, "r");
      if (file == NULL) {
        data_stack_push(errno);
        data_stack_push(false);
      }
      else {
        data_stack_push(file);
        data_stack_push(true);
      }
    }
    #+end_src

*** p_path_open_write

    #+begin_src c
    p_path_open_write() {
      // [path] -> [file true] or [errno false]
      char* path = data_stack_pop();

      FILE* file = fopen(path, "wx");
      if (file == NULL) {
        data_stack_push(errno);
        data_stack_push(false);
      }
      else {
        data_stack_push(file);
        data_stack_push(true);
      }
    }
    #+end_src

*** p_path_open_read_and_write

    #+begin_src c
    p_path_open_read_and_write() {
      // [path] -> [file true] or [errno false]
      char* path = data_stack_pop();

      FILE* file = fopen(path, "r+");
      if (file == NULL) {
        data_stack_push(errno);
        data_stack_push(false);
      }
      else {
        data_stack_push(file);
        data_stack_push(true);
      }
    }
    #+end_src

*** p_path_open_create

    #+begin_src c
    p_path_open_create() {
      // [path] -> [file true] or [errno false]
      char* path = data_stack_pop();

      FILE* file = fopen(path, "w+");
      if (file == NULL) {
        data_stack_push(errno);
        data_stack_push(false);
      }
      else {
        data_stack_push(file);
        data_stack_push(true);
      }
    }
    #+end_src

*** p_file_close

    #+begin_src c
    p_file_close() {
      // [file] -> [true] or [errno false]
      // - error reasons
      // 1. to close an unopened file descriptor
      // 2. close the same file descriptor twice
      // 3. error conditions for specific file system
      //    to diagnose during a close operation
      //    - for example, NFS (Network File System)
      FILE* file = data_stack_pop();

      if (fclose(file) == EOF) {
        data_stack_push(errno);
        data_stack_push(false);
      }
      else {
        data_stack_push(true);
      }
    }
    #+end_src

*** p_file_end_p

    #+begin_src c
    p_file_end_p() {
      // file -> true or false
      FILE* file = data_stack_pop();

      if (feof(file)) {
        data_stack_push(true);
      }
      else {
        data_stack_push(false);
      }
    }
    #+end_src

*** p_file_read

    #+begin_src c
    p_file_read() {
      // [file buffer requested-bytes] ->
      // [real-bytes true] or [errno false]
      // - partial read reasons
      //   1. [regular-file] end-of-file is reached
      //   2. [terminal] meets '\n'
      size_t want_bytes = data_stack_pop();
      void* buffer = data_stack_pop();
      FILE* file = data_stack_pop();

      size_t real_bytes = fread(buffer, 1, file, want_bytes);
      if (real_bytes != want_bytes) {
        if (ferror(file)) {
          data_stack_push(errno);
          data_stack_push(false);
        }
        else {
          data_stack_push(real_bytes);
          data_stack_push(true);
        }
      }
      else {
        data_stack_push(real_bytes);
        data_stack_push(true);
      }
    }
    #+end_src

*** p_file_write

    #+begin_src c
    p_file_write() {
      // [file buffer want-bytes] ->
      // [true] or [errno false]
      // - partial write reasons
      //   1. disk was filled
      //   2. the process resource limit on file sizes was reached
      size_t want_bytes = data_stack_pop();
      void* buffer = data_stack_pop();
      FILE* file = data_stack_pop();

      ssize_t real_bytes = fwrite(buffer, 1, want_bytes, file);
      if (real_bytes != want_bytes) {
        data_stack_push(errno);
        data_stack_push(false);
      }
      else {
        data_stack_push(true);
      }
    }
    #+end_src

*** p_file_size

    #+begin_src c
    p_file_size() {
      // file -> int
      FILE* file = data_stack_pop();
      struct stat file_state;
      fstat(fileno(file), &file_state);
      data_stack_push(file_state.st_size);
    }
    #+end_src

*** p_file_regular_file_p

    #+begin_src c
    p_file_regular_file_p() {
      // file -> true or false
      FILE* file = data_stack_pop();
      struct stat file_state;
      fstat(fileno(file), &file_state);
      if ((file_state.st_mode & S_IFMT) == S_IFREG) {
        data_stack_push(true);
      }
      else {
        data_stack_push(false);
      }
    }
    #+end_src

*** p_file_directory_p

    #+begin_src c
    p_file_directory_p() {
      // file -> true or false
      FILE* file = data_stack_pop();
      struct stat file_state;
      fstat(fileno(file), &file_state);
      if ((file_state.st_mode & S_IFMT) == S_IFDIR) {
        data_stack_push(true);
      }
      else {
        data_stack_push(false);
      }
    }
    #+end_src

*** p_file_character_device_p

    #+begin_src c
    p_file_character_device_p() {
      // file -> true or false
      FILE* file = data_stack_pop();
      struct stat file_state;
      fstat(fileno(file), &file_state);
      if ((file_state.st_mode & S_IFMT) == S_IFCHR) {
        data_stack_push(true);
      }
      else {
        data_stack_push(false);
      }
    }
    #+end_src

*** p_file_block_device_p

    #+begin_src c
    p_file_block_device_p() {
      // file -> true or false
      FILE* file = data_stack_pop();
      struct stat file_state;
      fstat(fileno(file), &file_state);
      if ((file_state.st_mode & S_IFMT) == S_IFBLK) {
        data_stack_push(true);
      }
      else {
        data_stack_push(false);
      }
    }
    #+end_src

*** p_file_fifo_p

    #+begin_src c
    p_file_fifo_p() {
      // file -> true or false
      FILE* file = data_stack_pop();
      struct stat file_state;
      fstat(fileno(file), &file_state);
      if ((file_state.st_mode & S_IFMT) == S_IFIFO) {
        data_stack_push(true);
      }
      else {
        data_stack_push(false);
      }
    }
    #+end_src

*** p_file_socket_p

    #+begin_src c
    p_file_socket_p() {
      // file -> true or false
      FILE* file = data_stack_pop();
      struct stat file_state;
      fstat(fileno(file), &file_state);
      if ((file_state.st_mode & S_IFMT) == S_IFSOCK) {
        data_stack_push(true);
      }
      else {
        data_stack_push(false);
      }
    }
    #+end_src

*** p_path_exist_p

    #+begin_src c
    p_path_exist_p() {
      // path -> true or false
      char* path = data_stack_pop();

      if (access(path, F_OK) == -1) {
        data_stack_push(false);
      }
      else {
        data_stack_push(true);
      }
    }
    #+end_src

*** p_path_readable_p

    #+begin_src c
    p_path_readable_p() {
      // path -> true or false
      char* path = data_stack_pop();

      if (access(path, R_OK) == -1) {
        data_stack_push(false);
      }
      else {
        data_stack_push(true);
      }
    }
    #+end_src

*** p_path_writable_p

    #+begin_src c
    p_path_writable_p() {
      // path -> true or false
      char* path = data_stack_pop();

      if (access(path, W_OK) == -1) {
        data_stack_push(false);
      }
      else {
        data_stack_push(true);
      }
    }
    #+end_src

*** p_path_executable_p

    #+begin_src c
    p_path_executable_p() {
      // path -> true or false
      char* path = data_stack_pop();

      if (access(path, X_OK) == -1) {
        data_stack_push(false);
      }
      else {
        data_stack_push(true);
      }
    }
    #+end_src

*** p_file_print_path

    #+begin_src c
    p_file_print_path() {
      // file -> path
      FILE* file = data_stack_pop();

      char proc_link_path[PATH_MAX];
      char file_path[PATH_MAX];

      sprintf(proc_link_path, "/proc/self/fd/%d", fileno(file));

      ssize_t real_bytes = readlink(proc_link_path, file_path, PATH_MAX);
      if (real_bytes == -1) {
        printf("- p_file_print_path fail readlink /proc/self/fd/%d\n", fileno(file));
        perror("\n");
      }
      else {
        file_path[real_bytes] = '\0';
        printf("%s", file_path);
      }
    }
    #+end_src

*** p_path_load

    #+begin_src c
    p_repl();

    p_path_load() {
      // path -> {reading_stack}
      char* path = data_stack_pop();
      FILE* file = fopen(path, "r");
      if(file == NULL) {
        printf("- p_path_load fail : %s\n", path);
        perror("file open failed");
        return;
      }
      reading_stack_push(file);
      p_repl();
      reading_stack_pop();
      fclose(file);
    }
    #+end_src

*** k_one_include

    #+begin_src c
    k_one_include() {
      // "..."
      char* path = malloc(PATH_MAX);
      cell cursor = 0;
      while (true) {
        char c = read_byte();
        if (c == '"') {
          path[cursor] = 0;
          cursor++;
          break;
        }
        else {
          path[cursor] = c;
          cursor++;
        }
      }
      char* real_read_path = get_real_reading_path(path);
      free(path);
      data_stack_push(real_read_path);
      p_path_load();
      free(real_read_path);
    }
    #+end_src

*** k_include

    #+begin_src c
    k_include() {
      // (include "..." ...)
      while (true) {
        jo s = read_raw_jo();
        if (s == ROUND_KET) {
          return;
        }
        else if (s == ROUND_BAR) {
          jo_apply(read_jo());
        }
        else if (s == DOUBLE_QUOTE) {
          k_one_include();
        }
        else {
          // do nothing
        }
      }
    }
    #+end_src

*** expose_file

    #+begin_src c
    expose_file() {
      define_prim("error-number/print", p_error_number_print);

      define_prim("path/open/read", p_path_open_read);
      define_prim("path/open/write", p_path_open_write);
      define_prim("path/open/create", p_path_open_create);
      define_prim("path/open/read-and-write", p_path_open_read_and_write);

      define_prim("file/close", p_file_close);

      define_prim("file/read", p_file_read);
      define_prim("file/write", p_file_write);

      define_prim("file/size", p_file_size);

      define_prim("file/regular-file?", p_file_regular_file_p);
      define_prim("file/directory?", p_file_directory_p);
      define_prim("file/character-device?", p_file_character_device_p);
      define_prim("file/block-device?", p_file_block_device_p);
      define_prim("file/fifo?", p_file_fifo_p);
      define_prim("file/socket?", p_file_socket_p);

      define_prim("path/exist?", p_path_exist_p);
      define_prim("path/readable?", p_path_readable_p);
      define_prim("path/writable?", p_path_writable_p);
      define_prim("path/executable?", p_path_executable_p);

      define_prim("file/print-path", p_file_print_path);

      define_prim("path/load", p_path_load);
      define_primkey("include", k_include);
    }
    #+end_src

* *system*

*** p_command_run

    #+begin_src c
    p_command_run() {
      // string -> {*}
      system(data_stack_pop());
    }
    #+end_src

*** p_n_command_run

    #+begin_src c
    p_n_command_run() {
      // ... string n -> *
      cell n = data_stack_pop();
      cell i = 0;
      char* str = malloc(4 * 1024);
      str[0] = 0;
      while (i < n) {
        strcat(str, data_stack[data_stack_pointer - n + i]);
        i++;
      }
      data_stack_pointer = data_stack_pointer - n;
      system(str);
      free(str);
    }
    #+end_src

*** p_cmd_number

    #+begin_src c
    cell cmd_number;

    p_cmd_number() {
      // -> cmd_number
      data_stack_push(cmd_number);
    }
    #+end_src

*** p_index_to_cmd_string

    #+begin_src c
    char** cmd_string_array;

    p_index_to_cmd_string() {
      // index -> string
      cell index = data_stack_pop();
      char* cmd_string = cmd_string_array[index];
      data_stack_push(cmd_string);
    }
    #+end_src

*** p_find_env_string

    #+begin_src c
    p_find_env_string() {
      // string -> [env-string true] or [false]
      char* var_string = data_stack_pop();
      char* env_string = getenv(var_string);
      if (env_string == NULL) {
        data_stack_push(false);
      }
      else {
        data_stack_push(env_string);
        data_stack_push(true);
      }
    }
    #+end_src

*** expose_system

    #+begin_src c
    expose_system() {
      define_prim("command/run", p_command_run);
      define_prim("n-command/run", p_n_command_run);
      define_prim("cmd-number", p_cmd_number);
      define_prim("index->cmd-string", p_index_to_cmd_string);
      define_prim("find-env-string", p_find_env_string);
    }
    #+end_src

* *cffi*

*** ccall

    #+begin_src c
    ccall (char* function_name, void* lib) {
      primitive fun = dlsym(lib, function_name);
      if (fun == NULL) {
        printf("- ccall fail\n");
        printf("  function_name : %s\n", function_name);
        printf("  dynamic link error : %s\n", dlerror());
      };
      fun();
    }
    #+end_src

*** k_clib_one

    #+begin_src c
    k_clib_one() {
      // "..."
      char* path = malloc(PATH_MAX);
      cell cursor = 0;
      while (true) {
        char c = read_byte();
        if (c == '"') {
          path[cursor] = 0;
          cursor++;
          break;
        }
        else {
          path[cursor] = c;
          cursor++;
        }
      }
      char* real_read_path = get_real_reading_path(path);
      free(path);
      void* lib = dlopen(real_read_path, RTLD_LAZY);
      if (lib == NULL) {
        printf("- k_clib_one fail to open library\n");
        printf("  real_read_path : %s\n", real_read_path);
        printf("  dynamic link error : %s\n", dlerror());
        p_debug();
        return;
      };
      free(real_read_path);
      ccall("expose", lib);
    }
    #+end_src

*** k_clib

    #+begin_src c
    k_clib() {
      // (clib "..." ...)
      while (true) {
        jo s = read_raw_jo();
        if (s == ROUND_KET) {
          return;
        }
        else if (s == DOUBLE_QUOTE) {
          k_clib_one();
        }
        else {
          // do nothing
        }
      }
    }
    #+end_src

*** expose_cffi

    #+begin_src c
    expose_cffi() {
      define_prim("clib", k_clib);
    }
    #+end_src

* *top_level*

*** k_define

    #+begin_src c
    k_run();

    k_define() {
      jo name = read_jo();
      k_run();
      data_stack_push(name);
      p_bind_name();
    }
    #+end_src

*** k_declare

***** note

      - no compile before define
        declare helps mutual recursive function

***** k_declare_one

      #+begin_src c
      k_declare_one() {
        jo jo = read_jo();
        jo->tag = JO_DECLARED;
        k_ignore();
      }
      #+end_src

***** k_declare

      #+begin_src c
      k_declare() {
        while (true) {
          jo s = read_jo();
          if (s == ROUND_KET) {
            return;
          }
          else if (s == ROUND_BAR) {
            k_declare_one();
          }
          else {
            // do nothing
          }
        }
      }
      #+end_src

*** k_run

    #+begin_src c
    p_compile_jojo();

    k_run() {
      // (run ...)
      jo* jojo = compiling_stack_tos();
      p_compile_jojo();
      return_stack_new_point(jojo);
      eval();
    }
    #+end_src

*** k_test

    #+begin_src c
    bool test_flag = false;
    p_test_flag() { data_stack_push(test_flag); }
    p_test_flag_on() { test_flag = true; }
    p_test_flag_off() { test_flag = false; }

    k_test() {
      if (test_flag) {
        k_run();
      }
      else {
        k_ignore();
      }
    }
    #+end_src

*** p_repl

    #+begin_src c
    bool repl_flag = false;
    p_repl_flag() { data_stack_push(repl_flag); }
    p_repl_flag_on() { repl_flag = true; }
    p_repl_flag_off() { repl_flag = false; }

    p_repl() {
      while (true) {
        if (!has_jo_p()) {
          return;
        }
        jo s = read_jo();
        if (s == ROUND_BAR) {
          jo_apply(read_jo());
          if (repl_flag) {
            p_print_data_stack();
          }
        }
        else {
          // loop
        }
      }
    }
    #+end_src

*** p_bare_jojo_print

    #+begin_src c
    p_bare_jojo_print() {
      // jojo -> {terminal-output}
      jo* jojo = data_stack_pop();
      printf("[ ");
      while (true) {
        if (jojo[0] == 0 && jojo[1] == 0) {
          break;
        }
        else if (jojo[0] == JO_INS_INT) {
          printf("(int %ld) ", jojo[1]);
          jojo++;
          jojo++;
        }
        else if (jojo[0] == JO_INS_JO) {
          printf("(jo %s) ", jo2str(jojo[1]));
          jojo++;
          jojo++;
        }
        else if (jojo[0] == JO_INS_STRING) {
          printf("(string \"%s\") ", (char*)jojo[1]);
          jojo++;
          jojo++;
        }
        else if (jojo[0] == JO_INS_BYTE) {
          printf("(btye \"%c\") ", (char)jojo[1]);
          jojo++;
          jojo++;
        }
        else if (jojo[0] == JO_INS_BARE_JOJO) {
          printf("(bare-jojo ");
          data_stack_push(jojo + 2);
          p_bare_jojo_print();
          printf(") ");
          jojo = jojo + (cell)jojo[1];
          jojo++;
        }
        else if (jojo[0] == JO_INS_ADDRESS) {
          printf("(address %ld) ", jojo[1]);
          jojo++;
          jojo++;
        }
        else if (jojo[0] == JO_INS_JUMP_IF_FALSE) {
          printf("(jump-if-false %ld) ", jojo[1]);
          jojo++;
          jojo++;
        }
        else if (jojo[0] == JO_INS_JUMP) {
          printf("(jump %ld) ", jojo[1]);
          jojo++;
          jojo++;
        }
        else if (jojo[0] == JO_INS_LOOP) {
          printf("(loop) ");
          jojo++;
          jojo++;
        }
        else if (jojo[0] == JO_INS_RECUR) {
          printf("(recur) ");
          jojo++;
          jojo++;
        }
        else if (jojo[0] == JO_INS_TAIL_CALL) {
          printf("(tail-call %s) ", jo2str(jojo[1]));
          jojo++;
          jojo++;
        }
        else {
          printf("%s ", jo2str(jojo[0]));
          jojo++;
        }
      }
      printf("] ");
    }
    #+end_src

*** point_return_point

    #+begin_src c
    point_return_point(cell i) {
      printf("    - ");
      if (i != return_stack_pointer -1) {
        printf("{ %s } ", jo2str(*(return_stack[i].jojo - 1)));
      }
      data_stack_push(return_stack[i].jojo);
      p_bare_jojo_print();
      printf("\n");

      cell cursor = return_stack[i].local_pointer;
      cell end = return_stack[i+1].local_pointer;
      if (i = return_stack_pointer -1) {
        end = current_local_pointer;
      }

      while (end > cursor) {
        printf("      %s = %ld %s\n"
               , jo2str(local_area[cursor].name)
               , local_area[cursor].local_data
               , jo2str(local_area[cursor].local_tag));
        cursor++;
      }
    }
    #+end_src

*** p_print_return_stack

    #+begin_src c
    p_print_return_stack() {
      cell i = return_stack_base;
      printf("  - return-stack :\n");
      while (i < return_stack_pointer) {
        point_return_point(i);
        i++;
      }
    }
    #+end_src

*** p_debug_repl

    #+begin_src c
    cell debug_repl_level = 0;

    p_debug_repl() {
      while (true) {
        if (!has_jo_p()) {
          return;
        }
        jo jo = read_raw_jo();
        if (jo == str2jo("help")) {
          printf("- debug-repl usage :\n");
          printf("  - available commands :\n");
          printf("    help exit bye\n");
        }
        else if (jo == str2jo("exit")) {
          return;
        }
        else if (jo == str2jo("bye")) {
          p_bye();
          return;
        }
        else if (jo == ROUND_BAR) {
          jo_apply(read_jo());
          p_print_data_stack();
          printf("debug[%ld]> ", debug_repl_level);
        }
        else {
          // loop
        }
      }
    }
    #+end_src

*** p_debug

    #+begin_src c
    p_debug() {
      reading_stack_push(stdin);

      printf("- in debug-repl [level %ld] >_<!\n", debug_repl_level);
      p_print_return_stack();
      p_print_data_stack();
      printf("debug[%ld]> ", debug_repl_level);
      debug_repl_level++;
      p_debug_repl();
      debug_repl_level--;
      printf("- exit debug-repl [level %ld]\n", debug_repl_level);

      reading_stack_pop();
    }
    #+end_src

*** stepper

    #+begin_src c
    cell stepper_counter = 0;
    cell pending_steps = 0;

    exit_stepper() {
      step_flag = false;
      stepper_counter = 0;
      pending_steps = 0;
      printf("- exit stepper\n");
    }

    stepper() {
      printf("stepper> ");
      while (true) {

        if (return_stack_empty_p()) {
          printf("\n");
          printf("- the return-stack is empty\n");
          exit_stepper();
          return;
        }

        if (pending_steps > 0) {
          p_print_return_stack();
          p_print_data_stack();
          stepper_counter++;
          printf("- stepper counting : %ld\n", stepper_counter);
          pending_steps--;
          return;
        }

        jo jo = read_raw_jo();
        if (jo == str2jo("help")) {
          printf("- stepper usage :\n");
          printf("  type '.' to execute one step\n");
          printf("  type a numebr to execute the number of steps\n");
          printf("  - available commands :\n");
          printf("    help exit bye\n");
        }
        else if (jo == str2jo(".")) {
          p_print_return_stack();
          p_print_data_stack();
          stepper_counter++;
          printf("- stepper counting : %ld\n", stepper_counter);
          return;
        }
        else if (nat_string_p(jo2str(jo))) {
          p_print_return_stack();
          p_print_data_stack();
          stepper_counter++;
          printf("- stepper counting : %ld\n", stepper_counter);
          pending_steps = string_to_int(jo2str(jo)) - 1;
          return;
        }
        else if (jo == str2jo("exit")) {
          exit_stepper();
          return;
        }
        else if (jo == str2jo("bye")) {
          p_bye();
          return;
        }
        else {
          // loop
        }
      }
    }
    #+end_src

*** p_step

    #+begin_src c
    p_step() {
      step_flag = true;
    }
    #+end_src

*** to handle kernel signal

***** note

      - A function is said to be reentrant
        if it can safely be simultaneously executed
        by multiple threads of execution in the same process.
        In this context, “safe” means that
        the function achieves its expected result,
        regardless of the state of execution
        of any other thread of execution.

        Because a signal handler may asynchronously interrupt
        the execution of a program at any point in time,
        the main program and the signal handler
        in effect form two independent
        (although not concurrent) threads of execution
        within the same process.

        -- quote from (2010) (michael kerrisk) the linux programming interface

      - thus single handler must be reentrant.

      - since nonreentrant functions in many C libraries [specially stdio],
        and we can call such functions in the debug repl of jojo,
        we should not simply call the debug repl in the kernel_signal_handler.

      - but except introducing runtime overhead,
        I can think of not solutions to this problem.

        thus, after exited the debug repl,
        possibly unnecessary errors that induced by nonreentrant functions,
        might lead you into the debug repl again.

        thus, the debug repl is not reliable to enable you
        to recover from any errors which trigger kernel signal.
        [the debug repl can only debug them.]

***** kernel_signal_handler

      #+begin_src c
      kernel_signal_handler(int sig, siginfo_t *siginfo, void *ucontext) {
        fflush(stdin);
        fflush(stdout);
        fflush(stderr);

        printf("- kernel_signal_handler\n");
        psiginfo(siginfo, "  signal ");

        int errno_backup;
        errno_backup = errno;

        p_debug();

        errno = errno_backup;
      }
      #+end_src

***** init_kernel_signal_handler

      #+begin_src c
      init_kernel_signal_handler() {
        struct sigaction kernel_signal_action;

        sigemptyset(&kernel_signal_action.sa_mask);

        kernel_signal_action.sa_flags = SA_SIGINFO | SA_NODEFER | SA_RESTART;
        kernel_signal_action.sa_sigaction = kernel_signal_handler;

        int sig_array[] = { SIGSEGV, SIGBUS, SIGFPE, SIGILL,
                            SIGPIPE, SIGSYS, SIGXCPU, SIGXFSZ};
        int sig_array_length = sizeof(sig_array)/sizeof(sig_array[0]);
        cell i = 0;
        while (i < sig_array_length) {
          if (sigaction(sig_array[i], &kernel_signal_action, NULL) == -1) {
            perror("- init_kernel_signal_handler fail");
          }
          i++;
        }
      }
      #+end_src

*** expose_top_level

    #+begin_src c
    expose_top_level() {
      define_primkey("define", k_define);
      define_primkey("bind-name", p_bind_name);
      define_primkey("declare", k_declare);

      define_primkey("run", k_run);

      define_primkey("test", k_test);
      define_prim("test-flag", p_test_flag);
      define_prim("test-flag/on", p_test_flag_on);
      define_prim("test-flag/off", p_test_flag_off);

      define_prim("repl", p_repl);
      define_prim("repl-flag", p_repl_flag);
      define_prim("repl-flag/on", p_repl_flag_on);
      define_prim("repl-flag/off", p_repl_flag_off);

      define_prim("bare-jojo/print", p_bare_jojo_print);
      define_prim("print-return-stack", p_print_return_stack);
      define_prim("debug", p_debug);

      define_prim("step", p_step);
    }
    #+end_src

* *keyword*

*** k_ignore

    #+begin_src c
    k_ignore() {
      while (true) {
        jo s = read_raw_jo();
        if (s == ROUND_BAR) {
          k_ignore();
        }
        if (s == ROUND_KET) {
          break;
        }
      }
    }
    #+end_src

*** compile_until_meet_jo

    #+begin_src c
    compile_until_meet_jo(jo ending_jo) {
      while (true) {
        jo jo = read_jo();
        if (jo == ROUND_BAR) {
          jo_apply(read_jo());
        }
        else if (jo == ending_jo) {
          break;
        }
        else if (used_jo_p(jo)) {
          here(jo);
        }
        else {
          // no compile before define
          printf("- compile_until_meet_jo undefined : %s\n", jo2str(jo));
          k_ignore();
          p_debug();
          return;
        }
      }
    }
    #+end_src

*** p_compile_until_meet_jo

    #+begin_src c
    p_compile_until_meet_jo() {
      compile_until_meet_jo(data_stack_pop());
    }
    #+end_src

*** compile_until_meet_jo_or_jo

    #+begin_src c
    jo compile_until_meet_jo_or_jo(jo ending_jo1, jo ending_jo2) {
      while (true) {
        jo jo = read_jo();
        if (jo == ROUND_BAR) {
          jo_apply(read_jo());
        }
        else if (jo == ending_jo1 || jo == ending_jo2) {
          return jo;
        }
        else if (used_jo_p(jo)) {
          here(jo);
        }
        else {
          // no compile before define
          printf("- compile_until_meet_jo_or_jo undefined : %s\n", jo2str(jo));
          printf("- ending_jo1 : %s\n", jo2str(ending_jo1));
          printf("- ending_jo2 : %s\n", jo2str(ending_jo2));
          k_ignore();
          p_debug();
          return JO_NULL; // to fool the compiler
        }
      }
    }
    #+end_src

*** p_compile_until_round_ket

    #+begin_src c
    p_compile_until_round_ket() {
      compile_until_meet_jo(ROUND_KET);
    }
    #+end_src

*** i_jump

    #+begin_src c
    i_jump() {
      // {return_stack}
      return_point rp = return_stack_tos();
      jo* jojo = rp.jojo;
      cell offset = jojo[0];
      return_point rp1 = return_stack_pop();
      return_stack_make_point(jojo + offset, rp1.local_pointer);
    }
    #+end_src

*** k_jump

    #+begin_src c
    k_jump() {
      here(JO_INS_JUMP);
      here(string_to_int(jo2str(read_raw_jo())));
      k_ignore();
    }
    #+end_src

*** i_jump_if_false

    #+begin_src c
    i_jump_if_false() {
      // [bool] -> {return_stack}
      return_point rp = return_stack_tos();
      return_stack_inc();
      jo* jojo = rp.jojo;
      cell offset = jojo[0];
      cell b = data_stack_pop();
      if (b == false) {
        return_point rp1 = return_stack_pop();
        return_stack_make_point(jojo + offset, rp1.local_pointer);
      }
    }
    #+end_src

*** k_jump_if_false

    #+begin_src c
    k_jump_if_false() {
      here(JO_INS_JUMP_IF_FALSE);
      here(string_to_int(jo2str(read_raw_jo())));
      k_ignore();
    }
    #+end_src

*** k_if

    #+begin_src c
    // - without else
    //   (if a b p? then c d)
    //   ==>
    //     a b p?
    //     jump_if_false[:end-of-then]
    //     c d
    //   :end-of-then

    // - with else
    //   (if a b p? then c d else e f)
    //   ==>
    //     a b p?
    //     jump_if_false[:end-of-then]
    //     c d
    //     jump[:end-of-else]
    //   :end-of-then
    //     e f
    //   :end-of-else

    k_if() {
      compile_until_meet_jo(JO_THEN);
      here(JO_INS_JUMP_IF_FALSE);
      jo* end_of_then = compiling_stack_tos();
      compiling_stack_inc();
      jo ending_jo = compile_until_meet_jo_or_jo(JO_ELSE, ROUND_KET);
      if (ending_jo == ROUND_KET) {
        end_of_then[0] = compiling_stack_tos() - end_of_then;
        return;
      }
      else {
        here(JO_INS_JUMP);
        jo* end_of_else = compiling_stack_tos();
        compiling_stack_inc();
        end_of_then[0] = compiling_stack_tos() - end_of_then;
        p_compile_until_round_ket();
        end_of_else[0] = compiling_stack_tos() - end_of_else;
        return;
      }
    }
    #+end_src

*** current_compiling_jojo_stack

    #+begin_src c
    typedef jo current_compiling_jojo_stack_t[1024];

    current_compiling_jojo_stack_t current_compiling_jojo_stack;
    cell current_compiling_jojo_stack_base = 0;
    cell current_compiling_jojo_stack_pointer = 0;

    current_compiling_jojo_stack_push(jo* value) {
      current_compiling_jojo_stack[current_compiling_jojo_stack_pointer] = value;
      current_compiling_jojo_stack_pointer++;
    }

    jo* current_compiling_jojo_stack_pop() {
      current_compiling_jojo_stack_pointer--;
      return current_compiling_jojo_stack[current_compiling_jojo_stack_pointer];
    }

    current_compiling_jojo_stack_inc() {
      current_compiling_jojo_stack[current_compiling_jojo_stack_pointer - 1] =
        current_compiling_jojo_stack[current_compiling_jojo_stack_pointer - 1] + 1;
    }


    jo* current_compiling_jojo_stack_tos() {
      return current_compiling_jojo_stack[current_compiling_jojo_stack_pointer - 1];
    }

    bool current_compiling_jojo_stack_empty_p() {
      return current_compiling_jojo_stack_pointer == current_compiling_jojo_stack_base;
    }
    #+end_src

*** p_compile_jojo

    #+begin_src c
    p_compile_jojo() {
      jo* jojo = compiling_stack_tos();
      current_compiling_jojo_stack_push(jojo);
      compile_until_meet_jo(ROUND_KET);
      here(JO_END);
      here(0);
      here(0);
      current_compiling_jojo_stack_pop();
    }
    #+end_src

*** i_tail_call

    #+begin_src c
    i_tail_call() {
      return_point rp = return_stack_pop();
      jo* jojo = rp.jojo;
      jo jo = jojo[0];
      jo_apply_with_local_pointer(jo, rp.local_pointer);
    }
    #+end_src

*** k_tail_call

    #+begin_src c
    k_tail_call() {
      // no check for "no compile before define"
      here(JO_INS_TAIL_CALL);
      here(read_jo());
      k_ignore();
    }
    #+end_src

*** i_loop

    #+begin_src c
    i_loop() {
      return_point rp = return_stack_pop();
      jo* jojo = rp.jojo;
      jo* jojo_self = jojo[0];
      return_stack_make_point(jojo_self, rp.local_pointer);
    }
    #+end_src

*** k_loop

    #+begin_src c
    k_loop() {
      here(JO_INS_LOOP);
      here(current_compiling_jojo_stack_tos());
      k_ignore();
    }
    #+end_src

*** i_recur

    #+begin_src c
    i_recur() {
      return_point rp = return_stack_tos();
      return_stack_inc();
      jo* jojo = rp.jojo;
      jo* jojo_self = jojo[0];
      return_stack_new_point(jojo_self);
    }
    #+end_src

*** k_recur

    #+begin_src c
    k_recur() {
      here(JO_INS_RECUR);
      here(current_compiling_jojo_stack_tos());
      k_ignore();
    }
    #+end_src

*** p_compiling_stack_tos

    #+begin_src c
    p_compiling_stack_tos() {
      data_stack_push(compiling_stack_tos());
    }
    #+end_src

*** i_bare_jojo

    #+begin_src c
    i_bare_jojo() {
      return_point rp = return_stack_pop();
      jo* jojo = rp.jojo;
      cell offset = jojo[0];
      return_point rp1 = {.jojo = jojo + offset,
                          .local_pointer = rp.local_pointer};
      return_stack_push(rp1);
      data_stack_push(jojo + 1);
    }
    #+end_src

*** k_bare_jojo

    #+begin_src c
    k_bare_jojo() {
      // (bare-jojo ...)
      here(JO_INS_BARE_JOJO);
      jo* beginning = compiling_stack_tos();
      compiling_stack_inc();
      p_compile_jojo();
      beginning[0] = (compiling_stack_tos() - beginning);
    }
    #+end_src

*** k_jojo

    #+begin_src c
    k_jojo() {
      // (jojo ...)
      k_bare_jojo();
      here(JO_INS_JO);
      here(TAG_JOJO);
    }
    #+end_src

*** k_keyword

    #+begin_src c
    k_keyword() {
      // (keyword ...)
      k_bare_jojo();
      here(JO_INS_JO);
      here(TAG_KEYWORD);
    }
    #+end_src

*** k_data

    - the semantic of this keyword has limitation,
      there can be not 'end' in it.

    #+begin_src c
    k_data() {
      // (data ...)
      p_compile_until_round_ket();
      here(JO_INS_JO);
      here(TAG_DATA);
    }
    #+end_src

*** local_find

    #+begin_src c
    cell local_find(jo name) {
      // return index of local_area
      // -1 -- no found
      return_point rp = return_stack_tos();
      cell cursor = current_local_pointer - 1;
      while (cursor >= rp.local_pointer) {
        if (local_area[cursor].name == name) {
          return cursor;
        }
        else {
          cursor--;
        }
      }
      return -1;
    }
    #+end_src

*** p_local_data_in

    #+begin_src c
    p_local_data_in() {
      cell jo = data_stack_pop();
      cell index = local_find(jo);
      cell data = data_stack_pop();
      if (index != -1) {
        local_area[index].name = jo;
        local_area[index].local_data = data;
      }
      else {
        local_area[current_local_pointer].name = jo;
        local_area[current_local_pointer].local_data = data;
        current_local_pointer = current_local_pointer + 1;
      }
    }
    #+end_src

*** p_local_data_out

    #+begin_src c
    p_local_data_out() {
      cell jo = data_stack_pop();
      cell index = local_find(jo);
      if (index != -1) {
        local_point lp = local_area[index];
        data_stack_push(lp.local_data);
      }
      else {
        printf("- p_local_data_out fatal error\n");
        printf("  name is not bound\n");
        printf("  name : %s\n", jo2str(jo));
        p_debug();
      }
    }
    #+end_src

*** p_local_tag_in

    #+begin_src c
    p_local_tag_in() {
      cell jo = data_stack_pop();
      cell index = local_find(jo);
      cell tag = data_stack_pop();
      if (index != -1) {
        local_area[index].name = jo;
        local_area[index].local_tag = tag;
      }
      else {
        local_area[current_local_pointer].name = jo;
        local_area[current_local_pointer].local_tag = tag;
        current_local_pointer = current_local_pointer + 1;
      }
    }
    #+end_src

*** p_local_tag_out

    #+begin_src c
    p_local_tag_out() {
      cell jo = data_stack_pop();
      cell index = local_find(jo);
      if (index != -1) {
        local_point lp = local_area[index];
        data_stack_push(lp.local_tag);
      }
      else {
        printf("- p_local_tag_out fatal error\n");
        printf("  name is not bound\n");
        printf("  name : %s\n", jo2str(jo));
        p_debug();
      }
    }
    #+end_src

*** p_local_in

    #+begin_src c
    p_local_in() {
      cell jo = data_stack_pop();
      cell index = local_find(jo);
      cell tag = data_stack_pop();
      cell data = data_stack_pop();
      if (index != -1) {
        local_area[index].name = jo;
        local_area[index].local_tag = tag;
        local_area[index].local_data = data;
      }
      else {
        local_area[current_local_pointer].name = jo;
        local_area[current_local_pointer].local_tag = tag;
        local_area[current_local_pointer].local_data = data;
        current_local_pointer = current_local_pointer + 1;
      }
    }
    #+end_src

*** p_local_out

    #+begin_src c
    p_local_out() {
      cell jo = data_stack_pop();
      cell index = local_find(jo);
      if (index != -1) {
        local_point lp = local_area[index];
        data_stack_push(lp.local_data);
        data_stack_push(lp.local_tag);
      }
      else {
        printf("- p_local_out fatal error\n");
        printf("  name is not bound\n");
        printf("  name : %s\n", jo2str(jo));
        p_debug();
      }
    }
    #+end_src

*** k_local_data_in

    #+begin_src c
    k_local_data_in() {
      jo s = read_raw_jo();
      if (s == ROUND_KET) {
        return;
      }
      else {
        k_local_data_in();

        here(JO_INS_JO);
        here(s);
        here(JO_LOCAL_DATA_IN);
      }
    }
    #+end_src

*** k_local_data_out

    #+begin_src c
    k_local_data_out() {
      jo s = read_raw_jo();
      if (s == ROUND_KET) {
        return;
      }
      else {
        here(JO_INS_JO);
        here(s);
        here(JO_LOCAL_DATA_OUT);

        k_local_data_out();
      }
    }
    #+end_src

*** k_local_tag_in

    #+begin_src c
    k_local_tag_in() {
      jo s = read_raw_jo();
      if (s == ROUND_KET) {
        return;
      }
      else {
        k_local_data_in();

        here(JO_INS_JO);
        here(s);
        here(JO_LOCAL_TAG_IN);
      }
    }
    #+end_src

*** k_local_tag_out

    #+begin_src c
    k_local_tag_out() {
      jo s = read_raw_jo();
      if (s == ROUND_KET) {
        return;
      }
      else {
        here(JO_INS_JO);
        here(s);
        here(JO_LOCAL_TAG_OUT);

        k_local_data_out();
      }
    }
    #+end_src

*** k_local_in

    #+begin_src c
    k_local_in() {
      jo s = read_raw_jo();
      if (s == ROUND_KET) {
        return;
      }
      else {
        k_local_data_in();

        here(JO_INS_JO);
        here(s);
        here(JO_LOCAL_IN);
      }
    }
    #+end_src

*** k_local_out

    #+begin_src c
    k_local_out() {
      jo s = read_raw_jo();
      if (s == ROUND_KET) {
        return;
      }
      else {
        here(JO_INS_JO);
        here(s);
        here(JO_LOCAL_OUT);

        k_local_data_out();
      }
    }
    #+end_src

*** p_current_local_pointer

    #+begin_src c
    p_current_local_pointer() {
      data_stack_push(current_local_pointer);
    }
    #+end_src

*** p_last_local_pointer

    #+begin_src c
    p_last_local_pointer() {
      return_point rp = return_stack_tos();
      data_stack_push(rp.local_pointer);
    }
    #+end_src

*** expose_keyword

    #+begin_src c
    expose_keyword() {
      define_primkey("ignore", k_ignore);
      define_primkey("note", k_ignore);

      define_prim("compiling-stack/tos", p_compiling_stack_tos);
      define_prim("compiling-stack/inc", compiling_stack_inc);

      define_prim("compile-until-meet-jo", p_compile_until_meet_jo);
      define_prim("compile-until-round-ket", p_compile_until_round_ket);


      define_prim("ins/jump", i_jump);
      define_primkey("jump", k_jump);

      define_prim("ins/jump-if-false", i_jump_if_false);
      define_primkey("jump-if-false", k_jump_if_false);

      define_primkey("if", k_if);
      define_primkey("else", p_compile_until_round_ket);
      define_primkey("el", p_compile_until_round_ket);

      define_prim("compile-jojo", p_compile_jojo);

      define_prim("ins/tail-call", i_tail_call);
      define_primkey("tail-call", k_tail_call);
      define_prim("ins/loop", i_loop);
      define_primkey("loop", k_loop);
      define_prim("ins/recur", i_recur);
      define_primkey("recur", k_recur);

      define_primkey("data", k_data);
      define_primkey("jojo", k_jojo);
      define_primkey("keyword", k_keyword);

      define_prim("ins/bare-jojo", i_bare_jojo);
      define_primkey("bare-jojo", k_bare_jojo);

      define_prim("local-data-in", p_local_data_in);
      define_prim("local-data-out", p_local_data_out);
      define_primkey(">", k_local_data_in);
      define_primkey("<", k_local_data_out);

      define_prim("local-tag-in", p_local_tag_in);
      define_prim("local-tag-out", p_local_tag_out);
      define_primkey("%>", k_local_tag_in);
      define_primkey("<%", k_local_tag_out);

      define_prim("local-in", p_local_in);
      define_prim("local-out", p_local_out);
      define_primkey(">>", k_local_in);
      define_primkey("<<", k_local_out);

      define_prim("current-local-pointer", p_current_local_pointer);
      define_prim("last-local-pointer", p_last_local_pointer);
    }
    #+end_src

* *misc*

*** p_here

    #+begin_src c
    p_here() {
      here(data_stack_pop());
    }
    #+end_src

*** p_address_of_here

    #+begin_src c
    p_address_of_here() {
     data_stack_push(compiling_stack_tos());
    }
    #+end_src

*** bar and ket

    #+begin_src c
    p_round_bar()    { data_stack_push(ROUND_BAR); }
    p_round_ket()    { data_stack_push(ROUND_KET); }
    p_square_bar()   { data_stack_push(SQUARE_BAR); }
    p_square_ket()   { data_stack_push(SQUARE_KET); }
    p_flower_bar()   { data_stack_push(FLOWER_BAR); }
    p_flower_ket()   { data_stack_push(FLOWER_KET); }
    p_double_quote() { data_stack_push(DOUBLE_QUOTE); }
    #+end_src

*** p_cell_size

    #+begin_src c
    p_cell_size() {
      data_stack_push(CELL_SIZE);
    }
    #+end_src

*** p_newline

    #+begin_src c
    p_newline() {
      printf("\n");
    }
    #+end_src

*** expose_mise

    #+begin_src c
    expose_mise() {
      define_prim("here", p_here);
      define_prim("address-of-here", p_address_of_here);

      define_prim("round-bar", p_round_bar);
      define_prim("round-ket", p_round_ket);
      define_prim("square-bar", p_square_bar);
      define_prim("square-ket", p_square_ket);
      define_prim("flower-bar", p_flower_bar);
      define_prim("flower-ket", p_flower_ket);
      define_prim("double-quote", p_double_quote);

      define_prim("cell-size", p_cell_size);

      define_prim("newline", p_newline);
    }
    #+end_src

* *play*

*** expose_play

    #+begin_src c
    expose_play() {
    }
    #+end_src

* main

*** init_jotable

    #+begin_src c
    init_jotable() {
      bzero(jotable, jotable_size * sizeof(jotable_entry));
    }
    #+end_src

*** init_literal_jo

    #+begin_src c
    init_literal_jo() {
      EMPTY_JO = str2jo("");

      TAG_PRIM         = str2jo("<prim>");
      TAG_JOJO         = str2jo("<jojo>");
      TAG_PRIM_KEYWORD = str2jo("<prim-keyword>");
      TAG_KEYWORD      = str2jo("<keyword>");
      TAG_DATA         = str2jo("<data>");

      JO_DECLARED = str2jo("declared");

      ROUND_BAR    =   str2jo("(");
      ROUND_KET    =   str2jo(")");
      SQUARE_BAR   =   str2jo("[");
      SQUARE_KET   =   str2jo("]");
      FLOWER_BAR   =   str2jo("{");
      FLOWER_KET   =   str2jo("}");
      DOUBLE_QUOTE =   str2jo("\"");

      JO_INS_INT  = str2jo("ins/int");
      JO_INS_JO   = str2jo("ins/jo");
      JO_INS_STRING = str2jo("ins/string");
      JO_INS_BYTE = str2jo("ins/byte");
      JO_INS_BARE_JOJO = str2jo("ins/bare-jojo");
      JO_INS_ADDRESS = str2jo("ins/address");

      JO_INS_JUMP = str2jo("ins/jump");
      JO_INS_JUMP_IF_FALSE = str2jo("ins/jump-if-false");

      JO_INS_TAIL_CALL = str2jo("ins/tail-call");
      JO_INS_LOOP = str2jo("ins/loop");
      JO_INS_RECUR = str2jo("ins/recur");

      JO_NULL     = str2jo("null");
      JO_THEN     = str2jo("then");
      JO_ELSE     = str2jo("else");

      JO_APPLY     = str2jo("apply");
      JO_END       = str2jo("end");

      JO_LOCAL_DATA_IN = str2jo("local-data-in");
      JO_LOCAL_DATA_OUT = str2jo("local-data-out");

      JO_LOCAL_TAG_IN = str2jo("local-tag-in");
      JO_LOCAL_TAG_OUT = str2jo("local-tag-out");

      JO_LOCAL_IN = str2jo("local-in");
      JO_LOCAL_OUT = str2jo("local-out");
    }
    #+end_src

*** init_jojo

    #+begin_src c
    init_jojo() {
      init_jotable();
      init_literal_jo();

      init_compiling_stack();
      init_jo_filter_stack();
      init_kernel_signal_handler();

      p_empty_jo();
      p_drop();

      expose_bind();
      expose_apply();
      expose_stack_operation();
      expose_ending();
      expose_bool();
      expose_int();
      expose_memory();
      expose_byte();
      expose_jo();
      expose_string();
      expose_file();
      expose_keyword();
      expose_system();
      expose_cffi();
      expose_top_level();
      expose_mise();

      expose_play();
    }
    #+end_src

*** init_core

    #+begin_src c
    #include "core.h"

    init_core() {
      FILE* core_file = fmemopen(core_jo, core_jo_len, "r");
      reading_stack_push(core_file);
      p_repl();
      reading_stack_pop();
      fclose(core_file);
    }
    #+end_src

*** main

    #+begin_src c
    main(int argc, char** argv) {
      cmd_number = argc;
      cmd_string_array = argv;
      init_jojo();
      init_core();
      p_repl();
    }
    #+end_src
