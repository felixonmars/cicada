#+property: tangle jojo.py
#+title: jojo on python

* [todo-stack]

  - fix arguments of function call

  - re-expose all built in functions

  - specify which semantic subset of python is captured by jojo

  - a compiler, in jojo on c, to compile jojo to python

  - rewrite the compiler, in jojo on python

* import

  #+begin_src python
  import inspect
  import types
  #+end_src

* utility

*** get_signature

    #+begin_src python
    def get_signature(fun):
        try:
            return inspect.signature(fun)
        except ValueError:
            return False
    #+end_src

*** fun_p

    #+begin_src python
    def fun_p(x):
        if isinstance(x, types.LambdaType):
            return True
        elif isinstance(x, types.MethodType):
            return True
        else:
            return False
    #+end_src

*** class_p

    #+begin_src python
    def class_p(x):
        if not inspect.isclass(x):
            return False
        elif x == type:
            return False
        else:
            return True
    #+end_src

* VM

*** RP

    #+begin_src python
    class RP:
        def __init__(self, fun):
            self.cursor = 0
            self.length = fun.length
            self.body = fun.body
            self.lr = fun.lr.copy()
    #+end_src

*** VM

    #+begin_src python
    class VM:
        def __init__(self, ds, rs):
            self.ds = ds
            self.rs = rs
    #+end_src

*** push_result_to_vm

    #+begin_src python
    def push_result_to_vm(result, vm):
        if isinstance(result, tuple):
            vm.ds.extend(result)
        elif result == None:
            pass
        else:
            vm.ds.append(result)
    #+end_src

* jo

*** LGET

    #+begin_src python
    class LGET:
        def __init__(self, name):
            self.name = name

        def jo_exe(self, rp, vm):
            value = rp.lr[self.name]
            vm.ds.append(value)
    #+end_src

*** LSET

    #+begin_src python
    class LSET:
        def __init__(self, name):
            self.name = name

        def jo_exe(self, rp, vm):
            value = vm.ds.pop()
            rp.lr[self.name] = value
    #+end_src

*** JOJO

    #+begin_src python
    class JOJO:
        def __init__(self, *body):
            self.length = len(body)
            self.body = list(body)
            self.lr = {}

        def jo_exe(self, rp, vm):
            vm.rs.append(RP(self))
    #+end_src

*** MSG

    #+begin_src python
    class MSG:
        def __init__(self, message):
            self.message = message

        def jo_exe(self, rp, vm):
            o = vm.ds.pop()
            fun = getattr(o, self.message)
            exe_jo(fun, rp, vm)
    #+end_src

*** CLO

***** CLOSURE

      #+begin_src python
      class CLOSURE:
          def __init__(self, body, lr):
              self.length = len(body)
              self.body = body
              self.lr = lr
      #+end_src

***** CLO

      #+begin_src python
      class CLO:
          @classmethod
          def jo_exe(cls, rp, vm):
              body = vm.ds.pop()
              lr = rp.lr
              clo = CLOSURE(body, lr)
              vm.ds.append(clo)
      #+end_src

*** APPLY

    #+begin_src python
    class APPLY:
        @classmethod
        def jo_exe(cls, rp, vm):
            clo = vm.ds.pop()
            vm.rs.append(RP(clo))
    #+end_src

*** IFTE

    #+begin_src python
    class IFTE:
        @classmethod
        def jo_exe(self, rp, vm):
            clo2 = vm.ds.pop()
            clo1 = vm.ds.pop()
            test = vm.ds.pop()
            if test:
                vm.rs.append(RP(clo1))
            else:
                vm.rs.append(RP(clo2))
    #+end_src

*** NEW

    #+begin_src python
    class NEW:
        @classmethod
        def jo_exe(self, rp, vm):
            c = vm.ds.pop()
            if not class_p(c):
                print ("- NEW.jo_exe fail")
                print ("  argument is not a class : {}".format(c))
            exe_fun(c, vm)
    #+end_src

* exe

*** exe

    #+begin_src python
    def exe(vm):
        while vm.rs != []:
            exe_one_step(vm)
            print (vm.ds)
        print ("- exe end")
        return vm
    #+end_src

*** exe_one_step

    #+begin_src python
    def exe_one_step(vm):
        rp = vm.rs.pop()
        jo = rp.body[rp.cursor]

        # handle tail call
        if rp.cursor >= rp.length - 1:
           pass
        else:
           rp.cursor = rp.cursor + 1
           vm.rs.append(rp)

        # dispatching
        exe_jo(jo, rp, vm)
    #+end_src

*** exe_jo

    #+begin_src python
    def exe_jo(jo, rp, vm):
        if fun_p(jo):
            exe_fun(jo, vm)
        elif hasattr(jo, "jo_exe"):
            jo.jo_exe(rp, vm)
        else:
            vm.ds.append(jo)
    #+end_src

*** exe_fun

    #+begin_src python
    def exe_fun(fun, vm):
        signature = get_signature(fun)
        if not signature:
            print ("- exe_fun fail to get signature")
            print ("  fun : {}".format(fun))

        parameters = signature.parameters
        length = len(parameters)
        arguments = []
        i = 0
        while i < length:
            arguments.append(vm.ds.pop())
            i = i + 1
        arguments.reverse()

        result = fun(*arguments)

        push_result_to_vm(result, vm)
    #+end_src

* stack operation

  #+begin_src python
  def drop(a):
      return ()

  def dup(a):
      return (a, a)

  def over(a, b):
      return (a, b, a)

  def tuck(a, b):
      return (b, a, b)

  def swap(a, b):
      return (b, a)
  #+end_src

* number

  #+begin_src python
  def add(a, b):
      return a + b
  #+end_src
