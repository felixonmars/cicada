#+title: recall sequent0
- EOPL in jojo
* [todo-stack]
* [note]

*** local-name in (jojo)

    - in jojo :
      - named // [(: :local-name type)]
        as assertion, during type-check leave the type in stack
      - unname // [type]
        during computation leave object in stack

    - a jojo always has type with it.
      there is no other simple way to get a trunk of function.

*** (type)

    - every field of product must be named
    - product occurs in data-constructor and type-constructor

*** function application [and constructor application]

    - currently
      during application arguments are not named
      and the order of argument is important

      this is not generic

    - to be generic
      we need to mimic object creation of object system
      and avoid pattern-matching

    - when a type has branches
      name of branches can be used as data-constructor

*** unification need uni-id

    - 解法 :
      1. uni-copy
      2. compile to peek and put [of stack]

*** 原則

    - 注意如下原則 :
      1. 信息不減
      2. 證明語義優先

* <class>

  - a class is a function of type (-> [] [<class>])

  - to create a class
    we call the class

  - a class does not have branches

  - to create a object of a class
    we call 'new' on the class
    and set the fields of the newly created object

  #+begin_src jojo
  (+class <rectangle> [<object>]
    (: .height <nat>)
    (: .width <nat>))

  (+class <color-rectangle> [<rectangle>]
    (: .cyan <nat>)
    (: .magenta <nat>)
    (: .yellow <nat>))

  (+ <rectangle> new :rectangle dup
     3 :rectangle.height!
     4 :rectangle.width!)
  #+end_src

* <type>

  - a type is a function of type (-> [...] [<type>])

  - to create a type
    we call the type

  - a type always has branches

  - a branches of a type is a function of type
    (-> [...] [... the-type])

  - to create a object of a type
    we call its branch

  - x -
    although there are no pattern-matching for data-constructors,
    but there are still pattern-matching for type-constructors.

    how to understand this ?

  - k -
    we siad we can let type inherit type,
    when that happens,
    how should argument of type should be handled ?

* <nat>

  #+begin_src jojo
  (+type <nat> (-> [] <type>)
    zero (-> [] <nat>)
    succ (-> (: .pre <nat>) <nat>))
  (note
    (+ <nat>
       (type (-> [] <type>)
         zero (-> [] <nat>)
         succ (-> (: .pre <nat>) <nat>))))

  (+jojo add (-> [(: :m <nat>) (: :n <nat>)] <nat>)
    (case :n
      zero [:m]
      succ [:m :n.pre (recur) succ]))

  (+jojo mul (-> [(: :m <nat>) (: :n <nat>)] <nat>)
    (case :n
      zero [zero]
      succ [:m :n.pre (recur) :n add]))

  (+jojo factorial (-> (: :n <nat>) <nat>)
    (case :n
      zero [zero succ]
      succ [:n.pre (recur) :n mul]))
  (note
    (+ factorial
       (jojo (-> (: :n <nat>) <nat>)
         (case :n
           zero [zero succ]
           succ [:n.pre (recur) :n mul]))))

  (+jojo nat-induction
      (-> [(: :p (-> <nat> <type>))
           (: :pz zero @:p)
           (: :ps (-> [(:k <nat>) :k @:p] [:k succ @:p]))
           (: :x <nat>)]
          [:x @:p])
    (case :x
      zero :pz
      succ [:x.pre :p :pz :ps :x.pre (recur) @:ps]))
  #+end_src

* stack

  - ':name' as local-variable for data
    also as local-variable for type

  #+begin_src jojo
  (+jojo drop (-> [(: :d :t)] [])
    (case :d
      * []))

  (+jojo dup (-> [(: :d :t)] [:t :t])
    (case :d
      * [:d :d]))

  (+jojo over (-> [(: :d0 :t0) (: :d1 :t1)] [:t0 :t1 :t0])
    (case [:d0 :d1]
      * * [:d0 :d1 :d0]))

  (+jojo tuck (-> [(: :d0 :t0) (: :d1 :t1)] [:t1 :t0 :t1])
    (case [:d0 :d1]
      * * [:d1 :d0 :d1]))

  (+jojo swap (-> [(: :d0 :t0) (: :d1 :t1)] [:t1 :t0])
    (case [:d0 :d1]
      * * [:d1 :d0]))

  (+ zero succ
     zero succ succ
     add)

  (+ drop)

  (+ zero succ succ succ
     zero succ succ succ
     mul)

  (+ drop)

  (+ zero succ succ succ
     factorial)

  (+ drop)
  #+end_src

* <vector>

  #+begin_src jojo
  (+type <vector> (-> [<nat> <type>] <type>)
    null (-> [] [zero :t <vector>])
    cons (-> [(: .cdr [:n :t <vector>])
              (: .car :t)]
             [:n succ :t <vector>]))

  ;; we want to say <vector> inherit <list>
  ;; thus not need to repeat the function body

  ;; or should we say <list> forget the length information in <vector>

  (+jojo append (-> [(: :l0 [:m :t <vector>])
                     (: :l1 [:n :t <vector>])]
                    [:m :n add :t <vector>])
    (case :l1
      null :l0
      cons [:l0 :l1.cdr (recur) :l1.car cons]))

  (+jojo map (-> [(: :l [:n :t1 <vector>])
                  (: :f (-> :t1 :t2))]
                 [:n :t2 <vector>])
    (case :l
      null null
      cons [:l.cdr :f (recur) :l.car @:f cons]))


  (+ null zero cons)

  (+ drop)

  (+ null
     zero cons
     null
     zero cons
     append)

  (+ drop)

  (+ null
     zero cons
     zero cons
     null
     zero cons
     zero cons
     append
     length)

  (+ drop)

  (+ null
     zero cons
     zero cons
     (jojo (-> <nat> <nat>) succ)
     map)

  (+ drop)

  (+ null
     zero cons
     zero cons
     zero cons
     null
     zero cons
     zero cons
     zero cons
     append
     (jojo (-> <nat> <nat>) succ)
     map)

  (+ drop)
  #+end_src

* <list>

  #+begin_src jojo
  ;; use forgetful functor to reuse function body defined for <vector>
  (+type <list> (forgetful <vector> (-> [(forget <nat>) <type>] <type>)))
  #+end_src

* <has-length>

  #+begin_src jojo
  (+type <has-length> (-> [:t <list> <nat>] <type>)
    null (-> [] [null zero <has-length>])
    cons (-> (: .cdr [:l :n <has-length>])
             [:l :a cons :n succ <has-length>]))

  (+jojo map/has-length (-> [(: :proof [:l :n <has-length>])]
                            [:l :f map :n <has-length>])
    (case :proof
      null null
      cons [:proof.cdr map/has-length cons]))
  #+end_src

* >< <int>

  - how to implement <int> by <nat>

* >< <fraction>

  - how to implement <fraction> by <int>

  #+begin_src jojo
  (+class <fraction> [<object>]
    (: .above <int>)
    (: .under <int>))
  #+end_src
