(+data <null>)
(+data <cons> .cdr .car)

(+jojo list-print :f! :l!
  (case :l
    <null> ["null" string-write space]
    <cons> [:l .cdr :f (recur)
            :l .car :f apply space
            "cons" string-write space]))

(note

  (+var a-list
    null
    1 cons
    2 cons)

  (run a-list (# int-write) list-print))

(note
  (+jojo t0 1 :a0! 2 :b0! (# :a0 :b0 add))
  (run t0 dup
    apply int-write space
    apply int-write space
    newline)

  (+jojo t1 1 :a! 2 :b! (# :a (# :b t0 apply add)))
  (run t1 apply apply add)


  (+jojo t0 1 :a! (# :a))
  (+jojo t1 2 :a! (# (# t0 apply)))
  (run t1 apply apply)


  (+jojo t0 1 :a! (# :a))
  (+jojo t1 2 :a! (# (# t0)))
  (run t1 apply apply apply)


  (+jojo t0 1 :a! (# :a))
  (+jojo t1 (# (# t0 apply)))
  (run t1 apply apply)

  (run t1 apply))

(+var server "8888" 5 tcp-socket-listen)
(+jojo run-server
  server socket-accept :addr! :client!
  "got a connection from " string-write :addr string-write newline
  :client "thank you for connecting" socket-send
  :client close (loop))
(note (run run-server))

(+var clinet "cicada" "8888" tcp-socket-connect)
(+jojo run-clinet
  clinet socket-recv string-write newline)
(note (run run-clinet))

(+data <nothing>)
(+data <just> .v)

(+data <leaf> .v)
(+data <node> .l .r)

(+jojo tree-write :f! :t!
  (note [tree fun] -> [])
  (case :t
    <leaf> [:t .v :f apply "leaf" string-write space]
    <node> [:t .l :f (recur)
            :t .r :f (recur) "node" string-write space]))

(+jojo tree-map :f! :t!
  (note [tree fun] -> [tree])
  (case :t
    <leaf> [:t .v :f apply leaf]
    <node> [:t .l :f (recur)
            :t .r :f (recur) node]))

(+var a-tree
  1 leaf 2 leaf node
  3 leaf 4 leaf node
  5 leaf node
  node)

(run a-tree
  (# 100 add) tree-map
  (# int-write space) tree-write)

(note
  (+jojo zip-tree :t1! :t2!
    (note [tree tree] -> [tree])
    (cond [:t1 leaf? :t2 leaf? and] [:t1 .v :t2 .v cons leaf]
          [:t1 node? :t2 node? and] [:t1 .l :t2 .l (recur)
                                     :t1 .r :t2 .r (recur) node]))
  (run a-tree dup (# 100 add) tree-map zip-tree
    (# dup .cdr int-write space
           .car int-write space
           "cons" string-write space)
    tree-write))

(note
  (+jojo zip-tree :t1! :t2!
    (note [tree tree] -> [maybe-tree])
    (cond [:t1 leaf? :t2 leaf? and]
          [:t1 .v :t2 .v cons leaf just]
          [:t1 node? :t2 node? and]
          (case [:t1 .l :t2 .l (recur) dup :lm!]
            <nothing> nothing
            <just> (case [:t1 .r :t2 .r (recur) dup :rm!]
                     <nothing> nothing
                     <just> [:lm .v :rm .v node just]))
          else nothing))

  (+jojo maybe-write :f! :m!
    (case :m
      <nothing> ["nothing" string-write space]
      <just> [:m .v :f apply "just" string-write space]))

  (run a-tree 1 leaf zip-tree
    (# (# dup .cdr int-write space
         .car int-write space
         "cons" string-write space)
      tree-write)
    maybe-write)

  (run a-tree dup zip-tree
    (# (# dup .cdr int-write space
         .car int-write space
         "cons" string-write space)
      tree-write)
    maybe-write))

(+jojo return-maybe just)

(+jojo bind-maybe :f! :m!
  (case :m
    <nothing> nothing
    <just> [:m .v :f apply]))

(+jojo zip-tree :t1! :t2!
  (note [tree tree] -> [maybe-tree])
  (cond [:t1 leaf? :t2 leaf? and]
        [:t1 .v :t2 .v cons leaf return-maybe]
        [:t1 node? :t2 node? and]
        [:t1 .l :t2 .l zip-tree
         (# :l! :t1 .r :t2 .r zip-tree
           (# :r! :l :r node return-maybe)
           bind-maybe)
         bind-maybe]
        else nothing))

(+jojo maybe-write :f! :m!
  (case :m
    <nothing> ["nothing" string-write space]
    <just> [:m .v :f apply "just" string-write space]))

(run a-tree 1 leaf zip-tree
  (# (# dup .cdr int-write space
            .car int-write space
            "cons" string-write space)
     tree-write)
  maybe-write)

(run a-tree dup zip-tree
  (# (# dup .cdr int-write space
            .car int-write space
            "cons" string-write space)
     tree-write)
  maybe-write)

(note
  (+jojo zip-tree :t1! :t2!
    (note [tree tree] -> [maybe-tree])
    (cond [:t1 leaf? :t2 leaf? and]
          [:t1 .v :t2 .v cons leaf return-maybe]
          [:t1 node? :t2 node? and]
          (let-bind bind-maybe
            :l [:t1 .l :t2 .l zip-tree]
            :r [:t1 .r :t2 .r zip-tree]
            [:l :r node return-maybe])
          else nothing))

  (+keyword let-bind
    (let-bind bind-maybe
      :l [:t1 .l :t2 .l zip-tree]
      :r [:t1 .r :t2 .r zip-tree]
      [:l :r node return-maybe])
    [:t1 .l :t2 .l zip-tree
     (# :l!
       :t1 .r :t2 .r zip-tree
       (# :r!
         :l :r node return-maybe)
       bind-maybe)
     bind-maybe]))


(note
  (let-bind bind-maybe
    :l [:t1 .l :t2 .l zip-tree]
    :r [:t1 .r :t2 .r zip-tree]
    [:l :r node return-maybe])
  =>
  [:t1 .l :t2 .l zip-tree
   (# :l!
     :t1 .r :t2 .r zip-tree
     (# :r!
       :l :r node return-maybe)
     bind-maybe)
   bind-maybe])


(note

  (: bind (-> (M a)
              (-> a -- (M b))
           -- (M b)))

  [(# :t1 .l :t2 .l zip-tree) :l!
   (# :t1 .r :t2 .r zip-tree) :r!
   (# @:l @:r node return-maybe)
   bind-maybe
   bind-maybe])

(+jojo tick
  (note (-> <int> -- <int> <int>))
  :x! :x inc :x)

(+jojo number-tree
  (note (-> :<t> <tree> -- (-> <int> -- <int> <tree>)))
  :t!
  (case :t
    <leaf> (# :x! :x inc :x leaf)
    <node> (# :t .l number-tree apply :l!
              :t .r number-tree apply :r!
              :l :r node)))

(+var tree-2
  "1" leaf "2" leaf node
  "3" leaf "4" leaf node
  "5" leaf node
  node)

(run
  tree-2 number-tree
  0 swap apply
  swap drop
  (# int-write space) tree-write newline)

(note
  (+jojo return-state
   (note (-- <v> -> (-- <s> -> <s> <v>)))
   :v!
    (# :v))

  (+jojo bind-state
    (note (-> (-> <s> -- <s> <v1>)
              (-> <v1> -- (-> <s> -- <s> <v2>))
              -- (-> <s> -- <s> <v2>)))
    :f! :m!
    (# :m apply :f apply apply))

  (+jojo tick
    (note (-> <int> -- <int> <int>))
    dup inc swap)

  (+jojo number-tree
    (note (-> :<t> <tree>
              -- (-> <int> -- <int> <tree>)))
    :t!
    (case :t
      <leaf> [(# tick)
              (# :s! :s leaf return-state)
              bind-state]
      <node> [:t .l number-tree
              (# :l! :t .r number-tree
                     (# :r! :l :r node return-state)
                     bind-state)
              bind-state]))

  (+var tree-0
    "1" leaf)

  (run
    tree-0 (# string-write space) tree-write newline)

  (run
    tree-0 number-tree
    0 swap apply
    swap drop
    (# int-write space) tree-write newline)

  (+var tree-1
    "1" leaf "2" leaf node)

  (run (note ><><>< error here)
    tree-1 number-tree
    0 swap apply
    swap drop
    (# int-write space) tree-write newline)

  (+var tree-2
    "1" leaf "2" leaf node
    "3" leaf "4" leaf node
    "5" leaf node
    node))
