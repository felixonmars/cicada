#+include: use-org-page.org
#+property: tangle LET.jo
#+title: LET

* intro

  - We begin by specifying a very simple language,
    which we call LET, after its most interesting feature.

* specifying the syntax

  - In this language,
    a program is just an expression.
    An expression is either

    1. an integer constant,
    2. a difference expression,
    3. a zero-test expression,
    4. a conditional expression,
    5. a variable, or a let expression.

  - example expression :
    (diff 55 (diff x 11))

*** formally

    #+begin_src jojo
    (note program = exp)
    (note exp
      = <const-exp>
      | <zero?-exp>
      | <if-exp>
      | <diff-exp>
      | <var-exp>
      | <let-exp>)
    #+end_src

* specification of values

  - An important part of the specification
    of any programming language
    is the set of values that the language manipulates.

  - Each language has at least two such sets :
    1. the expressed values
       which are the possible values of expressions,
    2. the denoted values
       which are the values bound to variables.

*** formally

    #+begin_src jojo
    (note val = <int> | <bool>)
    (note env = <null-env> | <cons-env>)
    #+end_src

* env

  #+begin_src jojo
  (+data <null-env>)
  (+data <cons-env> .rest .var .val)

  (+jojo env-apply (-> :var :env -- val)
    (case :env
      <null-env> ["- env-apply fail" w nl
                  "  can not find var : " w :var w nl
                  debug]
      <cons-env> (if :env .var :var equal?
                     then :env .val
                     else :var :env .rest recur)))

  (+jojo init-env
    null-env
    ':x 10 cons-env
    ':v 5  cons-env
    ':i 1  cons-env)
  #+end_src

* exp

  #+begin_src jojo
  (+data <const-exp> .num)
  (+data <zero?-exp> .exp1)
  (+data <if-exp>    .exp1 .exp2 .exp3)
  (+data <diff-exp>  .exp1 .exp2)
  (+data <var-exp>   .var)
  (+data <let-exp>   .var .exp1 .body)

  (+jojo program-eval (-> :program -- val)
    :program init-env eval)

  (+jojo eval (-> :exp :env -- val)
    (case :exp
      <const-exp> [:exp .num]
      <zero?-exp> [:exp .exp1 :env recur 0 equal?]
      <if-exp>    (if :exp .exp1 :env recur
                      then :exp .exp2 :env recur
                      else :exp .exp3 :env recur)
      <diff-exp>  [:exp .exp1 :env recur
                   :exp .exp2 :env recur sub]
      <var-exp>   [:exp .var :env env-apply]
      <let-exp>   [:env
                   :exp .var
                   :exp .exp1 :env recur
                   cons-env :new-env!
                   :exp .body :new-env recur]))
  #+end_src

* parse

  #+begin_src jojo
  (note
    123 -- <const-exp>
    (diff ... ...) -- <diff-exp>
    (if ... ... ...) -- <if-exp>
    (zero? ...) -- <zero?-exp>
    :var -- <var-exp>
    (let :var ... ...) -- <let-exp>)

  (+jojo parse (-> :sexp -- exp)
    (cond
      [:sexp int-jo?]   [:sexp jo->int const-exp]
      [:sexp local-jo?] [:sexp var-exp]
      [:sexp cons? not] ["- parse fail" w nl
                         "  can not parse sexp : " w
                         :sexp sexp-write nl
                         debug]
      else [:sexp parse/cons]))

  (+jojo parse/cons (-> :sexp -- exp)
    :sexp .car :key!
    :sexp .cdr :body!
    (cond [:key 'zero? eq?] [:body parse/spread zero?-exp]
          [:key 'if eq?]    [:body parse/spread if-exp]
          [:key 'diff eq?]  [:body parse/spread diff-exp]
          [:key 'let eq?]   [:body .car :body
                             .cdr parse/spread let-exp]))

  (+jojo parse/spread {parse} list-map list-spread)
  #+end_src

* LET

  #+begin_src jojo
  (+jojo LET (-> :body --)
    :body {parse program-eval} list-map)
  #+end_src
