* optimization

  - (+type) defines abstract datatype

    abstract-syntax is a special representation of data

    once defined, we have constructors and extractors
    we must be able to replace them with more efficient functions.
    [to optimize representation independent functions]

    - take <nat> as an example
      when representing number as list of numbers with a large base
      we must optimize 'add'
      to make use of the the representation of the data.

    - <env> is another example

    we must design a API for this feature

* encoding of subtype relation

  - function which can apply to supertype can also apply to subtype

  - subtype
    1. (subtype disjoint-subtype ...)
    2. forgetful functor
    3. inheritance

  - constructor and observer

    - constructor
      return that type of data
      thus including processing functions of type (-> [... t] [t])

    - observer
      no return that type of data
      predicate and extractor

      - but extractor might return that type of data
        how to define constructor and observer then ?

* implementation

*** unification

    - equivalence between functions
      or partially applied functions [trunks]
      or functions applied to non-determinate arguments
      例如
      1. [:m :n add :n :m add <eq>]
      2. [[add] [swap add] <eq>]
      對 2 的證明應該劃歸爲對 1 的證明
      因爲前者有更多的細節

    - 之所以覺得處理不好 unification
      是因爲我的編程能力還太弱了
      在不明白 type-class 與 monad 的情況下
      我對函數式編程的理解也不夠

*** unification need uni-id

    - solutions :
      1. uni-copy
      2. compile to peek and put [of stack]

*** laws

    1. information non-decreasing

    2. proof semantic precedes functional semantic
       for example, type is not predicate

    3. generic dispatch

* about algebraic data type

  - 沒有構造子的
    type-alias of sumtype
    type-alias of function type
    可以使得函數總是能作用與它可以所用於的類型
    但是這可能並不是想要的性狀
    因爲 即便是可以作用 也不想作用 而是要做更細緻的限制

  - 也許對於動態語言來說
    簡化的用法是合理的
