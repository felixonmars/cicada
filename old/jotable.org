*** type

    #+begin_src c
    typedef struct jo_t_entry {
      cell index;
      char *key;
      struct jo_t_entry *tag;
      cell value;
      cell orbit_length;
      cell orbiton;
    } jotable_entry;

    typedef jotable_entry *jo;

    // prime table size
    //   1000003   about 976 k
    //   1000033
    //   1000333
    //   100003    about 97 k
    //   100333
    //   997
    #define jotable_size 100003
    jotable_entry jotable[jotable_size];
    cell jotable_counter = 0;

    // thus (jotable + index) is jo
    #+end_src

*** jotable_entry_[occured|entry_used|no_collision]

    #+begin_src c
    jo JO_NOT_USED;

    bool jotable_entry_occured(jo jo) {
      return jo->key != 0;
    }

    bool jotable_entry_used(jo jo) {
      return jo->tag != JO_NOT_USED;
    }

    bool jotable_entry_no_collision(jo jo) {
      return jo->index == jo->orbiton;
    }
    #+end_src

*** string_to_sum

    #+begin_src c
    cell string_to_sum(char* str) {
      cell sum = 0;
      cell max_step = 10;
      cell i = 0;
      while (i < strlen(str)) {
        sum = sum + ((byte) str[i]) * (2 << min(i, max_step));
        i++;
      }
      return sum;
    }
    #+end_src

*** jotable_keyeq

    #+begin_src c
    bool jotable_keyeq(char* k1, char* k2) {
      return string_equal(k1, k2);
    }
    #+end_src

*** jotable_hash

    #+begin_src c
    // get hash value is index into jotable
    cell jotable_hash(char* key, cell counter) {
      return (counter + string_to_sum(key)) % jotable_size;
    }
    #+end_src

*** jotable_insert

    #+begin_src c
    p_debug();
    jo jotable_insert(char* key) {
      // in C : [string] -> [jo]
      cell orbit_index = jotable_hash(key, 0);
      cell counter = 0;
      while (true) {
        cell index = jotable_hash(key, counter);
        if (!jotable_entry_occured(jotable + index)) {
          key = copy_to_string_area(key);
          (jotable + index)->key = key;
          (jotable + index)->orbiton = orbit_index;
          (jotable + orbit_index)->orbit_length = 1 + counter;
          jotable_counter = 1 + jotable_counter;
          return (jotable + index);
        }
        else if (jotable_keyeq(key, (jotable + index)->key)) {
          return (jotable + index);
        }
        else if (counter == jotable_size) {
          printf("- jotable_insert fail\n");
          printf("  the hash_table is filled\n");
          p_debug();
          return NULL;
        }
        else {
          counter++;
        }
      }
    }
    #+end_src

*** jotable_search

    #+begin_src c
    jo jotable_search(char* key) {
      // in C : [string] -> [jo] or [NULL]
      // NULL denotes key not occured
      cell counter = 0;
      while (true) {
        cell index = jotable_hash(key, counter);
        if (!jotable_entry_occured(jotable + index)) {
          return NULL;
        }
        else if (jotable_keyeq(key, jotable[index].key)) {
          return (jotable + index);
        }
        else if (counter == jotable_size) {
          return NULL;
        }
        else {
          counter++;
        }
      }
    }
    #+end_src

*** jotable_entry_print

    #+begin_src c
    jotable_entry_print(jotable_entry entry) {
      printf("%s : ", jo2str(entry.tag));
      printf("%ld", entry.value);
    }
    #+end_src

*** jotable_report_orbit

    #+begin_src c
    jotable_report_orbit(cell index, cell counter) {
      while (counter < jotable[index].orbit_length) {
        char* key = jotable[index].key;
        cell next_index = jotable_hash(key, counter);
        if (index == jotable[next_index].orbiton) {
          printf("  | %ld %s\n", next_index, jotable[next_index].key);
        }
        if (jotable_entry_used(jotable + next_index)) {
          printf("    = ");
          jotable_entry_print(jotable[next_index]);
          printf("\n");
        }
        counter = 1 + counter;
      }
    }
    #+end_src

*** jotable_report

    #+begin_src c
    jotable_report() {
      printf("\n");
      printf("- jotable_report\n");
      printf("  : <index> <key> // <orbit-length>\n");
      cell index = 0;
      while (index < jotable_size) {
        if (jotable_entry_occured(jotable + index) &&
            jotable_entry_no_collision(jotable + index)) {
          printf("  - %ld %s // %ld\n",
                 index, jotable[index].key, jotable[index].orbit_length);
          if (jotable_entry_used(jotable + index)) {
            printf("    = ");
            jotable_entry_print(jotable[index]);
            printf("\n");
          }
          jotable_report_orbit(index, 1);
        }
        index = 1 + index;
      }
      printf("  : <index> <key> // <orbit-length>\n");
      printf("\n");
      printf("- used : %ld\n", jotable_counter);
      printf("- free : %ld\n", jotable_size - jotable_counter);
    }
    #+end_src

*** jotable_print

    #+begin_src c
    jotable_print() {
      printf("\n");
      printf("- jotable_print\n");
      cell index = 0;
      while (index < jotable_size) {
        printf("  - %ld %s %ld // %ld\n",
               index,
               jotable[index].key,
               jotable[index].value,
               jotable[index].orbit_length);
        index = 1 + index;
      }
      printf("\n");
      printf("- used : %ld\n", jotable_counter);
      printf("- free : %ld\n", jotable_size - jotable_counter);
    }
    #+end_src
