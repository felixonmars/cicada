* p_open_for_reading

  #+begin_src c
  void p_open_for_reading() {
    string pathname = as_pop();
    FILE* fd = open(pathname, O_RDONLY);
    if (fd == -1) {
      perror("- p_open_for_reading fail\n");
    }
    as_push(fd);
  }
  #+end_src

* path_file_size

  - abstract "struct stat" out

  #+begin_src c
  cell path_file_size(string file_name) {
    struct stat st;
    stat(file_name, &st);
    return st.st_size;
  }
  #+end_src

* p_path_file_size

  #+begin_src c
  void p_path_file_size() {
    as_push(path_file_size(as_pop()));
  }
  #+end_src

* dir_ok_p

  #+begin_src c
  bool dir_ok_p(string path) {
    DIR* dir = opendir(path);
    if (!dir) {
      return false;
    }
    else {
      closedir(dir);
      return true;
    }
  }
  #+end_src

* p_dir_ok_p

  #+begin_src c
  void p_dir_ok_p() {
    // (dir -> bool)
    as_push(dir_ok_p(as_pop()));
  }
  #+end_src

* p_file_copy_to_buffer

  #+begin_src c
  void p_file_copy_to_buffer() {
    // (file-name addr -> number)
    cell buffer = as_pop();
    cell path = as_pop();
    cell limit = path_file_size(path);
    FILE* fp = fopen(path, "r");
    if(!fp) {
      printf("- p_file_copy_to_buffer file to open file : %s\n", path);
      perror("  ");
      as_push(0);
      return;
    }
    cell read_counter = fread(buffer, 1, limit, fp);
    fclose(fp);
    as_push(read_counter);
  }
  #+end_src
