#+property: tangle core.jo
#+title: core

* todo

  - better syntax for 'here'

  - primitive objects

  - cat for error message

  - c is only used to implement primitive object ?
    and to do optimization ?

  - [emacs] bright and dark color theme

  - [module system]
    - 以 module 爲單位加載別人寫的函數所在的文件
      用 module_record 來記錄已經加載過的 module
      加載過的就不重複加載
    - 命名
      - 需要避免命名衝突
      - 每個函數有實際的唯一的名字
        module/name
      - 在每個 module 加載過程中
        ><
    - 版本
      - 需要控制版本
        module/name
    - re-export
      - module 正是用 interface function name 來編碼的
        所以可以設計類似 subtype 的機制
        [考慮 ocaml]

* flag

  #+begin_src jojo
  (run testing-flag/on)
  (test top-repl/printing-flag/on)
  #+end_src

* list

*** cons

    #+begin_src jojo
    (def cons-size      (bare-data (int 3) cell-size mul))
    (def cons-area-size (bare-data (int 1024 1024) mul cons-size mul))
    (def cons-area      (bare-data cons-area-size allocate))
    (def cons-area-top  (bare-data cons-area cons-area-size add))
    (def cons-pointer   (bare-data cons-area))
    (def current-mark   (bare-data (int 1)))
    (def max-mark       (bare-data (int 1024 1024) mul))

    (def cons-pointer/next
      (jojo (note -> [cons-pointer])
        cons-size cons-pointer add
        (& cons-pointer) set))

    (def cons-pointer/init
      (jojo (note -> [cons-pointer])
        cons-area
        (& cons-pointer) set))

    (def cons-pointer/next-free
      (jojo (note -> [cons-pointer])
        (if cons-pointer cons-area-top eq? then end)
        (if cons-pointer get current-mark eq? not then end)
        cons-pointer/next
        (loop)))

    (def cons?
      (jojo (note cell -> bool)
        (if dup cons-area lt? then drop false end)
        (if dup cons-area-top gteq? then drop false end)
        cons-area sub cons-size mod (int 0) eq?))



    (declare
     (car (note cons -> cell))
     (cdr (note cons -> cell)))

    (def cons-area/report/loop
      (jojo (note cons -> [io])
        (if dup cons-area-top eq? then drop end)
        (string "#:") string/print
        dup dot
        (string "mark: ") string/print
        dup get dot
        (string "car: ") string/print
        dup car dot
        (string "cdr: ") string/print
        dup cdr dot
        newline
        cons-size add
        (loop)))

    (def cons-area/report
      (jojo (note -> [io])
        cons-area cons-area/report/loop))



    (def sweep-cons-area/loop
      (jojo (note cons -> [io])
        (if dup cons-area-top eq? then drop end)
        dup (int 0)  swap set
        cons-size add
        (loop)))

    (def sweep-cons-area
      (jojo (note -> [cons-area])
        cons-area sweep-cons-area/loop))



    (note root from :
          stack
          defbare-data)

    (def mark-cons
      (jojo (note cons -> [cons-area])
        (if dup cons? not then drop end)
        dup current-mark swap set
        dup car mark-cons
        cdr (loop)))

    (def mark-cons-area/def-record
      (jojo (note def-record -> [cons-area])
        (if dup get (int 0) eq? then drop end)
        dup get mark-cons
        cell-size add
        (loop)))

    (def mark-cons-area/argument-stack
      (jojo (note stack -> [cons-area])
        (if dup stack-base eq? then drop end)
        cell-size sub
        dup get mark-cons
        (loop)))

    (def mark-cons-area
      (jojo (note -> [cons-area])
        (if current-mark max-mark eq? then
            sweep-cons-area
            (int 0) (& current-mark) set)
        current-mark (int 1) add (& current-mark) set
        def-record mark-cons-area/def-record
        stack-pointer
        mark-cons-area/argument-stack))



    (note cons :
          mark
          car
          cdr)

    (def new/cons
      (jojo (note -> cons)
        (if cons-pointer cons-area-top eq? then
            mark-cons-area
            cons-pointer/init
            cons-pointer/next-free
            (if cons-pointer cons-area-top eq? then
                (string "fatal error : cons-area is full") string/print
                newline bye)
            (loop))
        (if cons-pointer get current-mark eq? then
            cons-pointer/next (loop))
        cons-pointer
        cons-pointer/next end))

    (def set-car
      (jojo (note cell cons ->)
        cell-size add
        set))

    (def set-cdr
      (jojo (note cell cons ->)
        cell-size add
        cell-size add
        set))

    (def car
      (jojo (note cons -> cell)
        cell-size add
        get))

    (def cdr
      (jojo (note cons -> cell)
        cell-size add
        cell-size add
        get))

    (def cons
      (jojo (note cdr-cell car-cell -> cons)
        new/cons
        tuck set-car
        tuck set-cdr))


    (note the following tests are for small cons-area)

    (note (test (int 0)
                (int 1) cons
                (int 2) cons
                dup car dot
                dup cdr car dot
                dup cdr cdr dot

                dup cons? dot
                dup cdr cons? dot
                dup car cons? dot
                dup cdr car cons? dot
                dup cdr cdr cons? dot
                dot

                current-mark
                dot))

    (note (test newline
                new/cons dot
                new/cons dot
                new/cons dot
                new/cons dot
                new/cons dot
                current-mark dot
                newline
                cons-area/report
                newline))
    #+end_src

*** assoc-list

    #+begin_src jojo
    (def assq
      (jojo
        (note assoc-list value -> pair or null)
        (if over null eq? then drop drop null end)
        (if over car cdr over eq? then drop car end)
        swap cdr swap (loop)))

    (def assoc/find
      (jojo
        (note assoc-list value -> [pair true] or [false])
        (if over null eq? then drop drop false end)
        (if over car cdr over eq? then drop car true end)
        swap cdr swap (loop)))
    #+end_src

*** list/print

    #+begin_src jojo
    (def list/print
      (jojo
        (note list -> [output])
        (if dup null eq? then drop (jo null) jo/print (string " ") string/print end)
        (if dup cons? not then dot end)
        dup cdr (recur)
        car (recur) (jo cons) jo/print (string " ") string/print))
    #+end_src

*** list/copy

    #+begin_src jojo
    (def list/copy
      (jojo
        (note list -> list)
        (note circles are not handled)
        (if dup cons? then end)
        dup cdr (recur)
        car (recur)
        swap
        cons))

    (note
      (run (int 1) (int 2) cons
           (int 3) null cons
           cons
           dup
           cons
           dup list/print newline
           dup list/copy list/print newline
           dup list/copy list/print newline
           drop))
    #+end_src

* object

*** note

    - class
      - one superclass
        thus single inheritance
      - meta-variable
      - meta-method
        two ways to implement object creation :
        [1] to use meta class -- class is an object
        [2] to use meta method -- class is not an object
        i will use [2]
      - instance-variable
        i.e. parts of the object
      - method-list
        where super can be used to use an method of superclass
        to implement a new method to override it

    - interface-generator
      when defining a class
      different interface-generator can be used to generate method list
      for example
      - low level array like data with free
      - high level list list data using gc

*** help

    #+begin_src jojo
    (def class/get-class-name          (jojo (jo class-name) assq car))

    (def class/has-superclass?         (jojo (jo inherit) assq null eq? not))
    (def class/get-superclass-name     (jojo (jo inherit) assq car))

    (def class/has-meta-variable-list? (jojo (jo meta-variable) assq null eq? not))
    (def class/get-meta-variable-list  (jojo (jo meta-variable) assq car))

    (def class/has-meta-method-list?   (jojo (jo meta-method) assq null eq? not))
    (def class/get-meta-method-list    (jojo (jo meta-method) assq car))

    (def class/has-variable-list?      (jojo (jo variable) assq null eq? not))
    (def class/get-variable-list       (jojo (jo variable) assq car))

    (def class/has-method-list?        (jojo (jo method) assq null eq? not))
    (def class/get-method-list         (jojo (jo method) assq car))
    #+end_src

*** [keyword] define-class

    #+begin_src jojo
    (def define-class/keyword/one-variable
      (keyword
        (jo instruction/lit) here read/jo here
        compile-jojo
        (jo cons) here
        (jo cons) here
        (jo cons) here))

    (def jo-ending-with-colon?
      (jojo
        (note jo -> bool)
        jo->string string/last-char
        (string ":") string/last-char eq?))

    (def define-class/keyword/one-method/complex-message
      (keyword
        (note sum-jo -> sum-jo)
        read/jo
        (if dup round-ket eq? then drop end)
        (if dup jo-ending-with-colon? then
            jo/append
            (loop))
        swap (recur) swap
        (jo instruction/lit) here
        here
        (jo local-two-in) here))

    (def define-class/keyword/one-method/message
      (keyword
        (note -> jo)
        read/jo
        (if dup round-bar eq? not then end)
        drop read/jo drop
        empty-jo define-class/keyword/one-method/complex-message))

    (def define-class/keyword/one-method
      (keyword
        (jo instruction/jump) here
        compiling-stack/tos (> offset-place)
        compiling-stack/inc
        compiling-stack/tos (> bare-jojo-place)
        define-class/keyword/one-method/message (> message)
        compile-jojo
        (jo end) here
        compiling-stack/tos (< offset-place) set
        (jo instruction/lit) here
        (< bare-jojo-place) here
        (jo instruction/lit) here
        (< message) here
        (jo swap) here
        (jo cons) here
        (jo cons) here))

    (def define-class/keyword/inherit
      (keyword
        (jo instruction/lit) here (jo inherit) here
        (jo instruction/lit) here read/jo here
        ignore
        (jo cons) here
        (jo cons) here))

    (def define-class/keyword/meta-variable-list
      (keyword
        (jo *) (jo define-class/keyword/one-variable) alias-push

        (jo instruction/lit) here (jo meta-variable) here
        (jo null) here
        compile-jojo
        (jo cons) here
        (jo cons) here))

    (def define-class/keyword/meta-method-list
      (keyword
        (jo *) (jo define-class/keyword/one-method) alias-push

        (jo instruction/lit) here (jo meta-method) here
        (jo null) here
        compile-jojo
        (jo cons) here
        (jo cons) here))

    (def define-class/keyword/variable-list
      (keyword
        (jo *) (jo define-class/keyword/one-variable) alias-push

        (jo instruction/lit) here (jo variable) here
        (jo null) here
        compile-jojo
        (jo cons) here
        (jo cons) here))

    (def define-class/keyword/method-list
      (keyword
        (jo *) (jo define-class/keyword/one-method) alias-push

        (jo instruction/lit) here (jo method) here
        (jo null) here
        compile-jojo
        (jo cons) here
        (jo cons) here))


    (def define-class/help
      (keyword
        read/jo (> class-name)
        (jo inherit) (jo define-class/keyword/inherit) alias-push
        (jo meta-method) (jo define-class/keyword/meta-method-list) alias-push
        (jo meta-variable) (jo define-class/keyword/meta-variable-list) alias-push
        (jo variable) (jo define-class/keyword/variable-list) alias-push
        (jo method) (jo define-class/keyword/method-list) alias-push

        (jo null) here

        (jo instruction/lit) here
        (jo class-name) here
        (jo instruction/lit) here
        (< class-name) here
        (jo cons) here
        (jo cons) here

        compile-jojo
        (jo instruction/lit) here
        (jo <class>) here

        (jo instruction/lit) here
        (< class-name) here))

    (def define-class
      (keyword
        compiling-stack/tos (> begin)
        define-class/help
        (jo end) here
        (< begin) apply
        bind-name))
    #+end_src

*** send-to-class

    #+begin_src jojo
    (def send-to-class/find-meta-method
      (jojo
        (note class message -> [value <*> true] or [false])
        (> message)
        (> class)
        (if (< class) class/has-meta-method-list? then
            (< class) class/get-meta-method-list
            (< message)
            assoc/find
            (if then
                car
                true
                end))
        (if (< class) class/has-superclass? then
            (< class) class/get-superclass-name jo/apply drop
            (< message)
            (loop))
        false))

    (def send-to-class
      (jojo
        (> message)
        (> class)
        (< class) (< message)
        send-to-class/find-meta-method
        (if then
            local-area-pointer swap
            (< class) (jo self-class) local-in
            apply-with-local-area-pointer
            end)
        (string "- send-to-class : can not find message : ") string/print
        (< message) jo/print newline))
    #+end_src

*** send-to-object

    #+begin_src jojo
    (def send-to-object/find-method
      (jojo
        (note class-name message -> [bare-jojo true] or [false])
        (> message)
        (> class-name)
        (< class-name) jo/apply drop (> class)
        (if (< class) class/has-method-list? then
            (< class) class/get-method-list
            (< message) assoc/find
            (if then
                car
                true
                end))
        (if (< class) class/has-superclass? then
            (< class) class/get-superclass-name
            (< message)
            (loop))
        false))

    (def send-to-object
      (jojo
        (> message)
        (> class-name)
        (> data)
        (< class-name) (< message)
        send-to-object/find-method
        (if then
            local-area-pointer swap
            (< data) (< class-name) (jo self) local-two-in
            apply-with-local-area-pointer
            end)
        (string "- send-to-object : can not find message : ") string/print
        (< message) jo/print newline
        (string "  object/class-name : ") string/print
        (< class-name) jo/print newline))
    #+end_src

*** send

    #+begin_src jojo
    (def send
      (jojo
        (if over (jo <class>) eq? then swap drop send-to-class end)
        send-to-object))
    #+end_src

*** [keyword] :

    #+begin_src jojo
    (def send/sugar/simple
      (keyword
        (note (: message ...)
              =>
              (> object) (bare-jojo ...) apply
              (< object) (jo message) send)

        (> message)
        (jo :) generate-jo (> object-jo)

        (jo instruction/lit) here
        (< object-jo) here
        (jo local-two-in) here

        bare-jojo
        (jo apply) here

        (jo instruction/lit) here
        (< object-jo) here
        (jo local-two-out) here

        (jo instruction/lit) here
        (< message) here
        (jo send) here))

    (def send/sugar/complex/loop
      (keyword
        (note sum-jo -> sum-jo)
        read/jo
        (if dup round-ket eq? then drop end)
        (if dup round-bar eq? then drop read/jo jo/apply (loop))
        (if dup jo-ending-with-colon? then jo/append (loop))
        here (loop)))

    (def send/sugar/complex
      (keyword
        (note sum-jo -> sum-jo)
        (jo instruction/jump) here
        compiling-stack/tos (> offset-place)
        compiling-stack/inc
        compiling-stack/tos (> bare-jojo-place)
        send/sugar/complex/loop
        (jo end) here
        compiling-stack/tos (< offset-place) set
        (jo instruction/lit) here
        (< bare-jojo-place) here))

    (def :
      (keyword
        read/jo
        (if dup jo-ending-with-colon? not then
            send/sugar/simple end)

        (jo :) generate-jo (> object-jo)

        (jo instruction/lit) here
        (< object-jo) here
        (jo local-two-in) here

        send/sugar/complex (> message)
        (jo apply) here

        (jo instruction/lit) here
        (< object-jo) here
        (jo local-two-out) here

        (jo instruction/lit) here
        (< message) here
        (jo send) here))
    #+end_src

*** [keyword] <= and =>

    - syntax for instance-variable
      simply set and get

    #+begin_src jojo
    (def get-instance-variable
      (jojo
        (note [object name] -> [data tag])
        (> name)
        (> class-name)
        (> instance-variable-list)

        (< instance-variable-list)
        (< name)
        assoc/find
        (if then car dup car swap cdr swap end)
        (string "- get-instance-variable fail") string/print newline))

    (def <=
      (keyword
        (jo instruction/lit) here
        read/jo here
        ignore
        (jo get-instance-variable) here))


    (def set-instance-variable
      (jojo
        (note [object data type name] -> [])
        (> name)
        (> class-name)
        (> instance-variable-list)
        (> type-name)
        (> data)

        (< instance-variable-list)
        (< name)
        assoc/find
        (if then (> instance-variable)
            (< data) (< type-name) cons
            (< instance-variable) set-car end)
        (string "- set-instance-variable fail") string/print newline))

    (def =>
      (keyword
        (jo instruction/lit) here
        read/jo here
        ignore
        (jo set-instance-variable) here))
    #+end_src

*** <object>

    - an <object> is two values on the stack [data class-name].
    - the data of an <object> is simply an assoc-list of name and value.

    #+begin_src jojo
    (define-class <object>
      (meta-method
        (* new
           (if (< self-class) class/has-variable-list? then
               (< self-class) class/get-variable-list list/copy
               (< self-class) class/get-class-name end)
           null
           (< self-class) class/get-class-name)))
    #+end_src

*** test

    #+begin_src jojo
    (define-class <person>
      (inherit <object>)
      (meta-variable
        (* language (jo chinese) (jo <jo>)))
      (variable
        (* age (int 13) (jo <int>)))
      (method
        (* grow
           (<< self) (=> age))
        (* (: m1: a1 m2: a2)
           (<< a1) jo/print newline jo/print newline
           (<< a2) jo/print newline jo/print newline)))

    (run <object> (: new) jo/print newline list/print newline)


    (run <person> (: new) jo/print newline list/print newline)

    (run <person> (: new) (<= age) jo/print newline dot newline)

    (run  <person> (: new) 2dup
          (int 14) (jo <int>) 2swap (=> age)
          (<= age) jo/print newline dot newline)

    (run  <person> (: new)
          (: m1:m2: (jo j1) (jo <j1>) (jo j2) (jo <j2>)))

    (run  <person> (: new)
          (: m1: (jo j1) (jo <j1>) m2: (jo j2) (jo <j2>)))
    #+end_src

*** ><><>< defmethod

    #+begin_src jojo
    (note
      (def new/method (jojo (note method/body method/name -> method) cons))

      (def defmethod
        (jojo (note (defmethod :class-name :method-name ...)
                    =>
                    (bare-jojo ...) (jo :method-name) new/method
                    :class-name swap cons
                    (& :class-name) set)

          read/jo (> class-name)
          read/jo (> method-name)

          address-of-here (> bare-jojo)
          compile-jojo
          (jo end) here

          (< class-name) jo-as-var get
          (< bare-jojo) (< method-name) new/method
          cons

          (< class-name) jo-as-var set)))
    #+end_src

* file

*** note

    #+begin_src jojo
    (note
      (def <file> (bare-data empty-class))

      (def new/file
        (jojo (note string -> <file>)
          (jo <file>)))

      (defmethod <file> readable?
        (<< self) file/readable?)

      (run
        (string "READM") new/file (:: readable?)))
    #+end_src

* module

*** note

    #+begin_src jojo
    (note
     (module <module-name> function ...)
     (dep <module-name>)
     (include <path>)
     (clib <path>))
    #+end_src

* test

  #+begin_src jojo
  (note  (bye))
  #+end_src
