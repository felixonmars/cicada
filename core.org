#+property: tangle core.jo
#+title: core

* [todo-stack]

*** re-define keywords

*** (case) to handle multi-value

*** (let)

*** (let-bind) -- moand interface

    - (let-bind) or (do) ?
      #+begin_src jojo
      (note
        (+jojo zip-tree :t1! :t2!
          (note [tree tree] -> [maybe-tree])
          (cond [:t1 leaf? :t2 leaf? and]
                [:t1 .v :t2 .v cons leaf return-maybe]
                [:t1 node? :t2 node? and]
                (let-bind bind-maybe
                  :l {:t1 .l :t2 .l zip-tree}
                  :r {:t1 .r :t2 .r zip-tree}
                  {:l :r node return-maybe})
                else nothing)))
      #+end_src

*** about monad

    - learn more about monad by
      1. inline monads
      2. uncurry functions

*** about closure

    - and test closure by more examples
      such as 'counter'

*** dynamic scope

    - 一個 dynamic scope 的 block
      其 dynamic free variable 可以被看成是 有名參數

*** to use dynamic scope

    - function with effect on tos of global stack
      can be replaced by dynamic scoped variable in function ?

*** about closure

    - to catch unnamed data into returned closure

*** about algebraic data type

    - 沒有構造子的
      type-alias of sumtype
      type-alias of function type
      可以使得函數總是能作用與它可以所用於的類型
      但是這可能並不是想要的性狀
      因爲 即便是可以作用 也不想作用 而是要做更細緻的限制

    - 也許對於動態語言來說
      簡化的用法是合理的

*** test

    - use EOPL to test the language

*** module system

    - only use "~/.jojo"
      to make the behaviour of module system simple
    - move socket to module
    - improve socket API

* [note] syntax

*** the reader

    - what macro get
      is equivalent to '(...)
      (keyword ...)
      ['(...) keyword]

    - keyword v.s. macro ?
      only keyword no macro ?
      thus, no macro expend

*** literal

    | "..." | <string> |
    | 123   | <int>    |
    | 'jo   | <jo>     |

*** bar-ket

    | () | syntax    | '() | <cons> |
    | [] | <vector>  | '[] | <vons> |
    | {} | <closure> | '{} | <fons> |

* flag

  #+begin_src jojo
  (run core-flag-on)
  #+end_src

* jexp

*** [note]

    - jexp
      #+begin_src jojo
      (note jexp
        = jexp <cons>
        | jexp <vons>
        | jexp <fons>
        | <string>
        | <jo>)
      #+end_src

    - bar-ket
      | () | syntax    | '() | <cons> |
      | [] | <vector>  | '[] | <vons> |
      | {} | <closure> | '{} | <fons> |

*** jexp

    #+begin_src jojo
    (+data <null>)
    (+data <cons> .car .cdr)
    (+data <vons> .var .vdr)
    (+data <fons> .far .fdr)
    #+end_src

*** read-jexp

    - atom of jexp can only be <string> and <jo>

    #+begin_src jojo
    (+jojo read-jexp (-> -- jexp)
      read-jo :jo!
      (cond [:jo round-bar eq?]  [read-jexp/cons]
            [:jo square-bar eq?] [read-jexp/vons]
            [:jo flower-bar eq?] [read-jexp/fons]
            [:jo double-quote eq?] [read-string]
            else [:jo]))

    (+jojo read-jexp/cons
      read-jo :jo!
      (if :jo round-ket eq?
          then null
          else :jo jo-unread read-jexp recur cons))

    (+jojo read-jexp/vons
      read-jo :jo!
      (if :jo round-ket eq?
          then null
          else :jo jo-unread read-jexp recur vons))

    (+jojo read-jexp/fons
      read-jo :jo!
      (if :jo round-ket eq?
          then null
          else :jo jo-unread read-jexp recur fons))
    #+end_src

*** jexp-write

    #+begin_src jojo
    (+jojo jexp-write (-> :jexp --)
      (case :jexp
        <cons> [round-bar  jo-write space :jexp jexp-write/cons]
        <vons> [square-bar jo-write space :jexp jexp-write/vons]
        <fons> [flower-bar jo-write space :jexp jexp-write/fons]
        <string> [double-quote jo-write
                  :jexp string-write
                  double-quote jo-write
                  space]
        <jo> [:jexp jo-write space]))

    (+jojo jexp-write/cons (-> :l --)
      (case :l
        <null> [round-ket jo-write space]
        <cons> [:l .car jexp-write
                :l .cdr recur]))

    (+jojo jexp-write/vons (-> :l --)
      (case :l
        <null> [square-bar jo-write space]
        <cons> [:l .car jexp-write
                :l .cdr recur]))

    (+jojo jexp-write/fons (-> :l --)
      (case :l
        <null> [flower-bar jo-write space]
        <cons> [:l .car jexp-write
                :l .cdr recur]))
    #+end_src

*** ><>< repl

    - before call a repl one has to push an input_stack to reading_stack

      after the input_stack is empty
      the repl returns

      one has to drop reading_stack
      and close input_stack

      thus, the input_stack shoud be an argument of the repl

    #+begin_src jojo
    (+jojo repl
      push-terminal-to-reading-stack
      (if has-jo? not then drop-reading-stack end)
      read-jo :jo!
      (if :jo round-bar eq? then
          read-jo
          round-bar jo-unread read-jexp
          swap jo-apply)
      recur)
    #+end_src

*** >< compile-jojo

    #+begin_src jojo
    (note
      (+jojo compile-jojo (-> :l jexp <cons> -- <jojo>)
        new-jojo-from-compiling-stack-tos
        swap compile-jojo/help)

      (+jojo compile-jojo/jo (-> :jo --)
        (cond
          [:jo number-jo?] [:jo jo->int emit-lit]
          [:jo get-local-jo?] [:jo jo-emit-get-local]
          [:jo set-local-jo?] [:jo jo-emit-set-local]
          [:jo get-field-jo?] [:jo jo-emit-get-field]
          [:jo set-field-jo?] [:jo jo-emit-set-field]
          else [:jo jo-emit-call]))

      (+jojo compile-jojo/help (-> :l jexp <cons> --)
        (if :l null? then
            'end jo-emit-call
            0 int-emit-data
            0 int-emit-data
            end)
        :l .car :jexp!
        (cond [:jexp cons?] [:jexp .cdr :jexp .car jo-apply]
              [:jexp vons?] []
              [:jexp fons?] []
              [:jexp string?] [:jexp emit-lit]
              [:jexp jo?] [:jexp compile-jojo/jo])
        :l .cdr recur))
    #+end_src

*** >< (+jojo)

    #+begin_src jojo
    (note
      (+jojo +jojo (-> :l --)
        :l .car
        :l .cdr compile-jojo
        bind-name))
    #+end_src

*** >< (run repl)

    #+begin_src jojo
    (note (run repl))
    #+end_src

*** >< (run)

    #+begin_src jojo
    (note (+jojo run
            ))
    #+end_src

*** >< the-story-begin

    #+begin_src jojo
    (note
      (+jojo square dup mul)
      (run ))
    #+end_src
