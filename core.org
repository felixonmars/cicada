#+HTML_HEAD: <link rel="stylesheet" href="http://xieyuheng.github.io/asset/css/page.css" type="text/css" media="screen" />
#+PROPERTY: tangle core.jo
#+title: example code of jojo

* define function

  #+begin_src jojo
  (defun square (: int int -> int)
    dup mul end)

  (run (int 11) square dot)
  #+end_src

* loop by explicit tail-call

  #+begin_src jojo
  (defun key-jo/apply (: jo -> *)
    (if dup jo/used? -> jo/apply end)
    (string "undefined keyword : ") string/print
    jo->string string/print end)

  (defun stack-repl (: [io] -> *)
    (if read/jo round-bar eq? -> read/jo key-jo/apply print-stack)
    (loop))

  (run stack-repl)
  #+end_src

* branching by if

  #+begin_src jojo
  (run (if true -> true dot end)
       (if false -> false dot end))
  #+end_src

* receive function

  #+begin_src jojo
  (defun factorial (: int -> int)
    (if dup (int 1) lteq? -> drop (int 1) end)
    dup (int 1) sub (recur) mul end)

  (run (int 0) factorial dot
       (int 1) factorial dot
       (int 2) factorial dot
       (int 3) factorial dot
       (int 4) factorial dot)
  #+end_src

* int

  #+begin_src jojo
  (run (int 18 5) mod dot)
  (run (int 0 3 2) (int 1 3 2) (int 3) n-eq? dot)
  (run (int 1 3 2) (int 1 3 2) (int 3) n-eq? dot)
  #+end_src

* string

  #+begin_src jojo
  (run (string "test1" "test2")
       string/print string/print)
  #+end_src

* byte

  #+begin_src jojo
  (run (string "test1" "test2")
       dup (int 66) swap set-byte string/print
       dup get-byte dot string/print)
  #+end_src

* file

  #+begin_src jojo
  (run (string "README")
       (int 1024) allocate tuck
       (int 1024) read-file dot
       string/print)
  #+end_src

* system

  #+begin_src jojo
  (run current-dir string/print newline)
  #+end_src

* var

  #+begin_src jojo
  (defvar var1 (int 666) (int 666) add)
  (run var1 dot)
  #+end_src

* jo

  #+begin_src jojo
  (run (jo null) jo->string string/print newline)
  #+end_src

* list

*** cons-area

    #+begin_src jojo
    (defvar cons-size (int 3) cell-size mul)
    (defvar cons-area-size
      (: (int 5) (: for testing))
      (int 1024 1024) mul
      cons-size mul)

    (defvar cons-area cons-area-size allocate)
    (defvar cons-area-top cons-area cons-area-size add)

    (defvar cons-pointer cons-area)

    (defvar current-mark (int 1))
    (defvar max-mark (: (int 3) (: for testing))
            (int 1024 1024) mul)

    (defun cons-pointer/next (: -> [cons-pointer])
      cons-size cons-pointer add
      (var cons-pointer) set)

    (defun cons-pointer/init (: -> [cons-pointer])
      cons-area
      (var cons-pointer) set)

    (defun cons-pointer/next-free (: -> [cons-pointer])
      (if cons-pointer cons-area-top eq? -> end)
      (if cons-pointer get current-mark eq? not -> end)
      cons-pointer/next
      (loop))

    (defun cons? (: cell -> bool)
      (if dup cons-area lt? -> drop false end)
      (if dup cons-area-top gteq? -> drop false end)
      cons-area sub cons-size mod (int 0) eq?)
    #+end_src

*** cons-area/report

    #+begin_src jojo
    (declare
      (car (: cons -> cell))
      (cdr (: cons -> cell)))

    (defun cons-area/report/loop (: cons -> [io])
      (if dup cons-area-top eq? -> drop end)
      (string "#:") string/print
      dup dot
      (string "mark: ") string/print
      dup get dot
      (string "car: ") string/print
      dup car dot
      (string "cdr: ") string/print
      dup cdr dot
      newline
      cons-size add
      (loop))

    (defun cons-area/report (: -> [io])
      cons-area cons-area/report/loop)
    #+end_src

*** sweep-cons-area

    #+begin_src jojo
    (defun sweep-cons-area/loop (: cons -> [io])
      (if dup cons-area-top eq? -> drop end)
      dup (int 0)  swap set
      cons-size add
      (loop))

    (defun sweep-cons-area (: -> [cons-area])
      cons-area sweep-cons-area/loop)
    #+end_src

*** mark-cons-area

    - root from
      - stack
      - defvar

    #+begin_src jojo
    (defun mark-cons (: cons -> [cons-area])
      (if dup cons? not -> drop end)
      dup current-mark swap set
      dup car mark-cons
      cdr (loop))

    (defun mark-cons-area/defvar-record (: defvar-record -> [cons-area])
      (if dup get (int 0) eq? -> drop end)
      dup get mark-cons
      cell-size add
      (loop))

    (defun mark-cons-area/argument-stack (: stack -> [cons-area])
      (if dup stack-base eq? -> drop end)
      cell-size sub
      dup get mark-cons
      (loop))

    (defun mark-cons-area (: -> [cons-area])
      (if current-mark max-mark eq? ->
          sweep-cons-area
          (int 0) (var current-mark) set)
      current-mark (int 1) add (var current-mark) set
      defvar-record mark-cons-area/defvar-record
      stack-pointer
      mark-cons-area/argument-stack)
    #+end_src

*** cons

    - cons
      | mark |
      | car  |
      | cdr  |

    #+begin_src jojo
    (defun new/cons (: -> cons)
      (if cons-pointer cons-area-top eq? ->
          mark-cons-area
          cons-pointer/init
          cons-pointer/next-free
          (if cons-pointer cons-area-top eq? ->
              (string "fatal error : cons-area is full") string/print
              newline bye)
          (loop))
      (if cons-pointer get current-mark eq? ->
          cons-pointer/next (loop))
      cons-pointer
      cons-pointer/next end)

    (defun set-car (: cell cons -> cons)
      tuck
      cell-size add
      set)

    (defun set-cdr (: cell cons -> cons)
      tuck
      cell-size add
      cell-size add
      set)

    (defun car (: cons -> cell)
      cell-size add
      get)

    (defun cdr (: cons -> cell)
      cell-size add
      cell-size add
      get)

    (defun cons (: cdr-cell car-cell -> cons)
      new/cons set-car set-cdr)
    #+end_src

*** test

    #+begin_src jojo
    (: (run (int 0)
            (int 1) cons
            (int 2) cons
            dup car dot
            dup cdr car dot
            dup cdr cdr dot

            dup cons? dot
            dup cdr cons? dot
            dup car cons? dot
            dup cdr car cons? dot
            dup cdr cdr cons? dot
            dot

            current-mark
            dot))

    (: (run newline
            new/cons dot
            new/cons dot
            new/cons dot
            new/cons dot
            new/cons dot
            current-mark dot
            newline
            cons-area/report
            newline))
    #+end_src

*** list

    #+begin_src jojo
    (: {a {b c} d}
       null
       a cons
         null
         b cons
         c cons
       cons
       d cons)

    (defun list/one (: [io] -> [compile])
      read/jo
      (if dup flower-bar eq? ->
          drop null here
          (recur) (jo cons) here
          (loop))
      (if dup flower-ket eq? ->
          drop end)
      (if dup round-bar eq? ->
          drop read/jo key-jo/apply
          (jo cons) here
          (loop))
      (else (jo instruction/lit) here
            here
            (jo cons) here
            (loop)))

    (defun list (: [io] -> [compile])
      read/jo
      (if dup round-ket eq? -> drop end)
      (if dup flower-bar eq? ->
          drop null here
          list/one (loop))
      (else drop (loop)))
    #+end_src

*** test

    #+begin_src jojo
    (run (list {a {b c} d})
         dup car jo->string string/print
         dup cdr car car jo->string string/print
         dup cdr car cdr car jo->string string/print
         dup cdr car cdr cdr jo->string string/print
         dup cdr cdr car jo->string string/print
         dup cdr cdr cdr jo->string string/print
         drop)

    (run (list {(int 1) {(int 2) (do (int 1 2) add)} (int 4)})
         dup car dot
         dup cdr car car dot
         dup cdr car cdr car dot
         dup cdr car cdr cdr dot
         dup cdr cdr car dot
         dup cdr cdr cdr dot
         drop)
    #+end_src

*** int-list/print

    #+begin_src jojo
    (declare (int-list/print (: cons -> [io])))

    (defun int-list/print/rest (: cons -> [io])
      (if dup null eq? -> drop end)
      dup cdr int-list/print/rest
      car
      (if dup cons? -> int-list/print end)
      (else dot end))

    (defun int-list/print (: cons -> [io])
      (string "{ ") string/print
      int-list/print/rest
      (string "} ") string/print)
    #+end_src

*** test

    #+begin_src jojo
    (run (list {(int 1) {(int 2) (do (int 1 2) add)} (int 4)})
         int-list/print)
    #+end_src

*** jo/map & jo/itr

    #+begin_src jojo
    (defun jo/map (: {... a} (a -> b) -> {... b})
      (if over null eq? -> drop end)
      over car over jo/apply
      (int 2 1) xy-swap
      swap cdr swap (recur)
      swap cons)

    (defun jo/itr (: {... a} (a ->) ->)
      (if over null eq? -> drop drop end)
      over car over jo/apply
      swap cdr swap (loop))
    #+end_src

*** test

    #+begin_src jojo
    (defun add1 (: int -> int)
      (int 1) add)

    (run (int 1)
         (jo add1) jo/apply
         dot)

    (run (int 1) (int 2) (int 3) (int 4)
         (int 2 1) xy-swap dot dot dot dot)

    (run (list {(int 1) (int 2) (int 3) (int 4)})
         (jo add1) jo/map
         int-list/print)

    (run (list {(int 1) (int 2) (int 3) (int 4)})
         (jo dot) jo/itr)
    #+end_src

*** map

    #+begin_src jojo
    (defun map (: {... a} (a -> b) -> {... b})
      (if over null eq? -> drop end)
      over car over apply
      (int 2 1) xy-swap
      swap cdr swap (recur)
      swap cons)

    (defun itr (: {... a} (a ->) ->)
      (if over null eq? -> drop drop end)
      over car over apply
      swap cdr swap (loop))
    #+end_src

*** test

    #+begin_src jojo
    (run (list {(int 1) (int 2) (int 3) (int 4)})
         (jojo (int 1) add) map
         (jojo (int 1) add) map
         (jojo (int 1) add) map
         (jojo (int 1) add) map
         (jojo (int 1) add) map
         int-list/print)

    (run (list {(int 1) (int 2) (int 3) (int 4)})
         (jojo dup dot dot) itr)
    #+end_src

*** list/ref

    #+begin_src jojo
    (defun list/ref (: {... a} int -> a)
      (if dup (int 0) lteq? -> drop car end)
      (else swap cdr swap (int 1) sub (loop)))
    #+end_src

*** test

    #+begin_src jojo
    (run (list {(int 1) (int 2) (int 3) (int 4)})
         (int 1) list/ref dot)
    #+end_src

*** jo-list/print

    #+begin_src jojo
    (declare (jo-list/print (: cons -> [io])))

    (defun jo/dot (: jo -> [io])
      jo->string string/print
      (string " ") string/print)

    (defun jo-list/print/rest (: cons -> [io])
      (if dup null eq? -> drop end)
      dup cdr jo-list/print/rest
      car
      (if dup cons? -> jo-list/print end)
      (else jo/dot end))

    (defun jo-list/print (: cons -> [io])
      (string "{ ") string/print
      jo-list/print/rest
      (string "} ") string/print)
    #+end_src

*** test

    #+begin_src jojo
    (run (list {a {b c} d})
         jo-list/print)
    #+end_src

*** string-list/print

    #+begin_src jojo
    (declare (string-list/print (: cons -> [io])))

    (defun string/dot (: string -> [io])
      double-quote jo->string string/print
      string/print
      double-quote jo->string string/print
      (string " ") string/print)

    (defun string-list/print/rest (: cons -> [io])
      (if dup null eq? -> drop end)
      dup cdr string-list/print/rest
      car
      (if dup cons? -> string-list/print end)
      (else string/dot end))

    (defun string-list/print (: cons -> [io])
      (string "{ ") string/print
      string-list/print/rest
      (string "} ") string/print)
    #+end_src

*** test

    #+begin_src jojo
    (run (list {(string "111") {(string "222") (string "333")} (string "444")})
         string-list/print)
    #+end_src

* case

  #+begin_src jojo
  (defun compile-jojo (: [io] -> [compile])
    (string ")") string->jo compile-jojo/until-meet-jo)

  (defvar case-stack (int 1024) cell-size mul allocate)
  (defvar case-stack-pointer case-stack)
  (defun case-stack-pop (: -> stack/addr)
    case-stack-pointer cell-size sub
    (var case-stack-pointer) set
    case-stack-pointer get)
  (defun case-stack-push (: stack/addr ->)
    case-stack-pointer set
    case-stack-pointer cell-size add
    (var case-stack-pointer) set)

  (defun case/one (: [io] -> [compile])
    (jo ->) compile-jojo/until-meet-jo
    (jo over) here
    (jo eq?) here
    (jo instruction/lit) here
    compiling-stack/tos compiling-stack/inc
    (jo jump-if-false) here
    (jo drop) here
    square-ket compile-jojo/until-meet-jo
    compiling-stack/tos swap set)

  (defun case (: [io] -> [compile])
    read/jo
    (if dup round-ket eq? -> drop end)
    (if dup round-bar eq? -> drop read/jo key-jo/apply (loop))
    (if dup square-bar eq? -> drop case/one (loop))
    here (loop))

  (run
    (jo a)
    (case
      [(jo a) -> (string "a") string/print newline]
      (: comment)
      (string "between a & b") string/print newline
      [(jo b) -> (string "b") string/print newline]))

  (run
    (jo b)
    (case
      [(jo a) -> (string "a") string/print newline]
      [(jo b) -> (string "b") string/print newline]))
  #+end_src

* report

  #+begin_src jojo
  (: (run defprim/report
          defun/report
          defvar/report))
  #+end_src
