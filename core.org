#+property: tangle core.jo
#+title: core
- syntax of variable mirror local
- <stack>
- <table>
* todo

  - <str>

  - <jojo>

  - to see what <module> needs from <path> and <file>

  - example of the use of oo
    - syntax for super

  - [emacs]
    - write some emacs-lisp lib
    - bright and dark color theme

  - [testing] assert for embedded testing

  - [maybe] syntax for local helper functions

* note

*** terminology

    - tag as class-name

* flag

  #+begin_src jojo
  (run testing-flag/on)
  (test top-repl/printing-flag/on)
  #+end_src

* list

*** cons

    #+begin_src jojo
    (def cons-size      (bare-data (integer 3) cell-size mul))
    (def cons-area-size (bare-data (integer 1024 1024) mul cons-size mul))
    (def cons-area      (bare-data cons-area-size allocate))
    (def cons-area-top  (bare-data cons-area cons-area-size add))
    (def cons-pointer   (bare-data cons-area))
    (def current-mark   (bare-data (integer 1)))
    (def max-mark       (bare-data (integer 1024 1024) mul))

    (def cons-pointer/next
      (jojo
        (note -> [cons-pointer])
        cons-size cons-pointer add
        (& cons-pointer) set-cell))

    (def cons-pointer/init
      (jojo
        (note -> [cons-pointer])
        cons-area
        (& cons-pointer) set-cell))

    (def cons-pointer/next-free
      (jojo
        (note -> [cons-pointer])
        (if cons-pointer cons-area-top eq? then end)
        (if cons-pointer get-cell current-mark eq? not then end)
        cons-pointer/next
        (loop)))

    (def cons?
      (jojo
        (note cell -> bool)
        (if dup cons-area lt? then drop false end)
        (if dup cons-area-top gteq? then drop false end)
        cons-area sub cons-size mod (integer 0) eq?))



    (declare
     (car (note cons -> cell))
     (cdr (note cons -> cell)))

    (def cons-area/report/loop
      (jojo
        (note cons -> [io])
        (if dup cons-area-top eq? then drop end)
        (string "#:") string/print
        dup dot
        (string "mark: ") string/print
        dup get-cell dot
        (string "car: ") string/print
        dup car dot
        (string "cdr: ") string/print
        dup cdr dot
        newline
        cons-size add
        (loop)))

    (def cons-area/report
      (jojo
        (note -> [io])
        cons-area cons-area/report/loop))



    (def sweep-cons-area/loop
      (jojo
        (note cons -> [io])
        (if dup cons-area-top eq? then drop end)
        dup (integer 0)  swap set-cell
        cons-size add
        (loop)))

    (def sweep-cons-area
      (jojo
        (note -> [cons-area])
        cons-area sweep-cons-area/loop))



    (note root from :
          stack
          defbare-data)

    (def mark-cons
      (jojo
        (note cons -> [cons-area])
        (if dup cons? not then drop end)
        dup current-mark swap set-cell
        dup car mark-cons
        cdr (loop)))

    (def mark-cons-area/def-record
      (jojo
        (note def-record -> [cons-area])
        (if dup get-cell (integer 0) eq? then drop end)
        dup get-cell mark-cons
        cell-size add
        (loop)))

    (def mark-cons-area/argument-stack
      (jojo
        (note stack -> [cons-area])
        (if dup stack-base eq? then drop end)
        cell-size sub
        dup get-cell mark-cons
        (loop)))

    (def mark-cons-area
      (jojo
        (note -> [cons-area])
        (if current-mark max-mark eq? then
            sweep-cons-area
            (integer 0) (& current-mark) set-cell)
        current-mark (integer 1) add (& current-mark) set-cell
        def-record mark-cons-area/def-record
        stack-pointer
        mark-cons-area/argument-stack))



    (note cons :
          mark
          car
          cdr)

    (def new/cons
      (jojo
        (note -> cons)
        (if cons-pointer cons-area-top eq? then
            mark-cons-area
            cons-pointer/init
            cons-pointer/next-free
            (if cons-pointer cons-area-top eq? then
                (string "fatal error : cons-area is full") string/print
                newline bye)
            (loop))
        (if cons-pointer get-cell current-mark eq? then
            cons-pointer/next (loop))
        cons-pointer
        cons-pointer/next end))

    (def set-car
      (jojo
        (note cell cons ->)
        cell-size add
        set-cell))

    (def set-cdr
      (jojo
        (note cell cons ->)
        cell-size add
        cell-size add
        set-cell))

    (def car
      (jojo
        (note cons -> cell)
        cell-size add
        get-cell))

    (def cdr
      (jojo
        (note cons -> cell)
        cell-size add
        cell-size add
        get-cell))

    (def cons
      (jojo
        (note cdr-cell car-cell -> cons)
        new/cons
        tuck set-car
        tuck set-cdr))


    (note the following tests are for small cons-area)

    (note (test (integer 0)
                (integer 1) cons
                (integer 2) cons
                dup car dot
                dup cdr car dot
                dup cdr cdr dot

                dup cons? dot
                dup cdr cons? dot
                dup car cons? dot
                dup cdr car cons? dot
                dup cdr cdr cons? dot
                dot

                current-mark
                dot))

    (note (test newline
                new/cons dot
                new/cons dot
                new/cons dot
                new/cons dot
                new/cons dot
                current-mark dot
                newline
                cons-area/report
                newline))
    #+end_src

*** assoc-list

    #+begin_src jojo
    (def assq
      (jojo
        (note assoc-list value -> pair or null)
        (if over null eq? then drop drop null end)
        (if over car cdr over eq? then drop car end)
        swap cdr swap (loop)))

    (def assoc/find
      (jojo
        (note assoc-list value -> [pair true] or [false])
        (if over null eq? then drop drop false end)
        (if over car cdr over eq? then drop car true end)
        swap cdr swap (loop)))
    #+end_src

*** list/print

    #+begin_src jojo
    (def list/print
      (jojo
        (note list -> [output])
        (if dup null eq? then drop (jo null) jo/print (string " ") string/print end)
        (if dup cons? not then dot end)
        dup cdr (recur)
        car (recur) (jo cons) jo/print (string " ") string/print))
    #+end_src

*** list/copy

    #+begin_src jojo
    (def list/copy
      (jojo
        (note list -> list)
        (note circles are not handled)
        (if dup cons? then end)
        dup cdr (recur)
        car (recur)
        swap
        cons))

    (note
      (run (integer 1) (integer 2) cons
           (integer 3) null cons
           cons
           dup
           cons
           dup list/print newline
           dup list/copy list/print newline
           dup list/copy list/print newline
           drop))
    #+end_src

*** set-tail

    #+begin_src jojo
    (def set-tail
      (jojo
        (note element list ->)
        (if dup cdr null eq? then
            swap
            null swap cons
            swap
            set-cdr end)
        (el cdr (loop))))
    #+end_src

* [keyword] lev

  #+begin_src jojo
  (def lev
    (note lev denotes leave-data-here)
    (keyword
      read/jo
      (if dup round-ket eq? then drop end)
      (if dup round-bar eq? then drop
          read/jo
          (if dup (jo esc) eq? then
              drop compile-jojo (loop))
          (el jo/apply (jo here) here (loop)))
      (el (jo ins/lit) here
          here
          (jo here) here (loop))))
  #+end_src

* [keyword] alias

  #+begin_src jojo
  (def alias
    (keyword
      read/jo (> nick)
      (if (< nick) round-ket eq? then end)
      read/jo (> name)
      (if (< name) round-ket eq? then
          (string "- alias meet uneven list") string/print newline
          (string "  last nick : ") string/print (< nick) jo/print
          newline
          end)
      (el (lev ins/lit (< nick)
               ins/lit (< name)
               alias-push)
          (loop))))
  #+end_src

* [keyword] cat

*** cat

    #+begin_src jojo
    (def cat
      (keyword
        read/jo
        (if dup round-ket eq? then drop end)
        (if dup double-quote eq? then
            drop one-string
            (lev string/print)
            (loop))
        (if dup round-bar eq? then drop
            read/jo jo/apply (loop))
        (el here (loop))))
    #+end_src

*** test

    #+begin_src jojo
    (note (run (cat "1 2 3" newline "4 5 6" newline "7 8 9" newline)))
    #+end_src

* object note

  - class
    - one superclass
      thus single inheritance
    - meta-variable
    - meta-method
      two ways to implement object creation :
      [1] to use meta class -- class is an object
      [2] to use meta method -- class is not an object
      i will use [2]
    - instance-variable
      i.e. parts of the object
    - method-list
      where super can be used to use an method of superclass
      to implement a new method to override it

  - interface-generator
    when defining a class
    different interface-generator can be used to generate method list
    for example
    - low level array like data with free
    - high level list list data using gc

* [helper] class

  #+begin_src jojo
  (def class/get-tag                 (jojo (jo tag) assq car))

  (def class/has-superclass?         (jojo (jo inherit) assq null eq? not))
  (def class/get-super-tag           (jojo (jo inherit) assq car))

  (def class/has-meta-variable-list? (jojo (jo meta-variable) assq null eq? not))
  (def class/get-meta-variable-list  (jojo (jo meta-variable) assq car))

  (def class/has-meta-method-list?   (jojo (jo meta-method) assq null eq? not))
  (def class/get-meta-method-list    (jojo (jo meta-method) assq car))

  (def class/has-variable-list?      (jojo (jo variable) assq null eq? not))
  (def class/get-variable-list       (jojo (jo variable) assq car))

  (def class/has-method-list?        (jojo (jo method) assq null eq? not))
  (def class/get-method-list         (jojo (jo method) assq car))
  #+end_src

* [keyword] define-class

  #+begin_src jojo
  (def define-class/keyword/one-variable
    (keyword
      (lev ins/lit
           (esc read/jo here
                compile-jojo)
           cons cons cons)))

  (def jo-ending-with-colon?
    (jojo
      (note jo -> bool)
      jo->string string/last-char
      (string ":") string/last-char eq?))

  (def define-class/keyword/one-method/complex-message
    (keyword
      (note sum-jo -> sum-jo)
      read/jo
      (if dup round-ket eq? then drop end)
      (if dup jo-ending-with-colon? then
          jo/append
          (loop))
      swap (recur) swap
      (lev ins/lit
           (esc here)
           local-in)))

  (def define-class/keyword/one-method/message
    (keyword
      (note -> jo)
      read/jo
      (if dup round-bar eq? not then end)
      drop read/jo drop
      empty-jo define-class/keyword/one-method/complex-message))

  (def define-class/keyword/one-method/help
    (keyword
      (lev ins/jump)
      compiling-stack/tos (> offset-place)
      compiling-stack/inc
      compiling-stack/tos (> bare-jojo-place)
      define-class/keyword/one-method/message (> message)
      compile-jojo
      (lev end)
      compiling-stack/tos (< offset-place) set-cell
      (lev ins/lit (< bare-jojo-place)
           ins/lit (< message)
           swap
           cons)))

  (def define-class/keyword/one-method
    (keyword
      define-class/keyword/one-method/help
      (lev cons)))

  (def define-class/keyword/inherit
    (keyword
      (lev ins/lit inherit
           ins/lit
           (esc read/jo here
                ignore)
           cons
           cons)))

  (def define-class/keyword/meta-variable-list
    (keyword
      (alias * define-class/keyword/one-variable)
      (lev ins/lit meta-variable
           null
           (esc compile-jojo)
           cons
           cons)))

  (def define-class/keyword/meta-method-list
    (keyword
      (alias * define-class/keyword/one-method)
      (lev ins/lit meta-method
           null
           (esc compile-jojo)
           cons
           cons)))

  (def define-class/keyword/variable-list
    (keyword
      (alias * define-class/keyword/one-variable)
      (lev ins/lit variable
           null
           (esc compile-jojo)
           cons
           cons)))

  (def define-class/keyword/method-list
    (keyword
      (alias * define-class/keyword/one-method)
      (lev ins/lit method
           null
           (esc compile-jojo)
           cons
           cons)))

  (def define-class/help
    (keyword
      read/jo (> tag)
      (alias
        inherit       define-class/keyword/inherit
        meta-method   define-class/keyword/meta-method-list
        meta-variable define-class/keyword/meta-variable-list
        variable      define-class/keyword/variable-list
        method        define-class/keyword/method-list)
      (lev null
           ins/lit tag
           ins/lit (< tag)
           cons
           cons
           (esc compile-jojo)
           ins/lit <class>
           ins/lit (< tag))))

  (def define-class
    (keyword
      compiling-stack/tos (> begin)
      define-class/help
      (lev end)
      (< begin) apply
      bind-name))
  #+end_src

* send

*** send-to-class

    #+begin_src jojo
    (def send-to-class/find-meta-method
      (jojo
        (note class message -> [value <*> true] or [false])
        (> message)
        (> class)
        (if (< class) class/has-meta-method-list? then
            (< class) class/get-meta-method-list
            (< message)
            assoc/find
            (if then
                car
                true
                end))
        (if (< class) class/has-superclass? then
            (< class) class/get-super-tag jo/apply drop
            (< message)
            (loop))
        false))

    (def send-to-class
      (jojo
        (> message)
        (> class)
        (< class) (< message)
        send-to-class/find-meta-method
        (if then
            current-local-pointer swap
            (< class) (jo self-class) local-data-in
            apply-with-local-pointer
            end)
        (string "- send-to-class : can not find message : ") string/print
        (< message) jo/print newline))
    #+end_src

*** send-to-object

    #+begin_src jojo
    (def send-to-object/find-method
      (jojo
        (note tag message -> [bare-jojo true] or [false])
        (> message)
        (> tag)
        (< tag) jo/apply drop (> class)
        (if (< class) class/has-method-list? then
            (< class) class/get-method-list
            (< message) assoc/find
            (if then
                car
                true
                end))
        (if (< class) class/has-superclass? then
            (< class) class/get-super-tag
            (< message)
            (loop))
        false))

    (def send-to-object
      (jojo
        (> message)
        (> tag)
        (> data)
        (< tag) (< message)
        send-to-object/find-method
        (if then
            current-local-pointer swap
            (< data) (< tag) (jo self) local-in
            apply-with-local-pointer
            end)
        (string "- send-to-object : can not find message : ") string/print
        (< message) jo/print newline
        (string "  object/tag : ") string/print
        (< tag) jo/print newline))
    #+end_src

*** send

    #+begin_src jojo
    (def send
      (jojo
        (if over (jo <class>) eq? then swap drop send-to-class end)
        send-to-object))
    #+end_src

* [keyword] :

  #+begin_src jojo
  (def send/sugar/complex
    (keyword
      (note sum-jo -> sum-jo)
      read/jo
      (if dup round-ket eq? then drop end)
      (if dup round-bar eq? then drop read/jo jo/apply (loop))
      (if dup jo-ending-with-colon? then jo/append (loop))
      here (loop)))

  (def :
    (keyword
      (jo :) generate-jo (> object-jo)
      (lev ins/lit (< object-jo)
           local-in
           (esc read/jo
                (if dup jo-ending-with-colon? not
                    then (> message) compile-jojo
                    else send/sugar/complex (> message)))
           ins/lit (< object-jo)
           local-out
           ins/lit (< message)
           send)))
  #+end_src

* syntax for variable

*** [keyword] @ and !

    #+begin_src jojo
    (def get-instance-variable
      (jojo
        (note [object name] -> [data tag])
        (> name)
        (> tag)
        (> instance-variable-list)

        (< instance-variable-list)
        (< name)
        assoc/find
        (if then car dup car swap cdr swap end)
        (string "- get-instance-variable fail") string/print newline))

    (def @
      (keyword
        (lev ins/lit
             (esc read/jo here
                  ignore)
             get-instance-variable)))


    (def set-instance-variable
      (jojo
        (note [object data type name] -> [])
        (> name)
        (> tag)
        (> instance-variable-list)
        (> type-name)
        (> data)

        (< instance-variable-list)
        (< name)
        assoc/find
        (if then (> instance-variable)
            (< data) (< type-name) cons
            (< instance-variable) set-car end)
        (string "- set-instance-variable fail") string/print newline))

    (def !
      (keyword
        (lev ins/lit
             (esc read/jo here
                  ignore)
             set-instance-variable)))
    #+end_src

* [keyword] add-method

  #+begin_src jojo
  (def add-method
    (keyword
      read/jo (> tag)
      (< tag) jo/apply drop (> class)
      compiling-stack/tos (> begin)
      define-class/keyword/one-method/help
      (lev end)
      (< begin) apply (> method)

      (if (< class) class/has-method-list? not then
          (jo method) (< method) cons
          (< class) set-tail end)
      (el (< method)
          (< class) class/get-method-list
          set-tail)))
  #+end_src

* <object>

*** note

    - an <object> is two values on the stack [data tag].
    - the data of an <object> is simply an assoc-list of name and value.

*** <object>

    #+begin_src jojo
    (define-class <object>
      (meta-method
        (* new
           (if (< self-class) class/has-variable-list? then
               (< self-class) class/get-variable-list list/copy
               (< self-class) class/get-tag end)
           null
           (< self-class) class/get-tag)))
    #+end_src

* <int>

*** <int>

    #+begin_src jojo
    (define-class <int>
      (method
        (* inc (< self) inc (<% self))
        (* dec (< self) dec (<% self))
        (* neg (< self) neg (<% self))

        (* (: add: i) (< self) (< i) add (<% self))
        (* (: sub: i) (< self) (< i) sub (<% self))
        (* (: mul: i) (< self) (< i) mul (<% self))
        (* (: div: i) (< self) (< i) div (<% self))
        (* (: mod: i) (< self) (< i) mod (<% self))

        (* (: eq?: i) (< self) (< i) eq?)
        (* (: gt?: i) (< self) (< i) gt?)
        (* (: lt?: i) (< self) (< i) lt?)
        (* (: gteq?: i) (< self) (< i) gteq?)
        (* (: lteq?: i) (< self) (< i) lteq?)

        (* print (< self) integer/print)
        (* dot (< self) integer/dot)
        (* write (string "(int ") string/print
           (<< self) (: print)
           (string ") ") string/print)))
    #+end_src

*** [keyword] int

    #+begin_src jojo
    (def int
      (keyword
        (jo integer) jo/apply
        (lev ins/lit <int>)))
    #+end_src

* <str>

*** note

    - <str> is static allocated,
      no gc for this class.

*** <str>

    #+begin_src jojo
    (define-class <str>
      (method
        (* print (< self) string/print)
        (* length (< self) string/length (jo <int>))
        (* write
           (string "(str ") string/print
           double-quote jo/print
           (<< self) (: print)
           double-quote jo/print
           (string ") ") string/print)))
    #+end_src

*** [keyword] str

    #+begin_src jojo
    (def str
      (keyword
        (jo string) jo/apply
        (lev ins/lit <str>)))
    #+end_src

*** test

    #+begin_src jojo
    (note
      (test (str "k1 k2 k3")
            2dup (: print) newline
            2dup (: write) newline
            2dup (: length) (: print) newline
            2dup (: length) (: write) newline
            2drop))
    #+end_src

* <jojo>

*** note

    - play with combinators

*** <jojo>

    #+begin_src jojo
    (define-class <jojo>
      (method
        (* apply (< self) apply)))
    #+end_src

* <table>

*** <table>

    #+begin_src jojo
    (define-class <table>
      (method
        (* find )))
    #+end_src

* <stack>

*** <stack>

    #+begin_src jojo
    (note
      (define-class <stack>
        (variable
          (* stack null))
        (method
          (* pop
             )
          (* (: push: value)
             ))))
    #+end_src

* >< <system>

*** system

    #+begin_src jojo
    (test current-dir string/print newline)

    (test (string "HOME") var-string->env-string
          string/print newline)

    (test (string "PATH") var-string->env-string
          string/print newline)

    (def command-line/print-argument/loop
      (jojo (note index -> [io])
        (if dup argument-counter lt? then
            dup index->argument-string string/print
            newline
            (integer 1) add
            (loop))
        drop end))

    (def command-line/print-argument
      (jojo (note -> [io])
        (integer 0) command-line/print-argument/loop))

    (test command-line/print-argument)

    (note (test def-report))
    #+end_src

* <path>

*** <path>

    #+begin_src jojo
    (define-class <path>
      (inherit <str>)
      (method
        (* write
           (string "(path ") string/print
           double-quote jo/print
           (<< self) (: print)
           double-quote jo/print
           (string ") ") string/print)))

    (add-method <str> to-path
      (< self) (jo <path>))
    #+end_src

*** test

    #+begin_src jojo
    (test (str "/home/") (: to-path) (: write))
    #+end_src

* >< <file>

*** note

    #+begin_src jojo
    (note

      (define-class <file>
        (method
          (* close)))

      (add-method <path> open-for-reading
        (< self) string/open-for-reading)

      (add-method <path> (: open-for: flags)
        (note fd = open(pathname, flags, mode)
              if the file doesn’t exist,
              open() may create it,
              depending on the settings of the flags bitmask argument.
              the flags argument also specifies
              whether the file is to be opened for reading, writing, or both.))

      (add-method <path> (: open-for: flags with: mode)
        (note the mode argument specifies the permissions
              to be placed on the file if it is created by this call.
              If the open() call is not being used to create a file,
              this argument is ignored and can be omitted))

      (note numread = read(fd, buffer, count)
            reads at most count bytes from the open file
            referred to by fd and stores them in buffer.
            The read() call returns the number of bytes actually read.
            If no further bytes could be read
            (i.e., end-of-file was encountered),
            read() returns 0.)

      (note numwritten = write(fd, buffer, count)
            writes up to count bytes from buffer to the open file
            referred to by fd.
            The write() call returns the number of bytes actually written,
            which may be less than count.)

      (note status = close(fd)
            is called after all I/O has been completed,
            in order to release the file descriptor fd
            and its associated kernel resources.))
    #+end_src

*** test

    #+begin_src jojo
    (test (string "README") file/size dot)

    (test (string "README") file/readable? dot)

    (test (string "README")
          dup file/size
          allocate tuck file/copy-to-buffer
          drop
          string/print
          newline)
    #+end_src

* >< <module>

*** note

    - module is simply a dir of source code files,
      with a module.jo to store meta data of the module.

    - a module-record for loaded modules to avoid reload.

    - install modules to "~/.jojo/module/"
      as "module-name/version/*"

    - command-line interface of module-system :
      install
      uninstall
      reinstall

    - module-system helps name to be unique
      by adding prefix to name
      prefix is simply "module-name[version]."

    - a package manager to download dependences and install them.

    - unique naming is ensured by prefix,
      thus no export-list,
      thus all of a module are exposed to a user of the module.

    #+begin_src jojo
    (note
      (module module-name [version])
      (use module-name [version]
           ...)
      (include "path"))

    (note
      (load-module module-name[version])

      module-stack module-name[version]

      define name
      def module-name[version].name

      defining-stack name module-name[version].name)
    #+end_src

*** note module

    - x -
      module-stack for current defining-prefix
      defining-stack for current names to be prefixed

      - thus in a module
        one can not use name in core

        when one wants to use a name in core in his module
        he must prefix his version of this name by '.'

        thus the core must be very small
        and it must be fixed in early version of the language

*** module-stack

    #+begin_src jojo
    (note
      (def module-stack
        ))
    #+end_src

*** module-record

    #+begin_src jojo
    (note
      (def module-record
        ))
    #+end_src

* >< <clib>

*** note

    - [ffi]
      c is only used to implement primitive object ?
      and to do optimization ?

*** example

    #+begin_src jojo
    (note
      (include "path")
      (clib "path"))
    #+end_src

* test

  #+begin_src jojo
  (define-class <person>
    (inherit <object>)
    (variable
      (* age (int 13))
      (* language (str "chinese")))
    (method
      (* grow
         (<< self) (@ age) (: inc)
         (<< self) (! age))
      (* (: grow-by: years)
         (<< self) (@ age) (: add: (<< years))
         (<< self) (! age))
      (* (: grow-by: year1 and-by: year2)
         (<< self) (@ age) (: add: (<< year1)) (: add: (<< year2))
         (<< self) (! age))
      (* report
         (cat "age: "
              (<< self) (@ age) (: print) newline
              "languege: "
              (<< self) (@ language) (: print) newline))))

  (def xieyuheng <person> (: new))

  (run xieyuheng (: report)
       xieyuheng (: grow)
       xieyuheng (: report)
       xieyuheng (: grow-by: (int 10))
       xieyuheng (: report)
       xieyuheng (: grow-by: (int 10))
       xieyuheng (: report)
       xieyuheng (: grow-by: (int 10) and-by: (int 10))
       xieyuheng (: report))
  #+end_src

* test

  #+begin_src jojo
  (note (test (string "asd") open-for-reading dot)
        (test (string "README") open-for-reading dot))
  #+end_src
