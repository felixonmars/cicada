#+property: tangle core.jo
#+title: core

* todo

  - define-method

  - [primitive class] <int>

  - [primitive class] <str>

  - example of the use of oo

  - [emacs]
    - write some emacs-lisp lib
    - bright and dark color theme

  - [testing] assert for embedded testing

  - [maybe] syntax for local helper functions

* flag

  #+begin_src jojo
  (run testing-flag/on)
  (test top-repl/printing-flag/on)
  #+end_src

* list

*** cons

    #+begin_src jojo
    (def cons-size      (bare-data (integer 3) cell-size mul))
    (def cons-area-size (bare-data (integer 1024 1024) mul cons-size mul))
    (def cons-area      (bare-data cons-area-size allocate))
    (def cons-area-top  (bare-data cons-area cons-area-size add))
    (def cons-pointer   (bare-data cons-area))
    (def current-mark   (bare-data (integer 1)))
    (def max-mark       (bare-data (integer 1024 1024) mul))

    (def cons-pointer/next
      (jojo
        (note -> [cons-pointer])
        cons-size cons-pointer add
        (& cons-pointer) set))

    (def cons-pointer/init
      (jojo
        (note -> [cons-pointer])
        cons-area
        (& cons-pointer) set))

    (def cons-pointer/next-free
      (jojo
        (note -> [cons-pointer])
        (if cons-pointer cons-area-top eq? then end)
        (if cons-pointer get current-mark eq? not then end)
        cons-pointer/next
        (loop)))

    (def cons?
      (jojo
        (note cell -> bool)
        (if dup cons-area lt? then drop false end)
        (if dup cons-area-top gteq? then drop false end)
        cons-area sub cons-size mod (integer 0) eq?))



    (declare
     (car (note cons -> cell))
     (cdr (note cons -> cell)))

    (def cons-area/report/loop
      (jojo
        (note cons -> [io])
        (if dup cons-area-top eq? then drop end)
        (string "#:") string/print
        dup dot
        (string "mark: ") string/print
        dup get dot
        (string "car: ") string/print
        dup car dot
        (string "cdr: ") string/print
        dup cdr dot
        newline
        cons-size add
        (loop)))

    (def cons-area/report
      (jojo
        (note -> [io])
        cons-area cons-area/report/loop))



    (def sweep-cons-area/loop
      (jojo
        (note cons -> [io])
        (if dup cons-area-top eq? then drop end)
        dup (integer 0)  swap set
        cons-size add
        (loop)))

    (def sweep-cons-area
      (jojo
        (note -> [cons-area])
        cons-area sweep-cons-area/loop))



    (note root from :
          stack
          defbare-data)

    (def mark-cons
      (jojo
        (note cons -> [cons-area])
        (if dup cons? not then drop end)
        dup current-mark swap set
        dup car mark-cons
        cdr (loop)))

    (def mark-cons-area/def-record
      (jojo
        (note def-record -> [cons-area])
        (if dup get (integer 0) eq? then drop end)
        dup get mark-cons
        cell-size add
        (loop)))

    (def mark-cons-area/argument-stack
      (jojo
        (note stack -> [cons-area])
        (if dup stack-base eq? then drop end)
        cell-size sub
        dup get mark-cons
        (loop)))

    (def mark-cons-area
      (jojo
        (note -> [cons-area])
        (if current-mark max-mark eq? then
            sweep-cons-area
            (integer 0) (& current-mark) set)
        current-mark (integer 1) add (& current-mark) set
        def-record mark-cons-area/def-record
        stack-pointer
        mark-cons-area/argument-stack))



    (note cons :
          mark
          car
          cdr)

    (def new/cons
      (jojo
        (note -> cons)
        (if cons-pointer cons-area-top eq? then
            mark-cons-area
            cons-pointer/init
            cons-pointer/next-free
            (if cons-pointer cons-area-top eq? then
                (string "fatal error : cons-area is full") string/print
                newline bye)
            (loop))
        (if cons-pointer get current-mark eq? then
            cons-pointer/next (loop))
        cons-pointer
        cons-pointer/next end))

    (def set-car
      (jojo
        (note cell cons ->)
        cell-size add
        set))

    (def set-cdr
      (jojo
        (note cell cons ->)
        cell-size add
        cell-size add
        set))

    (def car
      (jojo
        (note cons -> cell)
        cell-size add
        get))

    (def cdr
      (jojo
        (note cons -> cell)
        cell-size add
        cell-size add
        get))

    (def cons
      (jojo
        (note cdr-cell car-cell -> cons)
        new/cons
        tuck set-car
        tuck set-cdr))


    (note the following tests are for small cons-area)

    (note (test (integer 0)
                (integer 1) cons
                (integer 2) cons
                dup car dot
                dup cdr car dot
                dup cdr cdr dot

                dup cons? dot
                dup cdr cons? dot
                dup car cons? dot
                dup cdr car cons? dot
                dup cdr cdr cons? dot
                dot

                current-mark
                dot))

    (note (test newline
                new/cons dot
                new/cons dot
                new/cons dot
                new/cons dot
                new/cons dot
                current-mark dot
                newline
                cons-area/report
                newline))
    #+end_src

*** assoc-list

    #+begin_src jojo
    (def assq
      (jojo
        (note assoc-list value -> pair or null)
        (if over null eq? then drop drop null end)
        (if over car cdr over eq? then drop car end)
        swap cdr swap (loop)))

    (def assoc/find
      (jojo
        (note assoc-list value -> [pair true] or [false])
        (if over null eq? then drop drop false end)
        (if over car cdr over eq? then drop car true end)
        swap cdr swap (loop)))
    #+end_src

*** list/print

    #+begin_src jojo
    (def list/print
      (jojo
        (note list -> [output])
        (if dup null eq? then drop (jo null) jo/print (string " ") string/print end)
        (if dup cons? not then dot end)
        dup cdr (recur)
        car (recur) (jo cons) jo/print (string " ") string/print))
    #+end_src

*** list/copy

    #+begin_src jojo
    (def list/copy
      (jojo
        (note list -> list)
        (note circles are not handled)
        (if dup cons? then end)
        dup cdr (recur)
        car (recur)
        swap
        cons))

    (note
      (run (integer 1) (integer 2) cons
           (integer 3) null cons
           cons
           dup
           cons
           dup list/print newline
           dup list/copy list/print newline
           dup list/copy list/print newline
           drop))
    #+end_src

* [keyword] lev

  #+begin_src jojo
  (def lev
    (note lev denotes leave-data-here)
    (keyword
      read/jo
      (if dup round-ket eq? then drop end)
      (if dup round-bar eq? then drop
          read/jo
          (if dup (jo esc) eq? then
              drop compile-jojo (loop))
          (el jo/apply (jo here) here (loop)))
      (el (jo ins/lit) here
          here
          (jo here) here (loop))))
  #+end_src

* [keyword] alias

  #+begin_src jojo
  (def alias
    (keyword
      read/jo (> nick)
      (if (< nick) round-ket eq? then end)
      read/jo (> name)
      (if (< name) round-ket eq? then
          (string "- alias meet uneven list") string/print newline
          (string "  last nick : ") string/print (< nick) jo/print
          newline
          end)
      (el (lev ins/lit (< nick)
               ins/lit (< name)
               alias-push)
          (loop))))
  #+end_src

* object

*** note

    - class
      - one superclass
        thus single inheritance
      - meta-variable
      - meta-method
        two ways to implement object creation :
        [1] to use meta class -- class is an object
        [2] to use meta method -- class is not an object
        i will use [2]
      - instance-variable
        i.e. parts of the object
      - method-list
        where super can be used to use an method of superclass
        to implement a new method to override it

    - interface-generator
      when defining a class
      different interface-generator can be used to generate method list
      for example
      - low level array like data with free
      - high level list list data using gc

*** help

    #+begin_src jojo
    (def class/get-class-name          (jojo (jo class-name) assq car))

    (def class/has-superclass?         (jojo (jo inherit) assq null eq? not))
    (def class/get-superclass-name     (jojo (jo inherit) assq car))

    (def class/has-meta-variable-list? (jojo (jo meta-variable) assq null eq? not))
    (def class/get-meta-variable-list  (jojo (jo meta-variable) assq car))

    (def class/has-meta-method-list?   (jojo (jo meta-method) assq null eq? not))
    (def class/get-meta-method-list    (jojo (jo meta-method) assq car))

    (def class/has-variable-list?      (jojo (jo variable) assq null eq? not))
    (def class/get-variable-list       (jojo (jo variable) assq car))

    (def class/has-method-list?        (jojo (jo method) assq null eq? not))
    (def class/get-method-list         (jojo (jo method) assq car))
    #+end_src

*** [keyword] define-class

    #+begin_src jojo
    (def define-class/keyword/one-variable
      (keyword
        (lev ins/lit
             (esc read/jo here
                  compile-jojo)
             cons cons cons)))

    (def jo-ending-with-colon?
      (jojo
        (note jo -> bool)
        jo->string string/last-char
        (string ":") string/last-char eq?))

    (def define-class/keyword/one-method/complex-message
      (keyword
        (note sum-jo -> sum-jo)
        read/jo
        (if dup round-ket eq? then drop end)
        (if dup jo-ending-with-colon? then
            jo/append
            (loop))
        swap (recur) swap
        (lev ins/lit
             (esc here)
             local-two-in)))

    (def define-class/keyword/one-method/message
      (keyword
        (note -> jo)
        read/jo
        (if dup round-bar eq? not then end)
        drop read/jo drop
        empty-jo define-class/keyword/one-method/complex-message))

    (def define-class/keyword/one-method
      (keyword
        (lev ins/jump)
        compiling-stack/tos (> offset-place)
        compiling-stack/inc
        compiling-stack/tos (> bare-jojo-place)
        define-class/keyword/one-method/message (> message)
        compile-jojo
        (lev end)
        compiling-stack/tos (< offset-place) set
        (lev ins/lit (< bare-jojo-place)
             ins/lit (< message)
             swap
             cons
             cons)))

    (def define-class/keyword/inherit
      (keyword
        (lev ins/lit inherit
             ins/lit
             (esc read/jo here
                  ignore)
             cons
             cons)))

    (def define-class/keyword/meta-variable-list
      (keyword
        (alias * define-class/keyword/one-variable)
        (lev ins/lit meta-variable
             null
             (esc compile-jojo)
             cons
             cons)))

    (def define-class/keyword/meta-method-list
      (keyword
        (alias * define-class/keyword/one-method)
        (lev ins/lit meta-method
             null
             (esc compile-jojo)
             cons
             cons)))

    (def define-class/keyword/variable-list
      (keyword
        (alias * define-class/keyword/one-variable)
        (lev ins/lit variable
             null
             (esc compile-jojo)
             cons
             cons)))

    (def define-class/keyword/method-list
      (keyword
        (alias * define-class/keyword/one-method)
        (lev ins/lit method
             null
             (esc compile-jojo)
             cons
             cons)))

    (def define-class/help
      (keyword
        read/jo (> class-name)
        (alias
          inherit       define-class/keyword/inherit
          meta-method   define-class/keyword/meta-method-list
          meta-variable define-class/keyword/meta-variable-list
          variable      define-class/keyword/variable-list
          method        define-class/keyword/method-list)
        (lev null
             ins/lit class-name
             ins/lit (< class-name)
             cons
             cons
             (esc compile-jojo)
             ins/lit <class>
             ins/lit (< class-name))))

    (def define-class
      (keyword
        compiling-stack/tos (> begin)
        define-class/help
        (lev end)
        (< begin) apply
        bind-name))
    #+end_src

*** send-to-class

    #+begin_src jojo
    (def send-to-class/find-meta-method
      (jojo
        (note class message -> [value <*> true] or [false])
        (> message)
        (> class)
        (if (< class) class/has-meta-method-list? then
            (< class) class/get-meta-method-list
            (< message)
            assoc/find
            (if then
                car
                true
                end))
        (if (< class) class/has-superclass? then
            (< class) class/get-superclass-name jo/apply drop
            (< message)
            (loop))
        false))

    (def send-to-class
      (jojo
        (> message)
        (> class)
        (< class) (< message)
        send-to-class/find-meta-method
        (if then
            current-local-pointer swap
            (< class) (jo self-class) local-in
            apply-with-local-pointer
            end)
        (string "- send-to-class : can not find message : ") string/print
        (< message) jo/print newline))
    #+end_src

*** send-to-object

    #+begin_src jojo
    (def send-to-object/find-method
      (jojo
        (note class-name message -> [bare-jojo true] or [false])
        (> message)
        (> class-name)
        (< class-name) jo/apply drop (> class)
        (if (< class) class/has-method-list? then
            (< class) class/get-method-list
            (< message) assoc/find
            (if then
                car
                true
                end))
        (if (< class) class/has-superclass? then
            (< class) class/get-superclass-name
            (< message)
            (loop))
        false))

    (def send-to-object
      (jojo
        (> message)
        (> class-name)
        (> data)
        (< class-name) (< message)
        send-to-object/find-method
        (if then
            current-local-pointer swap
            (< data) (< class-name) (jo self) local-two-in
            apply-with-local-pointer
            end)
        (string "- send-to-object : can not find message : ") string/print
        (< message) jo/print newline
        (string "  object/class-name : ") string/print
        (< class-name) jo/print newline))
    #+end_src

*** send

    #+begin_src jojo
    (def send
      (jojo
        (if over (jo <class>) eq? then swap drop send-to-class end)
        send-to-object))
    #+end_src

*** [keyword] :

    #+begin_src jojo
    (def send/sugar/complex
      (keyword
        (note sum-jo -> sum-jo)
        read/jo
        (if dup round-ket eq? then drop end)
        (if dup round-bar eq? then drop read/jo jo/apply (loop))
        (if dup jo-ending-with-colon? then jo/append (loop))
        here (loop)))

    (def :
      (keyword
        (jo :) generate-jo (> object-jo)
        (lev ins/lit (< object-jo)
             local-two-in
             (esc read/jo
                  (if dup jo-ending-with-colon? not
                      then (> message) compile-jojo
                      else send/sugar/complex (> message)))
             ins/lit (< object-jo)
             local-two-out
             ins/lit (< message)
             send)))
    #+end_src

*** [keyword] @ and !

    - syntax for instance-variable
      simply set and get

    #+begin_src jojo
    (def get-instance-variable
      (jojo
        (note [object name] -> [data tag])
        (> name)
        (> class-name)
        (> instance-variable-list)

        (< instance-variable-list)
        (< name)
        assoc/find
        (if then car dup car swap cdr swap end)
        (string "- get-instance-variable fail") string/print newline))

    (def @
      (keyword
        (lev ins/lit
             (esc read/jo here
                  ignore)
             get-instance-variable)))


    (def set-instance-variable
      (jojo
        (note [object data type name] -> [])
        (> name)
        (> class-name)
        (> instance-variable-list)
        (> type-name)
        (> data)

        (< instance-variable-list)
        (< name)
        assoc/find
        (if then (> instance-variable)
            (< data) (< type-name) cons
            (< instance-variable) set-car end)
        (string "- set-instance-variable fail") string/print newline))

    (def !
      (keyword
        (lev ins/lit
             (esc read/jo here
                  ignore)
             set-instance-variable)))
    #+end_src

*** >< [keyword] define-method

    #+begin_src jojo
    (def define-method
      (keyword
        ))
    #+end_src

* [keyword] cat

*** cat

    #+begin_src jojo
    (def cat
      (keyword
        read/jo
        (if dup round-ket eq? then drop end)
        (if dup double-quote eq? then
            drop one-string
            (lev string/print)
            (loop))
        (if dup round-bar eq? then drop
            read/jo jo/apply (loop))
        (el here (loop))))
    #+end_src

*** test

    #+begin_src jojo
    (note (run (cat "1 2 3" newline "4 5 6" newline "7 8 9" newline)))
    #+end_src

* <object>

*** note

    - an <object> is two values on the stack [data class-name].
    - the data of an <object> is simply an assoc-list of name and value.

*** <object>

    #+begin_src jojo
    (define-class <object>
      (meta-method
        (* new
           (if (< self-class) class/has-variable-list? then
               (< self-class) class/get-variable-list list/copy
               (< self-class) class/get-class-name end)
           null
           (< self-class) class/get-class-name)))
    #+end_src

* <int>

*** <int>

    #+begin_src jojo
    (define-class <int>
      (method
        (* inc
           (<< self)
           swap (integer 1) add
           swap)
        (* (: add: i)
           (<< self) drop
           (<< i) drop
           add (jo <int>))
        (* print
           (<< self) drop integer/print)
        (* write
           (string "(int ") string/print
           (<< self) (: print)
           (string ") ") string/print)))
    #+end_src

*** [keyword] int

    #+begin_src jojo
    (def int
      (keyword
        (jo integer) jo/apply
        (lev ins/lit <int>)))
    #+end_src

*** test

    #+begin_src jojo
    (run (int 123) 2dup (: print) newline (: write))
    #+end_src

* <str>

*** <str>

    #+begin_src jojo
    (define-class <str>
      (method
        (* print
           (<< self) drop string/print)
        (* write
           (string "(str ") string/print
           double-quote jo/print
           (<< self) (: print)
           double-quote jo/print
           (string ") ") string/print)
        (* length
           (<< self) drop string/length (jo <int>))))
    #+end_src

*** [keyword] str

    #+begin_src jojo
    (def str
      (keyword
        (jo string) jo/apply
        (lev ins/lit <str>)))
    #+end_src

*** test

    #+begin_src jojo
    (run (str "k1 k2 k3")
         2dup (: print) newline
         2dup (: write) newline
         2dup (: length) (: print) newline
         2dup (: length) (: write) newline
         2drop)
    #+end_src

* >< <list>

* >< <system>

*** system

    #+begin_src jojo
    (test current-dir string/print newline)

    (test (string "HOME") var-string->env-string
          string/print newline)

    (test (string "PATH") var-string->env-string
          string/print newline)

    (def command-line/print-argument/loop
      (jojo (note index -> [io])
        (if dup argument-counter lt? then
            dup index->argument-string string/print
            newline
            (integer 1) add
            (loop))
        drop end))

    (def command-line/print-argument
      (jojo (note -> [io])
        (integer 0) command-line/print-argument/loop))

    (test command-line/print-argument)

    (note (test def-report))
    #+end_src

* <path>

*** <path>

    #+begin_src jojo
    (define-class <path>
      (* write
         (string "(path ") string/print
         double-quote jo/print
         (<< self) (: print)
         double-quote jo/print
         (string ") ") string/print))

    (note (define-method <str> to-path
            ))
    #+end_src

*** test

    #+begin_src jojo

    #+end_src

* >< <file>

*** note

    #+begin_src jojo
    (define-class <file>
      )
    #+end_src

*** file

    #+begin_src jojo
    (test (string "README") file/size dot)

    (test (string "README") file/readable? dot)

    (test (string "README")
          dup file/size
          allocate tuck file/copy-to-buffer
          drop
          string/print
          newline)
    #+end_src

* >< <module>

*** note

    - module is simply a dir of source code files,
      with a module.jo to store meta data of the module.

      a module-record for loaded modules to avoid reload.

    - a package manager to download dependences and install them.

    - command-line interface of module-system :
      install
      uninstall
      reinstall

    - ~/.jojo/ to store installed modules.

    - namespace
      to avoid duplicated naming.
      how is an unique name ?
      module/version/name ?

    - version of module
      module/version/name ?

    - the re-export problem
      is a module encoded by interface function name ?
      shoud we use sub-module ?

    #+begin_src jojo
    (note
      (module <module-name> function ...)
      (dep <module-name>)
      (include <path>)
      (clib <path>))
    #+end_src

* >< <clib>

*** note

    - [ffi]
      c is only used to implement primitive object ?
      and to do optimization ?

* test

  #+begin_src jojo
  (define-class <person>
    (inherit <object>)
    (variable
      (* age (int 13))
      (* language (str "chinese")))
    (method
      (* grow
         (<< self) (@ age) (: inc)
         (<< self) (! age))
      (* (: grow-by: years)
         (<< self) (@ age) (: add: (<< years))
         (<< self) (! age))
      (* (: grow-by: year1 and-by: year2)
         (<< self) (@ age) (: add: (<< year1)) (: add: (<< year2))
         (<< self) (! age))
      (* report
         (cat "age: "
              (<< self) (@ age) (: print) newline
              "languege: "
              (<< self) (@ language) (: print) newline))))

  (def xieyuheng <person> (: new))

  (run xieyuheng (: report)
       xieyuheng (: grow)
       xieyuheng (: report)
       xieyuheng (: grow-by: (int 10))
       xieyuheng (: report)
       xieyuheng (: grow-by: (int 10))
       xieyuheng (: report)
       xieyuheng (: grow-by: (int 10) and-by: (int 10))
       xieyuheng (: report))
  #+end_src
