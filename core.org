#+PROPERTY: tangle core.jo
#+title: core

* note

*** intro

    - three level of languages :
      baredata -> list -> object

*** oo

    - oo like smalltalk
      re-implement everything by oo
      to see where it can take us

    - oo 的設計需要考慮到 c
      c 中的數據結構和函數 要能夠方便地 轉化成 jojo 的 class 與 method
      同時又要知道 jojo 所使用的主要數據結構是鏈表

*** module system

***** note

      - 以 module 爲單位加載別人寫的函數所在的文件
        用 module_record 來記錄已經加載過的 module
        加載過的就不重複加載

***** 命名

      - 需要避免命名衝突

      - 每個函數有實際的唯一的名字
        module/name

      - 在每個 module 加載過程中
        ><

***** 版本

      - 需要控制版本
        module/name

      - ><

***** >< re-export

      - module 正是用 interface function name 來編碼的
        所以可以設計類似 subtype 的機制
        (考慮 ocaml)

* flag

  #+begin_src jojo
  (run testing-flag/on)
  (test top-repl/printing-flag/on)
  #+end_src

* list

*** cons-area

    #+begin_src jojo
    (defvar cons-size (int 3) cell-size mul)
    (defvar cons-area-size
      (note (int 5) (note for testing))
      (int 1024 1024) mul
      cons-size mul)

    (defvar cons-area cons-area-size allocate)
    (defvar cons-area-top cons-area cons-area-size add)

    (defvar cons-pointer cons-area)

    (defvar current-mark (int 1))
    (defvar max-mark (note (int 3) (note for testing))
            (int 1024 1024) mul)

    (defun cons-pointer/next (note -> [cons-pointer])
      cons-size cons-pointer add
      (var cons-pointer) set)

    (defun cons-pointer/init (note -> [cons-pointer])
      cons-area
      (var cons-pointer) set)

    (defun cons-pointer/next-free (note -> [cons-pointer])
      (if cons-pointer cons-area-top eq? then end)
      (if cons-pointer get current-mark eq? not then end)
      cons-pointer/next
      (loop))

    (defun cons? (note cell -> bool)
      (if dup cons-area lt? then drop false end)
      (if dup cons-area-top gteq? then drop false end)
      cons-area sub cons-size mod (int 0) eq?)
    #+end_src

*** cons-area/report

    #+begin_src jojo
    (declare
      (car (note cons -> cell))
      (cdr (note cons -> cell)))

    (defun cons-area/report/loop (note cons -> [io])
      (if dup cons-area-top eq? then drop end)
      (string "#:") string/print
      dup dot
      (string "mark: ") string/print
      dup get dot
      (string "car: ") string/print
      dup car dot
      (string "cdr: ") string/print
      dup cdr dot
      newline
      cons-size add
      (loop))

    (defun cons-area/report (note -> [io])
      cons-area cons-area/report/loop)
    #+end_src

*** sweep-cons-area

    #+begin_src jojo
    (defun sweep-cons-area/loop (note cons -> [io])
      (if dup cons-area-top eq? then drop end)
      dup (int 0)  swap set
      cons-size add
      (loop))

    (defun sweep-cons-area (note -> [cons-area])
      cons-area sweep-cons-area/loop)
    #+end_src

*** mark-cons-area

    - root from
      - stack
      - defvar

    #+begin_src jojo
    (defun mark-cons (note cons -> [cons-area])
      (if dup cons? not then drop end)
      dup current-mark swap set
      dup car mark-cons
      cdr (loop))

    (defun mark-cons-area/defvar-record (note defvar-record -> [cons-area])
      (if dup get (int 0) eq? then drop end)
      dup get mark-cons
      cell-size add
      (loop))

    (defun mark-cons-area/argument-stack (note stack -> [cons-area])
      (if dup stack-base eq? then drop end)
      cell-size sub
      dup get mark-cons
      (loop))

    (defun mark-cons-area (note -> [cons-area])
      (if current-mark max-mark eq? then
          sweep-cons-area
          (int 0) (var current-mark) set)
      current-mark (int 1) add (var current-mark) set
      defvar-record mark-cons-area/defvar-record
      stack-pointer
      mark-cons-area/argument-stack)
    #+end_src

*** cons

    - cons
      | mark |
      | car  |
      | cdr  |

    #+begin_src jojo
    (defun new/cons (note -> cons)
      (if cons-pointer cons-area-top eq? then
          mark-cons-area
          cons-pointer/init
          cons-pointer/next-free
          (if cons-pointer cons-area-top eq? then
              (string "fatal error : cons-area is full") string/print
              newline bye)
          (loop))
      (if cons-pointer get current-mark eq? then
          cons-pointer/next (loop))
      cons-pointer
      cons-pointer/next end)

    (defun set-car (note cell cons ->)
      cell-size add
      set)

    (defun set-cdr (note cell cons ->)
      cell-size add
      cell-size add
      set)

    (defun car (note cons -> cell)
      cell-size add
      get)

    (defun cdr (note cons -> cell)
      cell-size add
      cell-size add
      get)

    (defun cons (note cdr-cell car-cell -> cons)
      new/cons
      tuck set-car
      tuck set-cdr)
    #+end_src

*** test

    #+begin_src jojo
    (note the following tests are for small cons-area)

    (note (test (int 0)
                (int 1) cons
                (int 2) cons
                dup car dot
                dup cdr car dot
                dup cdr cdr dot

                dup cons? dot
                dup cdr cons? dot
                dup car cons? dot
                dup cdr car cons? dot
                dup cdr cdr cons? dot
                dot

                current-mark
                dot))

    (note (test newline
                new/cons dot
                new/cons dot
                new/cons dot
                new/cons dot
                new/cons dot
                current-mark dot
                newline
                cons-area/report
                newline))
    #+end_src

*** list

    #+begin_src jojo
    (note (list <tail> ... <head>))

    (defun list/one (note jo [io] -> [compile])
      (if dup round-bar eq? then drop read/jo jo/apply end)
      (jo instruction/lit) here here end)

    (defun list/help (note [io] -> [compile])
      read/jo
      (if dup round-ket eq? then drop end)
      list/one
      (jo cons) here
      (loop))

    (defmacro list
      (note (list a (list b c) d)
            =>
            null
            (jo a) cons
            null
            (jo b) cons
            (jo c) cons
            cons
            (jo d) cons)
      (jo null) here
      list/help)
    #+end_src

*** test

    #+begin_src jojo
    (run (list a) dot)

    (run (list a (list b c) d)
         dup car jo->string string/print
         dup cdr car car jo->string string/print
         dup cdr car cdr car jo->string string/print
         dup cdr car cdr cdr jo->string string/print
         dup cdr cdr car jo->string string/print
         dup cdr cdr cdr jo->string string/print
         drop)

    (test (list (int 1) (list (int 2) (do (int 1 2) add)) (int 4))
          dup car dot
          dup cdr car car dot
          dup cdr car cdr car dot
          dup cdr car cdr cdr dot
          dup cdr cdr car dot
          dup cdr cdr cdr dot
          drop)
    #+end_src

*** list/length

    #+begin_src jojo
    (defun list/length (note list -> nat)
      (if dup cons? not then drop (int 0) end)
      (else cdr (recur) (int 1) add end))
    #+end_src

*** test

    #+begin_src jojo
    (test newline
          (list (list a (list b c) d)) list/length dot
          newline
          (list) list/length dot)
    #+end_src

*** list/print

    #+begin_src jojo
    (declare (list/print (note cons -> [io])))

    (defun list/print/rest (note cons -> [io])
      (if dup null eq? then drop end)
      dup cdr list/print/rest
      car
      (if dup cons? then list/print end)
      (else dot end))

    (defun list/print (note cons -> [io])
      (string "( list ") string/print
      list/print/rest
      (string ") ") string/print)
    #+end_src

*** test

    #+begin_src jojo
    (test (list (int 1) (list (int 2) (do (int 1 2) add)) (int 4))
          list/print)

    (test (list a (list b c) d)
          list/print)
    #+end_src

*** jo/map & jo/itr

    #+begin_src jojo
    (defun jo/map (note [... a] (a -> b) -> [... b])
      (if over null eq? then drop end)
      over car over jo/apply
      (int 2 1) xy-swap
      swap cdr swap (recur)
      swap cons)

    (defun jo/itr (note [... a] (a ->) ->)
      (if over null eq? then drop drop end)
      over car over jo/apply
      swap cdr swap (loop))
    #+end_src

*** test

    #+begin_src jojo
    (defun add1 (note int -> int)
      (int 1) add)

    (test (int 1)
          (jo add1) jo/apply
          dot)

    (test (int 1) (int 2) (int 3) (int 4)
          (int 2 1) xy-swap dot dot dot dot)

    (test (list (int 1) (int 2) (int 3) (int 4))
          (jo add1) jo/map
          list/print)

    (test (list (int 1) (int 2) (int 3) (int 4))
          (jo dot) jo/itr)
    #+end_src

*** map

    #+begin_src jojo
    (defun map (note [... a] (a -> b) -> [... b])
      (if over null eq? then drop end)
      over car over apply
      (int 2 1) xy-swap
      swap cdr swap (recur)
      swap cons)

    (defun itr (note [... a] (a ->) ->)
      (if over null eq? then drop drop end)
      over car over apply
      swap cdr swap (loop))
    #+end_src

*** test

    #+begin_src jojo
    (test (list (int 1) (int 2) (int 3) (int 4))
          (jojo (int 1) add) map
          (jojo (int 1) add) map
          (jojo (int 1) add) map
          (jojo (int 1) add) map
          (jojo (int 1) add) map
          list/print)

    (test (list (int 1) (int 2) (int 3) (int 4))
          (jojo dup dot dot) itr)
    #+end_src

*** list/ref

    #+begin_src jojo
    (defun list/ref (note [... a] int -> a)
      (if dup (int 0) lteq? then drop car end)
      (else swap cdr swap (int 1) sub (loop)))
    #+end_src

*** test

    #+begin_src jojo
    (test (list (int 1) (int 2) (int 3) (int 4))
          (int 1) list/ref dot)
    #+end_src

*** list/drop

    #+begin_src jojo
    (defun list/drop (note [... a] nat -> [... a])
      (if dup (int 0) lteq? then drop end)
      (else swap cdr swap (int 1) sub (loop)))
    #+end_src

*** list/take

    #+begin_src jojo
    (defun list/take (note [... a] nat -> [... a])
      (if dup (int 0) lteq? then drop null end)
      (else over car (int 2 1) xy-swap
            swap cdr swap (int 1) sub (recur)
            swap cons end))
    #+end_src

* object

*** note

    #+begin_src jojo
    (note class is also an object
          we can send new to it)

    (note under <class-name> we have
          method-record
          [method-record alone for now])

    (note object = <class-name> <data> cons)

    (note when defining a class
          different interface-generator can be used to generate method list
          for example
          inherit
          low level array like data with free
          - free must free everything
          high level list list data using gc)

    (note when using defmethod
          a function can assuming certain named local points
          such as self)
    #+end_src

*** class

    #+begin_src jojo
    (defun empty-class
      (list))
    #+end_src

*** defmethod

    #+begin_src jojo
    (defun new/method (note method/body method/name -> method) cons)
    (defun method/name car)
    (defun method/body cdr)

    (defmacro defmethod
      (note (defmethod <class-name> <method-name> ...)
            =>
            (jojo ...) (jo <method-name>) new/method
            <class-name> swap cons
            (var <class-name>) set)

      read/jo (>> class-name)
      read/jo (>> method-name)

      address-of-here (>> jojo)
      compile-jojo
      (jo end) here

      (<< class-name) jo-as-var get
      (<< jojo) (<< method-name) new/method
      cons

      (<< class-name) jo-as-var set)
    #+end_src

*** send

    #+begin_src jojo
    (defun object/class-name cdr)
    (defun object/data car)
    (defun object/method-record object/class-name jo/apply)

    (defun method-record/search
      (note message method-record -> (or method false))
      (if dup null eq? then
          drop drop false end)
      (if over over car method/name eq? then
          swap drop car method/body end)
      cdr (loop))

    (defun send
      (note object message -> [depends on object and message])
      (>> message)
      (>> object)
      (<< message)
      (<< object)
      object/method-record
      method-record/search
      (if dup false eq? not then
          (<< object) (jo self) apply-with-local-binding end)
      (string "can not find message : ") string/print
      (<< message) jo/print newline
      (string "object/class-name : ") string/print
      (<< object) object/class-name jo/print newline)

    (defmacro ::
      (note (:: message ...)
            =>
            (>> object) (jojo ...) apply
            (<< object) (jo message) send)

      read/jo (>> message)
      generate-jo (>> object-jo)

      (jo instruction/lit) here
      (<< object-jo) here
      (jo local-in) here

      jojo (jo apply) here

      (jo instruction/lit) here
      (<< object-jo) here
      (jo local-out) here

      (jo instruction/lit) here
      (<< message) here
      (jo send) here)
    #+end_src

*** test

    #+begin_src jojo
    (defvar person empty-class)

    (defun new/person
      (jo person) (int 13) cons)

    (defmethod person print-age
      (<< self) car dot)

    (run
      new/person (:: print-age))
    #+end_src

* file

*** note

    - to use oo

* module

*** note

    #+begin_src jojo
    (note
      (module <module-name> function ...)
      (dep <module-name>)
      (include <path>)
      (clib <path>))
    #+end_src
