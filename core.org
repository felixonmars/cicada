#+property: tangle core.jo
#+title: core

* [todo-stack]

*** semantic of quote and quasiquote

    - quote must be consisted with the sexp reader

    - also consisted with sexp-write

*** quasiquote

    - `({})

    - `(@{})

*** [maybe] 'and' and 'or' should be implemented as macro

*** comma is special jo

*** about monad

    - learn more about monad by
      1. inline monads
      2. uncurry functions

*** test

    - use EOPL to test the language

*** dynamic scope

    - a closure's dynamic scoped local
      can be viewed as is named arugments

    - function with effect on tos of global stack
      can be replaced by dynamic scoped local

*** pp -- pretty-print

    - 'write' as gene

    - dynamic scoped local for current indentation

*** better syntax check

    - (+gene) and (+disp)

*** about closure

    - to catch unnamed data into returned closure

*** module system

    - only use "~/.jojo"
      to make the behaviour of module system simple

    - move socket to module

    - improve socket API

* flag

  #+begin_src jojo
  (run core-flag-on)
  #+end_src

* list

*** <null> <cons>

    #+begin_src jojo
    (+data <null>)
    (+data <cons> .car .cdr)
    #+end_src

*** list-length

    #+begin_src jojo
    (+jojo list-length (-> :list -> <int>)
      (case :list
        <null> 0
        <cons> [:list .cdr recur inc]))
    #+end_src

*** list-member?

    #+begin_src jojo
    (+jojo list-member? (-> :a :list -- <bool>)
      (case :list
        <null> false
        <cons> [(if :a :list .car eq? then true end)
                :a :list .cdr recur]))
    #+end_src

*** list-append

    #+begin_src jojo
    (+jojo list-append (-> :left :right -> list)
      (case :left
        <null> [:right]
        <cons> [:left .cdr :right recur
                :left .car swap cons]))
    #+end_src

*** tail-cons

    #+begin_src jojo
    (+jojo tail-cons null cons list-append)
    #+end_src

*** list-left

    #+begin_src jojo
    (+jojo list-left (-> :list :pred -- left)
      (cond [:list null?] [null]
            [:list .car :pred apply] [null]
            else [:list .car
                  :list .cdr :pred recur
                  cons]))
    #+end_src

*** list-right

    #+begin_src jojo
    (+jojo list-right (-> :list :pred -- right)
      (cond [:list null?] [null]
            [:list .car :pred apply] [:list]
            else [:list .cdr :pred recur]))
    #+end_src

*** list-split

    #+begin_src jojo
    (+jojo list-split (-> :list :pred -- left right)
      (cond [:list null?] [null null]
            [:list .car :pred apply] [null :list]
            else [:list .car
                  :list .cdr :pred recur
                  :right! cons :right]))
    #+end_src

*** list-map

    #+begin_src jojo
    (+jojo list-map (-> :list :fun -- list)
      (case :list
        <null> null
        <cons> [:list .car :fun apply :list .cdr :fun recur cons]))
    #+end_src

*** list-for-each

    #+begin_src jojo
    (+jojo list-for-each (-> :list :fun --)
      (case :list
        <null> []
        <cons> [:list .car :fun apply :list .cdr :fun recur]))
    #+end_src

*** list-filter

    #+begin_src jojo
    (+jojo list-filter (-> :list :pred -- list)
      (cond [:list null?] [null]
            [:list .car :pred apply] [:list .car :list .cdr :pred recur cons]
            else [:list .cdr :pred recur]))
    #+end_src

*** list-reverse

    #+begin_src jojo
    (+jojo list-reverse null swap list-reverse-swap-append)

    (+jojo list-reverse-swap-append (-> left :list -- list)
      (case :list
        <null> []
        <cons> [:list .car swap cons :list .cdr recur]))
    #+end_src

*** list-write

    #+begin_src jojo
    (+jojo list-write (-> :list :printer --)
      (case :list
        <null> []
        <cons> [:list .car :printer apply
                :list .cdr :printer recur]))
    #+end_src

*** [test]

    #+begin_src jojo
    (+jojo int-list-write
      {int-write space} list-write newline)

    (run
      0 1 2 3 4 null
      cons cons cons cons cons

      5 6 7 8 9 null
      cons cons cons cons cons

      list-append
      int-list-write newline)

    (run
      0 1 2 3 4 5 6 7 8 9 null
      cons cons cons cons cons
      cons cons cons cons cons

      {5 gt?} list-left
      int-list-write newline)

    (run
      0 1 2 3 4 5 6 7 8 9 null
      cons cons cons cons cons
      cons cons cons cons cons

      {5 gteq?} list-split
      int-list-write int-list-write newline)

    (run
      0 1 2 3 4 5 6 7 8 9 null
      cons cons cons cons cons
      cons cons cons cons cons

      {inc inc inc} list-map int-list-write newline)

    (run
      0 1 2 3 4 5 6 7 8 9 null
      cons cons cons cons cons
      cons cons cons cons cons

      {2 mod 0 eq?} list-filter int-list-write newline)

    (run
      0 1 2 3 4 5 6 7 8 9 null
      cons cons cons cons cons
      cons cons cons cons cons

      list-reverse int-list-write newline)
    #+end_src

* sexp

*** [note] sexp

    #+begin_src jojo
    (note atom of sexp can only be <string> and <jo>)
    (note sexp
      = <cons> -- sexp list
      | <string>
      | <jo>)
    #+end_src

*** read-sexp

    #+begin_src jojo
    (+jojo read-sexp (-> -- sexp)
      read-jo :jo!
      (cond [:jo round-bar eq?] [round-ket read-sexp/list]
            [:jo square-bar eq?] [square-ket read-sexp/list 'vec swap cons]
            [:jo flower-bar eq?] [flower-ket read-sexp/list 'clo swap cons]
            [:jo doublequote eq?] [read-string]
            else [:jo]))

    (+jojo read-sexp/list (-> :ket <jo> -- sexp list)
      read-jo :jo!
      (if :jo :ket eq?
          then null
          else :jo jo-unread read-sexp, :ket recur, cons))
    #+end_src

*** sexp-write

    #+begin_src jojo
    (+jojo sexp-write (-> :sexp --)
      (case :sexp
        <cons> [round-bar jo-write :sexp sexp-list-write
                round-ket jo-write]
        <string> [doublequote jo-write :sexp string-write
                  doublequote jo-write]
        <jo> [:sexp jo-write]))

    (+jojo sexp-list-write (-> :list sexp list --)
      (cond
        [:list null?] []
        [:list .cdr null?] [:list .car sexp-write]
        else [:list .car sexp-write space
              :list .cdr recur]))
    #+end_src

* syntax

*** repl

    #+begin_src jojo
    (+jojo repl (-> :input-stack --)
      :input-stack reading-stack-push
      repl/loop
      reading-stack-drop)

    (+jojo repl/loop
      (if has-jo? not then end)
      read-jo :jo!
      (if :jo round-bar eq? then
          read-jo
          round-bar jo-unread read-sexp
          (note (-> sexp list -- [compiling-stack]))
          swap jo-apply)
      (if repl-flag then print-data-stack)
      recur)
    #+end_src

*** compile-jojo

    #+begin_src jojo
    (+jojo compile-jojo (-> sexp list -- <jojo>)
      compiling-stack-tos
      swap sexp-list-compile
      emit-jojo-end
      ' <jojo> tag-change)
    #+end_src

*** sexp-list-compile

    #+begin_src jojo
    (+jojo sexp-list-compile (-> :list sexp list --)
      (cond
        [:list null?] [end]

        [:list .car ' ' eq?]
        [:list .cdr .car emit-lit
         :list .cdr .cdr recur]

        else [:list .car sexp-compile
              :list .cdr recur]))
    #+end_src

*** sexp-compile

    #+begin_src jojo
    (+jojo sexp-compile (-> :sexp --)
      (cond
        [:sexp cons?] [:sexp .cdr :sexp .car jo-apply]
        [:sexp string?] [:sexp emit-lit]
        [:sexp jo?] [:sexp jo-compile]))
    #+end_src

*** jo-compile

    #+begin_src jojo
    (+jojo jo-compile (-> :jo --)
      (cond [:jo int-jo?]       [:jo jo->int emit-lit]
            [:jo get-local-jo?] [:jo jo-emit-get-local]
            [:jo set-local-jo?] [:jo jo-emit-set-local]
            [:jo get-field-jo?] [:jo jo-emit-get-field]
            [:jo set-field-jo?] [:jo jo-emit-set-field]
            else [:jo jo-emit]))
    #+end_src

*** (if)

    #+begin_src jojo
    (+jojo if-else-then (-> :body --)
      :body {'then eq?} list-split (-> :question :then-else)
      :then-else {'else eq?} list-split (-> :then :else)
      :question sexp-list-compile
      emit-jz :jz-address!
      :then .cdr sexp-list-compile
      emit-jmp :jmp-address!
      :jz-address set-offset-to-here
      :else .cdr sexp-list-compile
      :jmp-address set-offset-to-here)

    (+jojo if-then (-> :body --)
      :body {'then eq?} list-split (-> :question :then)
      :question sexp-list-compile
      emit-jz :jz-address!
      :then .cdr sexp-list-compile
      :jz-address set-offset-to-here)

    (+jojo core-if (-> :body --)
      (cond
        ['else :body list-member?
         'then :body list-member? and]
        [:body if-else-then]

        ['then :body list-member?] [:body if-then]

        else ["- if fail" string-write newline
              "  the body dose not has 'then" string-write newline
              "  body : " string-write :body sexp-list-write newline
              debug]))
    #+end_src

*** maybe-vec->list

    #+begin_src jojo
    (+jojo maybe-vec->list (-> :maybe -- list)
      (cond
        [:maybe cons? not] [:maybe null cons]
        [:maybe .car 'vec eq?] [:maybe .cdr]
        else [:maybe null cons]))
    #+end_src

*** (cond)

    #+begin_src jojo
    (+jojo cond/expend (-> :body -- sexp)
      (cond
        [:body list-length 2 eq?]
        [:body .car :body .cdr .car cond/if-then]

        else [:body .car :body .cdr .car cond/if-then
              'else tail-cons
              :body .cdr .cdr recur tail-cons]))

    (note
      (+jojo cond/if-then (-> :question :answer -- sexp)
        `(if @{(if :question 'else eq?
                   then '(true)
                   else :question maybe-vec->list)}
             then @{:answer maybe-vec->list})))

    (+jojo cond/if-then (-> :question :answer -- sexp)
      (if :question 'else eq?
          then 'true null cons
          else :question maybe-vec->list)
      'then tail-cons
      :answer maybe-vec->list list-append
      'if swap cons)
    #+end_src

*** (case)

    #+begin_src jojo
    (note
      (+jojo case/expend (-> :body -- sexp)
        `(begin @{:body .car maybe-vec->list}
                {:body .cdr case/expend-rest})))

    (+jojo case/expend (-> :body -- sexp)
      :body .car maybe-vec->list
      :body .cdr case/expend-rest tail-cons
      'begin swap cons)

    (+jojo case/expend-rest (-> :body -- sexp)
      (cond
        [:body list-length 2 eq?]
        [:body .car :body .cdr .car case/if-then]

        else [:body .car :body .cdr .car case/if-then
              'else tail-cons
              :body .cdr .cdr recur tail-cons]))

    (note
      (+jojo case/if-then (-> :tag :answer -- sexp)
        `(if @{(if :tag 'else eq?
                   then '(true)
                   else `(dup tag ' {:tag} eq?))}
             then drop @{:answer maybe-vec->list})))

    (+jojo case/if-then (-> :tag :answer -- sexp)
      (if :tag 'else eq?
          then 'true null cons
          else 'dup 'tag '' :tag 'eq? null cons cons cons cons cons)
      'then tail-cons
      'drop tail-cons
      :answer maybe-vec->list list-append
      'if swap cons)
    #+end_src

*** (->)

    #+begin_src jojo
    (+jojo arrow/expend (-> :body -- sexp)
      :body {'-- eq?} list-left
      {get-local-jo?} list-filter
      {get-local-jo->set-local-jo} list-map
      list-reverse
      'begin swap cons)
    #+end_src

*** compile-jojo-copy

    #+begin_src jojo
    (+jojo compile-jojo-copy (-> sexp list -- <jojo>)
      compiling-stack-tos :address!
      compile-jojo jojo-copy
      compiling-stack-drop
      :address compiling-stack-push)
    #+end_src

*** (clo)

    #+begin_src jojo
    (+jojo core-clo
      compile-jojo-copy emit-lit
      'current-local-env jo-emit
      'closure jo-emit)
    #+end_src

*** (+data)

    #+begin_src jojo
    (+jojo plus-data (-> :body --)
      (if :body .car tag-jo? not then
          "- plus-data fail" string-write newline
          "  name must be of form <...>" string-write newline
          "  body : " string-write :body sexp-list-write newline
          end)
      compiling-stack-tos :address!
      :body .cdr
      {get-field-jo?} list-filter
      {jo-emit} list-for-each
      emit-zero
      :address :body .car name-bind-data)
    #+end_src

*** (+gene)

    #+begin_src jojo
    (+jojo plus-gene (-> :body --)
      :body .cdr .car :arrow-sexp!
      :arrow-sexp .cdr
      {'-- eq?} list-left
      {get-local-jo?} list-filter
      list-length
      :body .car name-bind-gene)
    #+end_src

*** (+disp)

    - this syntax always use <jojo> as disp

    #+begin_src jojo
    (+jojo plus-disp (-> :body --)
      :body .cdr .car :arrow-sexp!
      :body .cdr :rest-body!

      :arrow-sexp .cdr
      {'-- eq?} list-left
      {tag-jo?} list-filter
      compiling-stack-tos :tag-array-address!
      {jo-emit} list-for-each
      emit-zero

      :rest-body compile-jojo-copy
      :tag-array-address
      :body .car
      name-bind-disp-to-jojo)
    #+end_src

*** >< (test)

*** >< (let)

*** >< (let-bind) -- moand interface

    #+begin_src jojo
    (note
      (+jojo zip-tree :t1! :t2!
        (note [tree tree] -> [maybe-tree])
        (cond [:t1 leaf? :t2 leaf? and]
              [:t1 .v :t2 .v cons leaf return-maybe]
              [:t1 node? :t2 node? and]
              (let-bind bind-maybe
                :l [:t1 .l :t2 .l zip-tree]
                :r [:t1 .r :t2 .r zip-tree]
                [:l :r node return-maybe])
              else nothing)))
    #+end_src

*** (+jojo) & run new repl

    #+begin_src jojo
    (+jojo +jojo (-> :body sexp list --)
      :body .cdr compile-jojo
      :body .car name-bind)

    (run reading-stack-tos repl)
    #+end_src

*** new keywords

    #+begin_src jojo
    (+jojo note drop)
    (+jojo run compile-jojo apply)
    (+jojo begin sexp-list-compile)
    (+jojo if core-if)
    (+jojo cond cond/expend sexp-compile)
    (+jojo case case/expend sexp-compile)
    (+jojo -> arrow/expend sexp-compile)
    (+jojo clo core-clo)
    (+jojo echo sexp-list-write newline)
    (+jojo +data plus-data)
    (+jojo +gene plus-gene)
    (+jojo +disp plus-disp)
    #+end_src

* [test]

  #+begin_src jojo
  (+jojo square dup mul)

  (run 123 square int-write newline)

  (run 1 :x!
    (if :x 1 eq?
        then "is 1" string-write newline
        else "not 1" string-write newline))

  (run 3 :x!
    (cond
      [:x 1 eq?] ["is 1" string-write newline]
      [:x 2 eq?] ["is 2" string-write newline]
      else ["not 1 not 2" string-write newline]))

  (+jojo list-length-2
    :list!
    (case :list
      <null> 0
      <cons> [:list .cdr recur inc]))

  (run 1 2 3 4 5 null cons cons cons cons cons list-length-2 int-write newline)

  (run
    1 2 (-> :x :y --)
    :y :y add int-write space
    :y :y add int-write space
    :x :x add int-write space newline)

  (+jojo com :m1! :m2!
    {:m2 apply
     :m1 apply})
  (run {1} {2} com apply add int-write newline)
  (run {1} {2} com {3} com apply add add int-write newline)
  (run {1} {2} {3} com com apply add add int-write newline)

  (run
    (echo 1 2 3)
    (echo (run
            1 2 (-> :x :y --)
            :y :y add int-write space
            :y :y add int-write space
            :x :x add int-write space newline)))

  (+jojo nl newline)

  (+gene w (-> :x --))
  (+disp w (-> <int> --) int-write)
  (+disp w (-> <string> --) string-write)
  (run
    1 w space "one" w nl)

  (+gene ww (-> :a :b --))
  (+disp ww (-> <int> <int> --) swap int-write space int-write)
  (+disp ww (-> <int> <string> --) swap int-write space string-write)
  (run 1 2 ww nl)
  (run 1 "two" ww nl)
  (note (run "two" 1 ww nl))
  #+end_src

* >< the-story-begin

  #+begin_src jojo
  (+jojo the-story-begin
    repl-flag-on terminal-input-stack repl)
  (run the-story-begin)
  #+end_src
