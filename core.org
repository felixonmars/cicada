#+property: tangle core.jo
#+title: core

* [todo-stack]

*** fix repl

    - before call a repl one has to push an input_stack to reading_stack

      after the input_stack is empty
      the repl returns

      one has to drop reading_stack
      and close input_stack

      thus, the input_stack shoud be an argument of the repl

    - x -
      this might be not a good way to use the repl

      maybe repl should only be used for terminal

      we can redirect reader
      but we should not use repl to do that

      [meaningful distinctions deserve to be maintained.]

      for example, when reading from file
      we have information about position

    - k -
      since we are passing input_stack as an argument to repl
      we already can make distinction in the function body of repl
      maybe the problem is calling repl in repl
      an wish the second repl to use the input_stack of the first repl

    - x -
      we can share input_stack between them
      and later, loading a file not by repl

*** ready to re-define keywords

*** (->)

*** quote as in jexp

*** (case) to handle multi-value

*** (let)

*** (let-bind) -- moand interface

    - (let-bind) or (do) ?
      #+begin_src jojo
      (note
        (+jojo zip-tree :t1! :t2!
          (note [tree tree] -> [maybe-tree])
          (cond [:t1 leaf? :t2 leaf? and]
                [:t1 .v :t2 .v cons leaf return-maybe]
                [:t1 node? :t2 node? and]
                (let-bind bind-maybe
                  :l {:t1 .l :t2 .l zip-tree}
                  :r {:t1 .r :t2 .r zip-tree}
                  {:l :r node return-maybe})
                else nothing)))
      #+end_src

*** about monad

    - learn more about monad by
      1. inline monads
      2. uncurry functions

*** about closure

    - and test closure by more examples
      such as 'counter'

*** dynamic scope

    - 一個 dynamic scope 的 block
      其 dynamic free variable 可以被看成是 有名參數

*** to use dynamic scope

    - function with effect on tos of global stack
      can be replaced by dynamic scoped variable in function ?

*** about closure

    - to catch unnamed data into returned closure

*** test

    - use EOPL to test the language

*** module system

    - only use "~/.jojo"
      to make the behaviour of module system simple
    - move socket to module
    - improve socket API

* [note] syntax

*** the reader

    - what macro get
      is equivalent to '(...)
      (keyword ...)
      ['(...) keyword]

    - keyword v.s. macro ?
      only keyword no macro ?
      thus, no macro expend

*** literal

    | "..." | <string> |
    | 123   | <int>    |
    | 'jo   | <jo>     |

*** bar-ket

    | () | syntax    | '() | <cons> |
    | [] | <vector>  | '[] | <vons> |
    | {} | <closure> | '{} | <fons> |

* flag

  #+begin_src jojo
  (run core-flag-on)
  #+end_src

* jexp

*** [note]

    - jexp
      #+begin_src jojo
      (note jexp
        = jexp <cons>
        | jexp <vons>
        | jexp <fons>
        | <string>
        | <jo>)
      #+end_src

    - bar-ket
      | () | syntax    | '() | <cons> |
      | [] | <vector>  | '[] | <vons> |
      | {} | <closure> | '{} | <fons> |

*** jexp

    #+begin_src jojo
    (+data <null>)
    (+data <cons> .car .cdr)
    (+data <vons> .var .vdr)
    (+data <fons> .far .fdr)
    #+end_src

*** read-jexp

    - atom of jexp can only be <string> and <jo>

    #+begin_src jojo
    (+jojo read-jexp (-> -- jexp)
      read-jo :jo!
      (cond [:jo round-bar eq?]  [read-jexp/cons]
            [:jo square-bar eq?] [read-jexp/vons]
            [:jo flower-bar eq?] [read-jexp/fons]
            [:jo double-quote eq?] [read-string]
            else [:jo]))

    (+jojo read-jexp/cons
      read-jo :jo!
      (if :jo round-ket eq?
          then null
          else :jo jo-unread read-jexp recur cons))

    (+jojo read-jexp/vons
      read-jo :jo!
      (if :jo round-ket eq?
          then null
          else :jo jo-unread read-jexp recur vons))

    (+jojo read-jexp/fons
      read-jo :jo!
      (if :jo round-ket eq?
          then null
          else :jo jo-unread read-jexp recur fons))
    #+end_src

*** jexp-write

    #+begin_src jojo
    (+jojo jexp-write (-> :jexp --)
      (case :jexp
        <cons> [round-bar  jo-write space :jexp jexp-write/cons]
        <vons> [square-bar jo-write space :jexp jexp-write/vons]
        <fons> [flower-bar jo-write space :jexp jexp-write/fons]
        <string> [double-quote jo-write
                  :jexp string-write
                  double-quote jo-write
                  space]
        <jo> [:jexp jo-write space]))

    (+jojo jexp-write/cons (-> :l --)
      (case :l
        <null> [round-ket jo-write space]
        <cons> [:l .car jexp-write
                :l .cdr recur]))

    (+jojo jexp-write/vons (-> :l --)
      (case :l
        <null> [square-bar jo-write space]
        <cons> [:l .car jexp-write
                :l .cdr recur]))

    (+jojo jexp-write/fons (-> :l --)
      (case :l
        <null> [flower-bar jo-write space]
        <cons> [:l .car jexp-write
                :l .cdr recur]))
    #+end_src

*** repl

    #+begin_src jojo
    (+jojo repl (-> :input-stack --)
      :input-stack reading-stack-push
      repl/loop
      reading-stack-drop)

    (+jojo repl/loop
      (if has-jo? not then end)
      read-jo :jo!
      (if :jo round-bar eq? then
          read-jo
          round-bar jo-unread read-jexp
          swap jo-apply)
      recur)
    #+end_src

*** >< compile-jojo

    #+begin_src jojo
    (+jojo compile-jojo (-> jexp <cons> -- <jojo>)
      new-jojo-from-compiling-stack-tos
      swap compile-jojo/help)

    (+jojo compile-jojo/jo (-> :jo --)
      (cond
        [:jo int-jo?]       [:jo jo->int emit-lit]
        [:jo get-local-jo?] [:jo jo-emit-get-local]
        [:jo set-local-jo?] [:jo jo-emit-set-local]
        [:jo get-field-jo?] [:jo jo-emit-get-field]
        [:jo set-field-jo?] [:jo jo-emit-set-field]
        else [:jo jo-emit-call]))

    (+jojo compile-jojo/help (-> :l jexp <cons> --)
      (if :l null? then
          'end jo-emit-call
          0 int-emit-data
          0 int-emit-data
          end)
      :l .car :jexp!
      (cond [:jexp cons?] [:jexp .cdr :jexp .car jo-apply]
            [:jexp vons?] []
            [:jexp fons?] []
            [:jexp string?] [:jexp emit-lit]
            [:jexp jo?] [:jexp compile-jojo/jo])
      :l .cdr recur)
    #+end_src

*** (+jojo)

    #+begin_src jojo
    (+jojo +jojo (-> :l --)
      :l .car   dup jo-write newline
      :l .cdr   dup jexp-write newline
      compile-jojo
      bind-name)
    (run reading-stack-tos repl)
    #+end_src

*** (run)

    #+begin_src jojo
    (+jojo run
      dup jexp-write newline
      compile-jojo apply)
    #+end_src

*** (note)

    #+begin_src jojo
    (+jojo note)
    #+end_src

*** >< the-story-begin

    #+begin_src jojo
    (+jojo square dup mul)
    (run 123 square int-write newline)
    #+end_src
