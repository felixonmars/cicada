#+property: tangle core.jo
#+title: core

* [todo-stack]

*** semantic of quote

    - quote must be consisted with the jexp reader

    - {} can be changed to (closure)
    - but how about [] ?
    - give up the quotation of list ?

*** zero follows 'end' means then end of jojo

*** (let)

*** (let-bind) -- moand interface

    - (let-bind) or (do) ?
      #+begin_src jojo
      (note
        (+jojo zip-tree :t1! :t2!
          (note [tree tree] -> [maybe-tree])
          (cond [:t1 leaf? :t2 leaf? and]
                [:t1 .v :t2 .v cons leaf return-maybe]
                [:t1 node? :t2 node? and]
                (let-bind bind-maybe
                  :l [:t1 .l :t2 .l zip-tree]
                  :r [:t1 .r :t2 .r zip-tree]
                  [:l :r node return-maybe])
                else nothing)))
      #+end_src

*** quote comma are special jo

*** about monad

    - learn more about monad by
      1. inline monads
      2. uncurry functions

*** test

    - use EOPL to test the language

*** dynamic scope

    - a closure's dynamic scoped free variables
      can be viewed as is named arugments

    - function with effect on tos of global stack
      can be replaced by dynamic scoped variable in function ?

*** about closure

    - to catch unnamed data into returned closure

*** module system

    - only use "~/.jojo"
      to make the behaviour of module system simple
    - move socket to module
    - improve socket API

* [note]

*** bar-ket

    - () -- macro
      [] -- only as arguments of macro [not even used as vector]
      {} -- <closure>

* flag

  #+begin_src jojo
  (run core-flag-on)
  #+end_src

* list

*** <null> <cons>

    #+begin_src jojo
    (+data <null>)
    (+data <cons> .car .cdr)
    #+end_src

*** list-member?

    #+begin_src jojo
    (+jojo list-member? (-> :a :list -- <bool>)
      (case :list
        <null> false
        <cons> [(if :a :list .car eq? then true end)
                :a :list .cdr recur]))
    #+end_src

*** list-append

    #+begin_src jojo
    (+jojo list-append (-> :left :right -> list)
      (case :left
        <null> [:right]
        <cons> [:left .cdr :right recur
                :left .car swap cons]))
    #+end_src

*** list-left

    #+begin_src jojo
    (+jojo list-left (-> :list :pred -- left)
      (cond [:list null?] [null]
            [:list .car :pred apply] [null]
            else [:list .car
                  :list .cdr :pred recur
                  cons]))
    #+end_src

*** list-right

    #+begin_src jojo
    (+jojo list-right (-> :list :pred -- right)
      (cond [:list null?] [null]
            [:list .car :pred apply] [:list]
            else [:list .cdr :pred recur]))
    #+end_src

*** list-split

    #+begin_src jojo
    (+jojo list-split (-> :list :pred -- left right)
      (cond [:list null?] [null null]
            [:list .car :pred apply] [null :list]
            else [:list .car
                  :list .cdr :pred recur
                  :right! cons :right]))
    #+end_src

*** [test]

    #+begin_src jojo
    (+jojo int-list-write
      "'" string-write
      round-bar jo-write space
      int-list-write/loop
      round-ket jo-write space)

    (+jojo int-list-write/loop (-> :list --)
      (case :list
        <null> [space]
        <cons> [:list .car int-write space
                :list .cdr recur]))

    (run
      0 1 2 3 4 null
      cons cons cons cons cons

      5 6 7 8 9 null
      cons cons cons cons cons

      list-append
      int-list-write newline)

    (run
      0 1 2 3 4 5 6 7 8 9 null
      cons cons cons cons cons
      cons cons cons cons cons

      {5 gt?} list-left
      int-list-write newline)

    (run
      0 1 2 3 4 5 6 7 8 9 null
      cons cons cons cons cons
      cons cons cons cons cons

      {5 gteq?} list-split
      int-list-write int-list-write newline)
    #+end_src

* jexp

*** [note] jexp

    #+begin_src jojo
    (note atom of jexp can only be <string> and <jo>)
    (note jexp
      = jexp list
      | <square-bar-ket>
      | <flower-bar-ket>
      | <string>
      | <jo>)

    (+data <square-bar-ket> .list)
    (+data <flower-bar-ket> .list)
    #+end_src

*** read-jexp

    #+begin_src jojo
    (+jojo read-jexp (-> -- jexp)
      read-jo :jo!
      (cond [:jo round-bar eq?] [round-ket read-jexp/list]
            [:jo square-bar eq?] [square-ket read-jexp/list square-bar-ket]
            [:jo flower-bar eq?] [flower-ket read-jexp/list flower-bar-ket]
            [:jo double-quote eq?] [read-string]
            else [:jo]))

    (+jojo read-jexp/list (-> :ket <jo> -- jexp list)
      read-jo :jo!
      (if :jo :ket eq?
          then null
          else :jo jo-unread read-jexp, :ket recur, cons))
    #+end_src

*** jexp-write

    #+begin_src jojo
    (+jojo jexp-write (-> :jexp --)
      (case :jexp
        <cons>  [round-bar jo-write space
                 :jexp jexp-list-write
                 round-ket jo-write space]
        <square-bar-ket> [square-bar jo-write space
                          :jexp .list jexp-list-write
                          square-ket jo-write space]
        <flower-bar-ket> [flower-bar jo-write space
                          :jexp .list jexp-list-write
                          flower-ket jo-write space]
        <string> [double-quote jo-write
                  :jexp string-write
                  double-quote jo-write space]
        <jo> [:jexp jo-write space]))

    (+jojo jexp-list-write (-> :list jexp list --)
      (case :list
        <null> [space]
        <cons> [:list .car jexp-write :list .cdr recur]))
    #+end_src

* syntax

*** repl

    #+begin_src jojo
    (+jojo repl (-> :input-stack --)
      :input-stack reading-stack-push
      repl/loop
      reading-stack-drop)

    (+jojo repl/loop
      (if has-jo? not then end)
      read-jo :jo!
      (if :jo round-bar eq? then
          read-jo
          round-bar jo-unread read-jexp
          (note (-> jexp list -- [compiling-stack]))
          swap jo-apply)
      (if repl-flag then print-data-stack)
      recur)
    #+end_src

*** compile-jojo

    #+begin_src jojo
    (+jojo compile-jojo (-> jexp list -- <jojo>)
      new-jojo-from-compiling-stack-tos
      swap jexp-list-compile
      quote end jo-emit-call
      0 int-emit-data
      0 int-emit-data)
    #+end_src

*** jexp-list-compile

    #+begin_src jojo
    (+jojo jexp-list-compile (-> :list jexp list --)
      (if :list null? then end)
      :list .car jexp-compile
      :list .cdr recur)
    #+end_src

*** jexp-compile

    #+begin_src jojo
    (+jojo jexp-compile (-> :jexp --)
      (cond
        [:jexp cons?]
        [:jexp .cdr dup jexp-list-write newline
         :jexp .car dup jo-write newline
         jo-apply]

        [:jexp square-bar-ket?] []

        [:jexp flower-bar-ket?] []

        [:jexp string?] [:jexp emit-lit]

        [:jexp jo?] [:jexp jo-compile]))
    #+end_src

*** jo-compile

    #+begin_src jojo
    (+jojo jo-compile (-> :jo --)
      (cond [:jo int-jo?]       [:jo jo->int emit-lit]
            [:jo get-local-jo?] [:jo jo-emit-get-local]
            [:jo set-local-jo?] [:jo jo-emit-set-local]
            [:jo get-field-jo?] [:jo jo-emit-get-field]
            [:jo set-field-jo?] [:jo jo-emit-set-field]
            else [:jo jo-emit-call]))
    #+end_src

*** >< (if)

    #+begin_src jojo
    (note

      (+jojo if-else-then
        )

      (+jojo if-then (-> :list --)
        :list {quote then eq?} list-split (-> :question :then)
        :then .cdr (-> :answer)
        ))

    (+jojo core-if (-> :list --)
      (cond
        [quote else :list list-member?
         quote then :list list-member? and]
        [:list if-else-then]

        [quote then :list list-member?] [:list if-then]

        else ["- if fail" string-write newline
              "  the body dose not has 'then" string-write newline
              "  body : " string-write :list jexp-list-write newline
              debug]))
    #+end_src


*** (+jojo)

    #+begin_src jojo
    (+jojo +jojo (-> :list jexp list --)
      :list .car,  (note dup jo-write newline)
      :list .cdr   (note dup jexp-list-write newline)
      compile-jojo,
      bind-name)
    #+end_src

*** run the new repl

    #+begin_src jojo
    (run reading-stack-tos repl)
    #+end_src

*** new keywords

    #+begin_src jojo
    (+jojo if core-if)
    #+end_src

*** >< (->)

*** >< (+var)

*** >< (+data)

*** >< (+gene)

*** >< (+disp)

*** (run)

    #+begin_src jojo
    (+jojo run compile-jojo apply)
    #+end_src

*** (note)

    #+begin_src jojo
    (+jojo note drop)
    #+end_src

*** >< (test)

*** >< (cond)

*** >< (case)

*** >< {}

* [test]

  #+begin_src jojo
  (+jojo square dup mul)
  (run 123 square int-write newline)
  #+end_src

* >< the-story-begin

  #+begin_src jojo
  (+jojo the-story-begin
    repl-flag-on terminal-input-stack repl)
  (run the-story-begin)
  #+end_src
