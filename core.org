#+html_head: <link rel="stylesheet" href="https://xieyuheng.github.io/asset/css/page.css" type="text/css" media="screen" />
#+property: tangle core.jo
#+title: core

* [todo-stack]

*** how to test io functions ?

    - with-output-to-string ?

*** little syntax check for (cond) (+gene) (+disp)

*** (case) handles multi argument [with little syntax check]

*** about monad

    - learn more about monad by
      1. inline monads
      2. uncurry functions

*** top level keywords such as (run) can not be nested

    - (run (run 1)) is not equal to
      '('(1) run) run

*** use EOPL to test the language

*** dynamic scope

    - a closure's dynamic scoped local
      can be viewed as is named arugments

    - function with effect on tos of global stack
      can be replaced by dynamic scoped local

*** pp -- pretty-print

    - 'write' as gene

    - dynamic scoped local for current indentation

*** about closure

    - to catch unnamed data into returned closure

*** module system

    - only use "~/.jojo"
      to make the behaviour of module system simple

    - move socket to module

    - improve socket API

* flag

  #+begin_src jojo
  (run
    core-flag-on
    test-flag-on
    repl-flag-off)
  #+end_src

* list

*** <null> <cons>

    #+begin_src jojo
    (+data <null>)
    (+data <cons> .car .cdr)
    #+end_src

*** list?

    #+begin_src jojo
    (+jojo list? (-> :x -- <bool>)
      (case :x
        <null> true
        <cons> true
        else false))
    #+end_src

*** array->list

    #+begin_src jojo
    (+jojo array->list 0 right-of-array->list)

    (+jojo right-of-array->list (-> :array :index -- list)
      (cond [:index :array array-length gteq?] [null]
            else [:array :index inc recur
                  :array :index array-ref
                  swap cons]))
    #+end_src

*** list-spread

    #+begin_src jojo
    (+jojo list-spread (-> :list --)
      (case :list
        <null> []
        <cons> [:list .car :list .cdr recur]))
    #+end_src

*** list-length

    #+begin_src jojo
    (+jojo list-length (-> :list -> <int>)
      (case :list
        <null> 0
        <cons> [:list .cdr recur inc]))
    #+end_src

*** list-any?

    #+begin_src jojo
    (+jojo list-any? (-> :list :pred -> <bool>)
      (cond [:list null?] [false]
            [:list .car :pred apply] [true]
            else [:list .cdr :pred recur]))
    #+end_src

*** list-every?

    #+begin_src jojo
    (+jojo list-every? (-> :list :pred -> <bool>)
      (cond [:list null?] [true]
            [:list .car :pred apply not] [false]
            else [:list .cdr :pred recur]))
    #+end_src

*** list-append

    #+begin_src jojo
    (+jojo list-append (-> :left :right -> list)
      (case :left
        <null> [:right]
        <cons> [:left .cdr :right recur
                :left .car swap cons]))
    #+end_src

*** tail-cons

    #+begin_src jojo
    (+jojo tail-cons null cons list-append)
    #+end_src

*** list-left

    #+begin_src jojo
    (+jojo list-left (-> :list :pred -- left)
      (cond [:list null?] [null]
            [:list .car :pred apply] [null]
            else [:list .car
                  :list .cdr :pred recur
                  cons]))
    #+end_src

*** list-right

    #+begin_src jojo
    (+jojo list-right (-> :list :pred -- right)
      (cond [:list null?] [null]
            [:list .car :pred apply] [:list]
            else [:list .cdr :pred recur]))
    #+end_src

*** list-split

    #+begin_src jojo
    (+jojo list-split (-> :list :pred -- left right)
      (cond [:list null?] [null null]
            [:list .car :pred apply] [null :list]
            else [:list .car
                  :list .cdr :pred recur
                  :right! cons :right]))
    #+end_src

*** list-map

    #+begin_src jojo
    (+jojo list-map (-> :list :fun -- list)
      (case :list
        <null> null
        <cons> [:list .car :fun apply :list .cdr :fun recur cons]))
    #+end_src

*** list-for-each

    #+begin_src jojo
    (+jojo list-for-each (-> :list :fun --)
      (case :list
        <null> []
        <cons> [:list .car :fun apply :list .cdr :fun recur]))
    #+end_src

*** list-filter

    #+begin_src jojo
    (+jojo list-filter (-> :list :pred -- list)
      (cond [:list null?] [null]
            [:list .car :pred apply] [:list .car :list .cdr :pred recur cons]
            else [:list .cdr :pred recur]))
    #+end_src

*** list-reverse

    #+begin_src jojo
    (+jojo list-reverse null swap list-reverse-swap-append)

    (+jojo list-reverse-swap-append (-> left :list -- list)
      (case :list
        <null> []
        <cons> [:list .car swap cons :list .cdr recur]))
    #+end_src

*** list-write

    #+begin_src jojo
    (+jojo list-write (-> :list :printer --)
      (case :list
        <null> []
        <cons> [:list .car :printer apply
                :list .cdr :printer recur]))
    #+end_src

*** list-eqv?

    #+begin_src jojo
    (+jojo list-eqv? (-> :l1 :l2 :eqv -- <bool>)
      (cond [:l1 null? :l2 null? and] [true]
            [:l1 null?] [false]
            [:l2 null?] [false]
            [:l1 .car :l2 .car :eqv apply not] [false]
            else [:l1 .cdr :l2 .cdr :eqv recur]))
    #+end_src

* sexp

*** [note] sexp

    #+begin_src jojo
    (note sexp
      = sexp list -- <null> or <cons>
      | <string>
      | <jo>)
    #+end_src

*** read-sexp

    #+begin_src jojo
    (+jojo read-sexp (-> -- sexp)
      read-jo :jo!
      (cond
        [:jo round-bar eq?]
        [round-ket read-sexp-list-until-ket]

        [:jo square-bar eq?]
        ['begin square-ket read-sexp-list-until-ket cons]

        [:jo flower-bar eq?]
        ['clo flower-ket read-sexp-list-until-ket cons]

        [:jo doublequote eq?]
        [read-string]

        [:jo singlequote eq?]
        ['quote null cons recur tail-cons]

        [:jo backquote eq?]
        ['partquote null cons recur tail-cons]

        else :jo))

    (+jojo read-sexp-list-until-ket (-> :ket <jo> -- sexp list)
      read-jo :jo!
      (if :jo :ket eq?
          then null
          else :jo jo-unread read-sexp, :ket recur, cons))
    #+end_src

*** sexp-write

    #+begin_src jojo
    (+jojo sexp-write (-> :sexp --)
      (case :sexp
        <null> ['null jo-write]
        <cons> [round-bar jo-write :sexp sexp-list-write
                round-ket jo-write]
        <string> [doublequote jo-write :sexp string-write
                  doublequote jo-write]
        <jo> [:sexp jo-write]))

    (+jojo sexp-list-write (-> :list sexp list --)
      (cond
        [:list null?] []
        [:list .cdr null?] [:list .car sexp-write]
        else [:list .car sexp-write space
              :list .cdr recur]))
    #+end_src

* syntax

*** repl

    #+begin_src jojo
    (+jojo repl (-> :input-stack --)
      :input-stack reading-stack-push
      repl/loop
      reading-stack-drop)

    (+jojo repl/loop
      (if has-jo? not then end)
      read-jo :jo!
      (if :jo round-bar eq? then
          read-jo
          round-bar jo-unread read-sexp
          (note (-> sexp list -- [compiling-stack]))
          swap jo-apply)
      (if repl-flag then print-data-stack)
      recur)
    #+end_src

*** compile-jojo

    #+begin_src jojo
    (+jojo compile-jojo (-> sexp list -- <jojo>)
      compiling-stack-tos
      swap sexp-list-compile
      emit-jojo-end
      '<jojo> tag-change)
    #+end_src

*** sexp-list-compile

    #+begin_src jojo
    (note
      [:list .car singlequote eq?]
      [:list .cdr .car emit-lit
       :list .cdr .cdr recur]

      [:list .car backquote eq?]
      [:list .cdr .car sexp-partquote-compile
       :list .cdr .cdr recur])

    (+jojo sexp-list-compile (-> :list sexp list --)
      (case :list
        <null> []
        <cons> [:list .car sexp-compile
                :list .cdr recur]))
    #+end_src

*** sexp-compile

    #+begin_src jojo
    (+jojo sexp-compile (-> :sexp --)
      (case :sexp
        <null>   [:sexp emit-lit]
        <cons>   [:sexp .cdr :sexp .car jo-apply]
        <string> [:sexp emit-lit]
        <jo>     [:sexp jo-compile]))
    #+end_src

*** (quote)

    #+begin_src jojo
    (+jojo quote .car emit-lit)
    #+end_src

*** (partquote)

    #+begin_src jojo
    (+jojo partquote .car sexp-partquote-compile)
    #+end_src

*** sexp-partquote-compile

    #+begin_src jojo
    (+jojo sexp-partquote-compile (-> :sexp --)
      (if :sexp cons?
          then :sexp sexp-partquote-compile/recur
          else :sexp sexp-compile))
    #+end_src

*** sexp-partquote-compile/recur

    #+begin_src jojo
    (+jojo sexp-partquote-compile/recur (-> :sexp --)
      (cond
        [:sexp null?]
        [null emit-lit]

        [:sexp .car cons? not]
        [:sexp .cdr recur
         :sexp .car emit-lit
         'swap jo-emit
         'cons jo-emit]

        [:sexp .car .car '@ eq?]
        [:sexp .cdr recur
         'list :sexp .car .cdr cons sexp-compile
         'swap jo-emit
         'list-append jo-emit]

        else
        [:sexp .cdr recur
         :sexp .car recur
         'swap jo-emit
         'cons jo-emit]))
    #+end_src

*** jo-compile

    #+begin_src jojo
    (+jojo jo-compile (-> :jo --)
      (cond [:jo int-jo?]       [:jo jo->int emit-lit]
            [:jo local-jo?]     [:jo jo-emit-local]
            [:jo set-local-jo?] [:jo jo-emit-set-local]
            [:jo field-jo?]     [:jo jo-emit-field]
            [:jo set-field-jo?] [:jo jo-emit-set-field]
            [:jo comma eq?]     []
            else [:jo jo-emit]))
    #+end_src

*** (if)

    #+begin_src jojo
    (+jojo if-else-then (-> :body --)
      :body {'then eq?} list-split (-> :question :then-else)
      :then-else {'else eq?} list-split (-> :then :else)
      :question sexp-list-compile
      emit-jz :address-for-jz!
      :then .cdr sexp-list-compile
      emit-jmp :address-for-jmp!
      :address-for-jz set-offset-to-here
      :else .cdr sexp-list-compile
      :address-for-jmp set-offset-to-here)

    (+jojo if-then (-> :body --)
      :body {'then eq?} list-split (-> :question :then)
      :question sexp-list-compile
      emit-jz :address-for-jz!
      :then .cdr sexp-list-compile
      :address-for-jz set-offset-to-here)

    (+jojo core-if (-> :body --)
      (cond
        [:body {'else eq?} list-any?
         :body {'then eq?} list-any? and]
        [:body if-else-then]

        [:body {'then eq?} list-any?]
        [:body if-then]

        else ["- if fail" string-write newline
              "  the body dose not has 'then" string-write newline
              "  body : " string-write :body sexp-list-write newline
              debug]))
    #+end_src

*** (clo)

    #+begin_src jojo
    (+jojo core-clo
      compile-jojo-copy emit-lit
      'current-local-env jo-emit
      'closure jo-emit)
    #+end_src

*** (cond)

    #+begin_src jojo
    (+jojo cond/expend (-> :body -- sexp)
      (cond
        [:body list-length 2 eq?]
        [:body .car :body .cdr .car cond/expend-if-then]

        else [:body .car :body .cdr .car cond/expend-if-then
              'else tail-cons
              :body .cdr .cdr recur tail-cons]))

    (note
      (+jojo cond/expend-if-then (-> :question :answer -- sexp)
        `(if (@ (if :question 'else eq?
                    then 'true
                    else :question))
             then (@ :answer))))

    (+jojo cond/expend-if-then (-> :question :answer -- sexp)
      'if null cons
      (if :question 'else eq?
          then 'true
          else :question)
      tail-cons
      'then tail-cons
      :answer tail-cons)
    #+end_src

*** (case)

    #+begin_src jojo
    (note
      (+jojo case/expend (-> :body -- sexp)
        `(begin (@ :body .car) (@ :body .cdr case/expend-rest))))

    (+jojo case/expend (-> :body -- sexp)
      'begin null cons
      :body .car tail-cons
      :body .cdr case/expend-rest tail-cons)

    (+jojo case/expend-rest (-> :body -- sexp)
      (cond
        [:body list-length 2 eq?]
        [:body .car :body .cdr .car case/expend-if-then]

        else [:body .car :body .cdr .car case/expend-if-then
              'else tail-cons
              :body .cdr .cdr recur tail-cons]))

    (note
      (+jojo case/expend-if-then (-> :tag :answer -- sexp)
        `(if (@ (if :tag 'else eq?
                    then 'true
                    else `(begin dup tag (@ :tag) eq?)))
             then drop (@ :answer))))

    (+jojo case/expend-if-then (-> :tag :answer -- sexp)
      'if null cons
      (if :tag 'else eq?
          then 'true
          else
          'begin null cons
          'dup tail-cons
          'tag tail-cons
          'quote null cons :tag tail-cons tail-cons
          'eq? tail-cons)
      tail-cons
      'then tail-cons
      'drop tail-cons
      :answer tail-cons)
    #+end_src

*** (->)

    #+begin_src jojo
    (+jojo arrow/expend (-> :body -- sexp)
      :body {'-- eq?} list-left
      {local-jo?} list-filter
      {local-jo->set-local-jo} list-map
      list-reverse
      'begin swap cons)
    #+end_src

*** compile-jojo-copy

    #+begin_src jojo
    (+jojo compile-jojo-copy (-> sexp list -- <jojo>)
      compiling-stack-tos :address!
      compile-jojo jojo-copy
      compiling-stack-drop
      :address compiling-stack-push)
    #+end_src

*** (+data)

    #+begin_src jojo
    (+jojo plus-data (-> :body --)
      (if :body .car tag-jo? not then
          "- plus-data fail" string-write newline
          "  name must be of form <...>" string-write newline
          "  body : " string-write :body sexp-list-write newline
          end)
      compiling-stack-tos :address!
      :body .cdr
      {field-jo?} list-filter
      {jo-emit} list-for-each
      emit-zero
      :address :body .car name-bind-data)
    #+end_src

*** (+gene)

    #+begin_src jojo
    (+jojo plus-gene (-> :body --)
      :body .cdr .car :arrow-sexp!
      :arrow-sexp .cdr
      {'-- eq?} list-left
      {local-jo?} list-filter
      list-length
      :body .car name-bind-gene)
    #+end_src

*** (+disp)

    - this syntax always use <jojo> as disp

    #+begin_src jojo
    (+jojo plus-disp (-> :body --)
      :body .cdr .car :arrow-sexp!
      :body .cdr :rest-body!

      :arrow-sexp .cdr
      {'-- eq?} list-left
      {tag-jo?} list-filter
      compiling-stack-tos :address-of-tags!
      {jo-emit} list-for-each
      emit-zero

      :rest-body compile-jojo-copy
      :address-of-tags
      :body .car
      name-bind-disp-to-jojo)
    #+end_src

* re-define syntax -- the order matters

*** (+jojo)

    #+begin_src jojo
    (+jojo +jojo (-> :body sexp list --)
      :body .cdr compile-jojo
      :body .car name-bind)
    #+end_src

*** run new repl

    #+begin_src jojo
    (run reading-stack-tos repl)
    #+end_src

*** redefine new keywords

    #+begin_src jojo
    (+jojo note drop)
    (+jojo run compile-jojo apply)

    (+jojo begin sexp-list-compile)

    (+jojo if core-if)
    (+jojo clo core-clo)

    (+jojo cond cond/expend sexp-compile)
    (+jojo case case/expend sexp-compile)
    (+jojo -> arrow/expend sexp-compile)

    (+jojo +data plus-data)
    (+jojo +gene plus-gene)
    (+jojo +disp plus-disp)
    #+end_src

* more syntax

*** (array)

    #+begin_src jojo
    (+jojo array array/expend sexp-compile)

    (+jojo array/expend (-> :body -- sexp)
      'begin null cons
      'mark tail-cons
      :body list-append
      'collect tail-cons)
    #+end_src

*** (list)

    #+begin_src jojo
    (+jojo list list/expend sexp-compile)

    (+jojo list/expend (-> :body -- sexp)
      'begin null cons
      'mark tail-cons
      :body list-append
      'collect tail-cons
      'array->list tail-cons)
    #+end_src

*** (assert) & (assert!)

    #+begin_src jojo
    (+jojo assert assert/expend sexp-compile)

    (+jojo assert/expend (-> :body -- sexp)
      `(if (@ :body list-spread)
           then
           else
           "- assert fail" string-write newline
           "  assertion : " string-write
           '(@ :body) sexp-list-write newline))


    (+jojo assert! assert!/expend sexp-compile)

    (+jojo assert!/expend (-> :body -- sexp)
      `(if (@ :body list-spread)
           then
           else
           "- assert! fail" string-write newline
           "  assertion : " string-write
           '(@ :body) sexp-list-write newline
           debug))
    #+end_src

*** (test)

    #+begin_src jojo
    (+jojo test/eval (-> :sexp --)
      (case :sexp
        <cons> [:sexp .cdr :sexp .car jo-apply]
        else []))

    (+jojo test (-> :body --)
      (if test-flag then :body {test/eval} list-for-each))
    #+end_src

*** (let-bind) -- moand interface

    #+begin_src jojo
    (note example
      (let-bind bind-maybe
        :l [:t1 .l :t2 .l zip-tree]
        :r [:t1 .r :t2 .r zip-tree]
        [:l :r node return-maybe])
      (begin
        [:t1 .l :t2 .l tree-zip]
        {:l! [:t1 .r :t2 .r zip-tree]
         {:r! [:l :r node return-maybe]}
         bind-maybe}
        bind-maybe)
      (begin
        [:t1 .l :t2 .l tree-zip] {:l!
        [:t1 .r :t2 .r zip-tree] {:r!
        [:l :r node return-maybe]} bind-maybe} bind-maybe))

    (+jojo let-bind let-bind/expend sexp-compile)

    (+jojo let-bind/expend (-> :body -- sexp)
      :body .car :body .cdr let-bind/expend-recur)

    (+jojo let-bind/expend-recur (-> :binder :rest -- sexp)
      (cond
        [:rest list-length 1 eq?]
        [:rest .car]

        [:rest .car local-jo?]
        [`[(@ :rest .cdr .car)
            {(@ :rest .car local-jo->set-local-jo
                :binder :rest .cdr .cdr recur)}
            (@ :binder)]]

        else
        [`[(@ :rest .car)
           {drop
            (@ :binder :rest .cdr recur)}
           (@ :binder)]]))
    #+end_src

* [test]

*** (list)

    #+begin_src jojo
    (test
      (run
        (assert
          mark 0 1 2 3 4 collect
          array->list
          (list 0 1 2 3 4)
          {eq?} list-eqv?)
        (assert
          (list 0 1 2 3 4)
          (list 5 6 7 8 9)
          list-append
          (list 0 1 2 3 4 5 6 7 8 9)
          {eq?} list-eqv?)
        (assert
          (list 0 1 2 3 4 5 6 7 8 9)
          {5 gteq?} list-left
          (list 0 1 2 3 4)
          {eq?} list-eqv?)
        (assert
          (list 0 1 2 3 4 5 6 7 8 9)
          {5 gteq?} list-split
          swap (list 0 1 2 3 4) {eq?} list-eqv?
          swap (list 5 6 7 8 9) {eq?} list-eqv?
          and)
        (assert
          (list 0 1 2 3 4 5 6 7 8 9)
          {inc} list-map
          (list 1 2 3 4 5 6 7 8 9 10)
          {eq?} list-eqv?)
        (assert
          (list 0 1 2 3 4 5 6 7 8 9)
          {2 mod 0 eq?} list-filter
          (list 0 2 4 6 8)
          {eq?} list-eqv?)
        (assert
          (list 0 1 2 3 4 5 6 7 8 9)
          list-reverse
          (list 9 8 7 6 5 4 3 2 1 0)
          {eq?} list-eqv?)))
    #+end_src

*** (+jojo)

    #+begin_src jojo
    (test
      (+jojo square dup mul)
      (run
        (assert 2 square 4 eq?)))
    #+end_src

*** (cond) & (case)

    #+begin_src jojo
    (test
      (+jojo list-1
        1 2 3 4 5 null cons cons cons cons cons)
      (+jojo list-length/cond
        :list!
        (cond
          [:list null?] [0]
          else [:list .cdr recur inc]))
      (run
        (assert list-1 list-length/cond 5 eq?))
      (+jojo list-length/case
        :list!
        (case :list
          <null> 0
          <cons> [:list .cdr recur inc]))
      (run
        (assert list-1 list-length/case 5 eq?)))
    #+end_src

*** (->)

    #+begin_src jojo
    (test
      (run
        1 2 (-> :x :y --)
        (assert :x 1 eq?)
        (assert :y 2 eq?)))
    #+end_src

*** (clo)

    #+begin_src jojo
    (test
      (+jojo com (-> :m1 :m2 -- jojo)
        {:m1 apply :m2 apply})
      (run
        (assert {1} {2} com apply add 3 eq?)
        (assert {1} {2} com {3} com apply add add 6 eq?)
        (assert {1} {2} {3} com com apply add add 6 eq?)))
    #+end_src

*** (+gene) & (+disp)

    #+begin_src jojo
    (test
      (+gene add-two (-> :x :y --))
      (+disp add-two (-> <string> <int> --) swap string-length add)
      (+disp add-two (-> <int> <string> --) string-length add)
      (+disp add-two (-> <int> <int> --) add)
      (+disp add-two (-> <string> <string> --)
        string-length swap string-length add)
      (run
        (assert "123" 3 add-two 6 eq?)
        (assert  3 "123" add-two 6 eq?)
        (assert  3 3 add-two 6 eq?)
        (assert  "123" "123" add-two 6 eq?)))
    #+end_src

*** partquote

    #+begin_src jojo
    (test
      (+jojo one-two-three 'one 'two 'three)
      (+jojo one-two-three-list '(one two three))
      (run
        (assert
          `(1 2 3)
          '(1 2 3)
          {eq?} list-eqv?)
        (assert
          `(1 2 3 (@ one-two-three) 1 2 3)
          '(1 2 3 one two three 1 2 3)
          {eq?} list-eqv?)
        (assert
          `(1 2 3 (@ one-two-three-list list-spread) 1 2 3)
          '(1 2 3 one two three 1 2 3)
          {eq?} list-eqv?)
        (assert
          `(((@ 1))) .car .car
          1 eq?)
        (assert
          `(((@ `(((@ 1)))))) .car .car .car .car
          1 eq?)))
    #+end_src

* the-story-begin

  #+begin_src jojo
  (+jojo the-story-begin
    core-flag-off
    test-flag-off
    repl-flag-on
    terminal-input-stack repl)

  (run print-data-stack the-story-begin)
  #+end_src
