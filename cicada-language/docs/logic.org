#+title: logic

* [todo-stack]

*** 對比 minikanren 和 prolog 對同樣問題的描述

*** use the type system as logic language

    - learn from prolog

* [note]

*** judgment and inference rule

***** inference rules are formed about judgment

      - a type constructor is a parameterized judgment
        - note that
          a type constructor itself is not judgment
          the type constructed by it is judgment
        - note that
          the return type of type constructor is always type-tt

      - a type constructor's data constructors
        are its inference rules
        - more specifically
          the type of the data constructor is the inference rule
          the name of the data constructor is the name of the inference rule

      - [evident : judgment] == [data : type]

      - judgment == relation

      - inference rules can generate directed graph
        where judgment is node
        and inference is directed star [not only edge] in the graph

      - a proof is formed by an inference tree
        a function is a proof
        - more specifically
          the type of the function is the theorem to be proved
          the body of the function record the inference tree

      - both inference rule and theorem are
        expressed in the form of arrow

***** judgment and predicate

      - a judgment reads like a predicate
        a predicate can be viewed as a set

      - a judgment can generate a predicate
        by searching its inference rules
        - the searching can be viewed as happening in
          the directed graph generated by inference rules

      - a judgment is like a predicate written in
        logic programming language

***** meta judgment

      - in the above we used ':' such as :
        type constructor : inference rule
        proof : theorem
        function : type

      - note that
        ':' itself is a name of a judgment !
        - thus if we want to write a type checker
          we can model ':' as a judgment
          just like an interpreter is a program

*** unification

***** what to unify ?

      - in cicada
        <term> := <type-term>, <union-term>, <data-term>
        --- (data <hypo>), (type <hypo>)
        --- <trunk>
        <type-term>  := (<type-constructor> <term> ...)
        <union-term> := (<union-constructor> <term> ...)
        <data-term>  := (<data-constructor> <term> ...)
        <trunk> := function application to be reduced

        data-bind-dict -- <hypo> to data <term>
        type-bind-dict -- <hypo> to type <term>

        <trunk> will be formed,
        when among arguments of a function application
        there is a <hypo> that is not bound to data
        or there is a non-reduce-able <trunk>

      - in logic
        <term> := <predicate-term>, <var>, <constant>
        <predicate-term> := (<predicate-symbol> <term> ...)

***** feature structures

      - <var> with two fields type and data,
        can be viewed as feature structures
        in unification theory

*** vector vs list

    - vector and list have the same data-constructor shape

    - it is *not* true that
      every function can be defined for vector
      can also be defined for list

      - for example zip can be defined for vector of same length

      - when defining zip for vector
        more informations in type
        can help to rule out some not meaningful cases

      list -> list
      vector -> vector
      can *not* be composed to
      list -> vector

    - it is true that
      every function can be defined for list
      can also be defined for vector

      - by dropping the length information

      vector -> vector
      list -> list
      can be composed
      vector -> list

    - vector can be viewed as subtype of list
      we can assert so
      and use this subtype relation to reuse functions

      - in some case [when namings are so different]
        we also need to assert relation between
        fields of type and data-constructors

*** proof search

***** the natural of the proof space

*** logical harmony

    - x -
      我们之前把 judgment 理解为 type-constructor
      inference rule 理解为 data-constructor
      这正确吗 ?

    ------

    - x -
      在這種理解方式下
      如何理解 logical harmony ?

*** provability as a judgment

    - it looks like a meta thing
      but function abstraction give us just it.
      by useing '->'

    - can we also bring down the meta-ness of ':' ?

    - can we really view function abstraction as
      bringing down provability ?

    - f : Y Z -> X
      g : Z -> (Y -> X)
      ------------------
      (let z) {z f}

* list processing

*** list-u

    #+begin_src cicada
    (+union list-u : (-> type : type-tt -- type-tt)
      (-> -- type null-t)
      (-> car : type
          cdr : type list-u
       -- type cons-t))
    #+end_src

*** append-o

    #+begin_src cicada
    (+relation append-o
      : )
    #+end_src

* number theory

*** int-q

    #+begin_src cicada

    #+end_src

*** mod-u

    #+begin_src cicada
    (+union mod-u
      : (->
         -- )
      (-> ))
    #+end_src

*** gcd-u

    #+begin_src cicada
    (+union gcd-u
      : (-> x : int-q
            y : int-q
            d : int-q
         -- type-tt)
      (-> -- x zero-c x zero-gcd-t)
      (-> gcd : x y d gcd-u
          mod : x y z mod-u
       -- y z d mod-gcd-t))
    #+end_src
