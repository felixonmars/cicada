* 2018-03-20

  - x -
    we need a theory of scope
    note that
    1. during cut, an arrow can be applied separately
    2. during exe, an arrow can be applied with the body

  - k -
    we might drop the use of hypo in cicada-language

    because cicada-prover will be a different implementation
    based on logic programming language tech

    at least,
    we must be clear about the difference
    between cicada-language and cicada-prover

  - x -
    I think we are so confused now
    because we are not sure which tech solution
    is used to solve which imp problem
    we are using hypo
    seems it is solving two problems :
    1. a variable has both type and value
    2. a variable might exist after the function exit

  - k -
    oh we must examine this by examples

* ><

*** [note] type-check detail of 'add-zero-commutative'

    #+begin_src cicada
    (match m succ-c)
    (= m m.prev succ-c)

    (type-computed

     [m.prev]
     [recur {succ-c} eq-apply]

     [m.prev zero-c add
      zero-c m.prev add eq-t]
     [{succ-c} eq-apply]

     [m.prev zero-c add succ-c
      zero-c m.prev add succ-c eq-t]

     [m.prev add succ-c
      zero-c m.prev add succ-c eq-t])

    (type-asserted

     [m zero-c add
      zero-c m add eq-t]

     [m.prev succ-c zero-c add
      zero-c m.prev succ-c add eq-t]

     [m.prev succ-c add
      zero-c m.prev succ-c add eq-t]

     [m.prev add succ-c
      zero-c m.prev succ-c add eq-t]

     [m.prev add succ-c
      zero-c m.prev add succ-c eq-t])
    #+end_src

*** [note] type-check detail of 'add-commutative'

    #+begin_src cicada
    (match n succ-c)
    (= n n.prev succ-c)

    (type-computed

     [m n.prev]
     [recur {succ-c} eq-apply
      n.prev m add-succ-commutative eq-swap eq-compose]

     [m n.prev add
      n.prev m add eq-t]
     [{succ} eq-apply
      n.prev m add-succ-commutative eq-swap eq-compose]

     [m n.prev add succ-c
      n.prev m add succ-c eq-t]
     [n.prev m add-succ-commutative eq-swap eq-compose]

     [m n.prev add succ-c
      n.prev m add succ-c eq-t
      n.prev succ-c m add
      n.prev m add succ-c eq-t]
     [eq-swap eq-compose]

     [m n.prev add succ-c
      n.prev m add succ-c eq-t
      n.prev m add succ-c
      n.prev succ-c m add eq-t]
     [eq-compose]

     [m n.prev add succ-c
      n.prev succ-c m add eq-t])

    (type-asserted

     [m n add
      n m add eq-t]

     [m n.prev succ-c add
      n.prev succ-c m add eq-t]

     [m n.prev add succ-c
      n.prev succ-c m add eq-t])
    #+end_src

*** [note] type-check detail of 'map-has-length'

    #+begin_src cicada
    (: has-length l n has-length-t)

    (match has-length cons-has-length)
      (= has-length has-length.cdr cons-has-length)
        (: has-length.cdr [l#0 n#0 has-length-t])
      (: has-length [a#0 l#0 cons n#0 succ-c has-length-t])
        (= l a#0 l#0 cons)
        (= n n#0 succ)

    (type-computed

     [has-length.cdr recur cons-has-length]

     [l#0 n#0 has-length-t]
     [recur cons-has-length]

     [l#0 fun#0 map n#0 has-length-t]
     [cons-has-length]

     [a#1 l#0 fun#0 map cons n#0 succ-c has-length-t])

    (type-asserted

     [l fun map n has-length-t]

     [a#0 l#0 cons fun map n#0 succ-c has-length-t]

     [a#0 @fun l#0 fun map cons n#0 succ-c has-length-t])
    #+end_src

*** [note] type-check detail of vector 'append'

    #+begin_src cicada
    (: :l0 [:m :t vector-u])
    (: :l1 [:n :t vector-u])

    (match :l1 cons)
      (= :l1 :l1.car :l1.cdr cons)
        (: :l1.cdr [:n#0 :t#0 vector-u])
        (: :l1.car :t#0)
      (: :l1 [:n#0 succ :t#0 vector-u])
        (= :n :n#0 succ)
        (= :t :t#0)

    (type-computed:

     [:l1.car :l0 :l1.cdr recur cons]

     [:m :t vector-u :n :t vector-u]
     ><><>< the order of cons
     [recur :l1.car cons]

     [:m :t vector-u :n#0 :t#0 vector-u]
     [recur :l1.car cons]

     [:m :n#0 add :t#0 vector-u]
     [:l1.car cons]

     [:m :n#0 add :t#0 vector-u :t#0]
     [cons]

     [:m :n#0 add succ :t#0 vector-u])

    (type-asserted:

     [:m :n add :t vector-u]

     [:m :n#0 succ add :t#0 vector-u]

     [:m :n#0 add succ :t#0 vector-u])
    #+end_src

*** [note] type-check detail of vector 'map'

    #+begin_src cicada
    (: :l [:n :t1 vector-u])
    (: :f (-> :t1 :t2))

    (match :l cons)
      (= :l :l.car :l.cdr cons)
        (: :l.cdr [:n#0 :t#0 vector-u])
        (: :l.car :t#0)
      (: :l [:n#0 succ :t#0 vector-u])
        (= :n :n#0 succ)
        (= :t1 :t#0)

    (type-computed:

     ><><>< the order of cons
     [:l.cdr :f recur :l.car :f apply cons]

     [:n#0 :t#0 vector-u (-> :t1 :t2)]
     [recur :l.car :f apply cons]

     [:n#0 :t2 vector-u]
     [:l.car :f apply cons]

     [:n#0 :t2 vector-u :t#0]
     [:f apply cons]

     [:n#0 :t2 vector-u :t2]
     [cons]

     [:n#0 succ :t2 vector-u])

    (type-asserted:

     [:n :t2 vector-u]

     [:n#0 succ :t2 vector-u])
    #+end_src
