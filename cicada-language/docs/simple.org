#+title: simple

* [todo-stack]

* [note]

*** (+type)

    - type of data in data-field must be of type type-tt
      thus, function can not be stored in data-field

*** naming convention

    - type

      | -t  | type constructor          |
      | -u  | union-type constructor    |
      | -q  | quotient-type constructor |
      | -tc | type-class                |
      | -tt | type of type              |

    - function

      | -p  | predicate        |
      | -c  | data constructor |
      | -cr | create           |

* bool

*** bool-u

    #+begin_src cicada
    (+union bool-u : type-tt
      (-> -- true-t)
      (-> -- false-t))
    #+end_src

* nat

*** nat-u

    #+begin_src cicada
    (+union nat-u : type-tt
      (-> -- zero-t)
      (-> prev : nat-u -- succ-t))

    (+fun nat-add : (-> [m n] : nat-u -- nat-u)
      (case n
        (zero-t m)
        (succ-t m n.prev recur succ-c)))

    (+fun nat-mul : (-> [m n] : nat-u -- nat-u)
      (case n
        (zero-t n)
        (succ-t m n.prev recur m nat-add)))

    (+fun nat-factorial : (-> n : nat-u -- nat-u)
      (case n
        (zero-t n succ-c)
        (succ-t n.prev recur n nat-mul)))
    #+end_src

* list

*** list-u

    #+begin_src cicada
    (+union list-u : (-> type : type-tt -- type-tt)
      (-> -- type null-t)
      (-> car : type
          cdr : [type list-u]
       -- type cons-t))
    #+end_src

*** list-u -- not inline

    #+begin_src cicada
    (+union list-u : (-> type : type-tt -- type-tt)
      null-t
      cons-t)

    (+type null-t : (-> type : type-tt -- type-tt)
      (-> -- type null-t))

    (+type cons-t : (-> type : type-tt -- type-tt)
      (-> car : type
          cdr : [type cons-t]
       -- type cons-t))
    #+end_src

*** list-length

    #+begin_src cicada
    (+fun list-length
      : (-> type :: type-tt
            list : [type list-u]
         -- nat-u)
      (case list
        (null-t zero-c)
        (cons-t list.cdr recur succ-c)))
    #+end_src

*** list-append

    #+begin_src cicada
    (+fun list-append
      : (-> type :: type-tt
            list : [type list-u]
            list2 : [type list-u]
         -- type list-u)
      (case list2
        (null-t list)
        (cons-t list2.car list list2.cdr recur cons-c)))
    #+end_src

*** list-map

    #+begin_src cicada
    (+fun list-map
      : (-> [type type2] :: type-tt
            list : [type list-u]
            fun : (-> type -- type2)
         -- type2 list-u)
      (case list
        (null-t list)
        (cons-t list.car fun list.cdr {fun} recur cons-c)))
    #+end_src

*** list-ref -- will not pass type check

    #+begin_src cicada
    ;; this function will not pass type check
    ;;   because we can not use car cdr on list-u
    ;;   we can only use them on cons-t
    #note
    (+fun list-ref
      : (-> type :: type-tt
            list : [type list-u]
            index : nat-u
         -- type)
      (case index
        (zero-t list.car)
        (succ-t list.cdr index.prev recur)))
    #+end_src

*** list-remove-first

    #+begin_src cicada
    (+fun list-remove-first
      : (-> type :: type-tt
            x : type
            list : [type list-u]
         -- type list-u)
      (case list
        (null-t list)
        (cons-t (case [list.car x eq-p]
                   (true-t  list.cdr)
                   (false-t list.car list.cdr x recur cons-c)))))
    #+end_src
