(run testing-flag/on)
(test top-repl/printing-flag/on)

(def cons-size      (bare-data (int 3) cell-size mul))
(def cons-area-size (bare-data (int 1024 1024) mul cons-size mul))
(def cons-area      (bare-data cons-area-size allocate))
(def cons-area-top  (bare-data cons-area cons-area-size add))
(def cons-pointer   (bare-data cons-area))
(def current-mark   (bare-data (int 1)))
(def max-mark       (bare-data (int 1024 1024) mul))

(def cons-pointer/next
  (jojo (note -> [cons-pointer])
    cons-size cons-pointer add
    (& cons-pointer) set))

(def cons-pointer/init
  (jojo (note -> [cons-pointer])
    cons-area
    (& cons-pointer) set))

(def cons-pointer/next-free
  (jojo (note -> [cons-pointer])
    (if cons-pointer cons-area-top eq? then end)
    (if cons-pointer get current-mark eq? not then end)
    cons-pointer/next
    (loop)))

(def cons?
  (jojo (note cell -> bool)
    (if dup cons-area lt? then drop false end)
    (if dup cons-area-top gteq? then drop false end)
    cons-area sub cons-size mod (int 0) eq?))



(declare
 (car (note cons -> cell))
 (cdr (note cons -> cell)))

(def cons-area/report/loop
  (jojo (note cons -> [io])
    (if dup cons-area-top eq? then drop end)
    (string "#:") string/print
    dup dot
    (string "mark: ") string/print
    dup get dot
    (string "car: ") string/print
    dup car dot
    (string "cdr: ") string/print
    dup cdr dot
    newline
    cons-size add
    (loop)))

(def cons-area/report
  (jojo (note -> [io])
    cons-area cons-area/report/loop))



(def sweep-cons-area/loop
  (jojo (note cons -> [io])
    (if dup cons-area-top eq? then drop end)
    dup (int 0)  swap set
    cons-size add
    (loop)))

(def sweep-cons-area
  (jojo (note -> [cons-area])
    cons-area sweep-cons-area/loop))



(note root from :
      stack
      defbare-data)

(def mark-cons
  (jojo (note cons -> [cons-area])
    (if dup cons? not then drop end)
    dup current-mark swap set
    dup car mark-cons
    cdr (loop)))

(def mark-cons-area/def-record
  (jojo (note def-record -> [cons-area])
    (if dup get (int 0) eq? then drop end)
    dup get mark-cons
    cell-size add
    (loop)))

(def mark-cons-area/argument-stack
  (jojo (note stack -> [cons-area])
    (if dup stack-base eq? then drop end)
    cell-size sub
    dup get mark-cons
    (loop)))

(def mark-cons-area
  (jojo (note -> [cons-area])
    (if current-mark max-mark eq? then
        sweep-cons-area
        (int 0) (& current-mark) set)
    current-mark (int 1) add (& current-mark) set
    def-record mark-cons-area/def-record
    stack-pointer
    mark-cons-area/argument-stack))



(note cons :
      mark
      car
      cdr)

(def new/cons
  (jojo (note -> cons)
    (if cons-pointer cons-area-top eq? then
        mark-cons-area
        cons-pointer/init
        cons-pointer/next-free
        (if cons-pointer cons-area-top eq? then
            (string "fatal error : cons-area is full") string/print
            newline bye)
        (loop))
    (if cons-pointer get current-mark eq? then
        cons-pointer/next (loop))
    cons-pointer
    cons-pointer/next end))

(def set-car
  (jojo (note cell cons ->)
    cell-size add
    set))

(def set-cdr
  (jojo (note cell cons ->)
    cell-size add
    cell-size add
    set))

(def car
  (jojo (note cons -> cell)
    cell-size add
    get))

(def cdr
  (jojo (note cons -> cell)
    cell-size add
    cell-size add
    get))

(def cons
  (jojo (note cdr-cell car-cell -> cons)
    new/cons
    tuck set-car
    tuck set-cdr))


(note the following tests are for small cons-area)

(note (test (int 0)
            (int 1) cons
            (int 2) cons
            dup car dot
            dup cdr car dot
            dup cdr cdr dot

            dup cons? dot
            dup cdr cons? dot
            dup car cons? dot
            dup cdr car cons? dot
            dup cdr cdr cons? dot
            dot

            current-mark
            dot))

(note (test newline
            new/cons dot
            new/cons dot
            new/cons dot
            new/cons dot
            new/cons dot
            current-mark dot
            newline
            cons-area/report
            newline))

(def assq
  (jojo
    (note assoc-list value -> pair or null)
    (if over null eq? then drop drop null end)
    (if over car cdr over eq? then drop car end)
    swap cdr swap (loop)))

(def assoc/find
  (jojo
    (note assoc-list value -> [pair true] or [false])
    (if over null eq? then drop drop false end)
    (if over car cdr over eq? then drop car true end)
    swap cdr swap (loop)))

(def list/print
  (jojo
    (note list -> [output])
    (if dup null eq? then drop (jo null) jo/print (string " ") string/print end)
    (if dup cons? not then dot end)
    dup cdr (recur)
    car (recur) (jo cons) jo/print (string " ") string/print))

(def list/copy
  (jojo
    (note list -> list)
    (note circles are not handled)
    (if dup cons? then end)
    dup cdr (recur)
    car (recur)
    swap
    cons))

(note
  (run (int 1) (int 2) cons
       (int 3) null cons
       cons
       dup
       cons
       dup list/print newline
       dup list/copy list/print newline
       dup list/copy list/print newline
       drop))

(def lev
  (note lev denotes leave-data-here)
  (keyword
    read/jo
    (if dup round-ket eq? then drop end)
    (if dup round-bar eq? then
        drop read/jo
        (if dup (jo esc) eq? then
            drop compile-jojo (loop))
        (el jo/apply (jo here) here (loop)))
    (el (jo ins/lit) here
        here
        (jo here) here (loop))))

(def alias
  (keyword
    read/jo (> nick)
    (if (< nick) round-ket eq? then end)
    read/jo (> name)
    (if (< name) round-ket eq? then
        (string "- alias meet uneven list") string/print newline
        (string "  last nick : ") string/print (< nick) jo/print
        newline
        end)
    (el (lev ins/lit (< nick)
             ins/lit (< name)
             alias-push)
        (loop))))

(def class/get-class-name          (jojo (jo class-name) assq car))

(def class/has-superclass?         (jojo (jo inherit) assq null eq? not))
(def class/get-superclass-name     (jojo (jo inherit) assq car))

(def class/has-meta-variable-list? (jojo (jo meta-variable) assq null eq? not))
(def class/get-meta-variable-list  (jojo (jo meta-variable) assq car))

(def class/has-meta-method-list?   (jojo (jo meta-method) assq null eq? not))
(def class/get-meta-method-list    (jojo (jo meta-method) assq car))

(def class/has-variable-list?      (jojo (jo variable) assq null eq? not))
(def class/get-variable-list       (jojo (jo variable) assq car))

(def class/has-method-list?        (jojo (jo method) assq null eq? not))
(def class/get-method-list         (jojo (jo method) assq car))

(def define-class/keyword/one-variable
  (keyword
    (lev ins/lit
         (esc read/jo here
              compile-jojo)
         cons cons cons)))

(def jo-ending-with-colon?
  (jojo
    (note jo -> bool)
    jo->string string/last-char
    (string ":") string/last-char eq?))

(def define-class/keyword/one-method/complex-message
  (keyword
    (note sum-jo -> sum-jo)
    read/jo
    (if dup round-ket eq? then drop end)
    (if dup jo-ending-with-colon? then
        jo/append
        (loop))
    swap (recur) swap
    (lev ins/lit
         (esc here)
         local-two-in)))

(def define-class/keyword/one-method/message
  (keyword
    (note -> jo)
    read/jo
    (if dup round-bar eq? not then end)
    drop read/jo drop
    empty-jo define-class/keyword/one-method/complex-message))

(def define-class/keyword/one-method
  (keyword
    (lev ins/jump)
    compiling-stack/tos (> offset-place)
    compiling-stack/inc
    compiling-stack/tos (> bare-jojo-place)
    define-class/keyword/one-method/message (> message)
    compile-jojo
    (lev end)
    compiling-stack/tos (< offset-place) set
    (lev ins/lit (< bare-jojo-place)
         ins/lit (< message)
         swap
         cons
         cons)))

(def define-class/keyword/inherit
  (keyword
    (lev ins/lit inherit
         ins/lit
         (esc read/jo here
              ignore)
         cons
         cons)))

(def define-class/keyword/meta-variable-list
  (keyword
    (alias * define-class/keyword/one-variable)
    (lev ins/lit meta-variable
         null
         (esc compile-jojo)
         cons
         cons)))

(def define-class/keyword/meta-method-list
  (keyword
    (alias * define-class/keyword/one-method)
    (lev ins/lit meta-method
         null
         (esc compile-jojo)
         cons
         cons)))

(def define-class/keyword/variable-list
  (keyword
    (alias * define-class/keyword/one-variable)
    (lev ins/lit variable
         null
         (esc compile-jojo)
         cons
         cons)))

(def define-class/keyword/method-list
  (keyword
    (alias * define-class/keyword/one-method)
    (lev ins/lit method
         null
         (esc compile-jojo)
         cons
         cons)))

(def define-class/help
  (keyword
    read/jo (> class-name)
    (alias
      inherit       define-class/keyword/inherit
      meta-method   define-class/keyword/meta-method-list
      meta-variable define-class/keyword/meta-variable-list
      variable      define-class/keyword/variable-list
      method        define-class/keyword/method-list)
    (lev null
         ins/lit class-name
         ins/lit (< class-name)
         cons
         cons
         (esc compile-jojo)
         ins/lit <class>
         ins/lit (< class-name))))

(def define-class
  (keyword
    compiling-stack/tos (> begin)
    define-class/help
    (lev end)
    (< begin) apply
    bind-name))

(def send-to-class/find-meta-method
  (jojo
    (note class message -> [value <*> true] or [false])
    (> message)
    (> class)
    (if (< class) class/has-meta-method-list? then
        (< class) class/get-meta-method-list
        (< message)
        assoc/find
        (if then
            car
            true
            end))
    (if (< class) class/has-superclass? then
        (< class) class/get-superclass-name jo/apply drop
        (< message)
        (loop))
    false))

(def send-to-class
  (jojo
    (> message)
    (> class)
    (< class) (< message)
    send-to-class/find-meta-method
    (if then
        local-area-pointer swap
        (< class) (jo self-class) local-in
        apply-with-local-area-pointer
        end)
    (string "- send-to-class : can not find message : ") string/print
    (< message) jo/print newline))

(def send-to-object/find-method
  (jojo
    (note class-name message -> [bare-jojo true] or [false])
    (> message)
    (> class-name)
    (< class-name) jo/apply drop (> class)
    (if (< class) class/has-method-list? then
        (< class) class/get-method-list
        (< message) assoc/find
        (if then
            car
            true
            end))
    (if (< class) class/has-superclass? then
        (< class) class/get-superclass-name
        (< message)
        (loop))
    false))

(def send-to-object
  (jojo
    (> message)
    (> class-name)
    (> data)
    (< class-name) (< message)
    send-to-object/find-method
    (if then
        local-area-pointer swap
        (< data) (< class-name) (jo self) local-two-in
        apply-with-local-area-pointer
        end)
    (string "- send-to-object : can not find message : ") string/print
    (< message) jo/print newline
    (string "  object/class-name : ") string/print
    (< class-name) jo/print newline))

(def send
  (jojo
    (if over (jo <class>) eq? then swap drop send-to-class end)
    send-to-object))

(def send/sugar/simple
  (keyword
    (note (: message ...)
          =>
          (> object) (bare-jojo ...) apply
          (< object) (jo message) send)
    (> message)
    (jo :) generate-jo (> object-jo)
    (lev ins/lit (< object-jo)
         local-two-in
         (esc bare-jojo) apply
         ins/lit (< object-jo)
         local-two-out
         ins/lit (< message)
         send)))

(def send/sugar/complex/loop
  (keyword
    (note sum-jo -> sum-jo)
    read/jo
    (if dup round-ket eq? then drop end)
    (if dup round-bar eq? then drop read/jo jo/apply (loop))
    (if dup jo-ending-with-colon? then jo/append (loop))
    here (loop)))

(def send/sugar/complex
  (keyword
    (note sum-jo -> sum-jo)
    (lev ins/jump)
    compiling-stack/tos (> offset-place)
    compiling-stack/inc
    compiling-stack/tos (> bare-jojo-place)
    send/sugar/complex/loop
    (lev end)
    compiling-stack/tos (< offset-place) set
    (lev ins/lit (< bare-jojo-place))))

(def :
  (keyword
    read/jo
    (if dup jo-ending-with-colon? not then
        send/sugar/simple end)
    (jo :) generate-jo (> object-jo)
    (lev ins/lit (< object-jo)
         local-two-in
         (esc send/sugar/complex (> message))
         apply
         ins/lit (< object-jo)
         local-two-out
         ins/lit (< message)
         send)))

(def get-instance-variable
  (jojo
    (note [object name] -> [data tag])
    (> name)
    (> class-name)
    (> instance-variable-list)

    (< instance-variable-list)
    (< name)
    assoc/find
    (if then car dup car swap cdr swap end)
    (string "- get-instance-variable fail") string/print newline))

(def <=
  (keyword
    (lev ins/lit
         (esc read/jo here
              ignore)
         get-instance-variable)))


(def set-instance-variable
  (jojo
    (note [object data type name] -> [])
    (> name)
    (> class-name)
    (> instance-variable-list)
    (> type-name)
    (> data)

    (< instance-variable-list)
    (< name)
    assoc/find
    (if then (> instance-variable)
        (< data) (< type-name) cons
        (< instance-variable) set-car end)
    (string "- set-instance-variable fail") string/print newline))

(def =>
  (keyword
    (lev ins/lit
         (esc read/jo here
              ignore)
         set-instance-variable)))

(define-class <object>
  (meta-method
    (* new
       (if (< self-class) class/has-variable-list? then
           (< self-class) class/get-variable-list list/copy
           (< self-class) class/get-class-name end)
       null
       (< self-class) class/get-class-name)))

(define-class <person>
  (inherit <object>)
  (meta-variable
    (* language (jo chinese) (jo <jo>)))
  (variable
    (* age (int 13) (jo <int>)))
  (method
    (* grow
       (<< self) (=> age))
    (* (: m1: a1 m2: a2)
       (<< a1) jo/print newline jo/print newline
       (<< a2) jo/print newline jo/print newline)))

(run <object> (: new) jo/print newline list/print newline)


(run <person> (: new) jo/print newline list/print newline)

(run <person> (: new) (<= age) jo/print newline dot newline)

(run  <person> (: new) 2dup
      (int 14) (jo <int>) 2swap (=> age)
      (<= age) jo/print newline dot newline)

(run  <person> (: new)
      (: m1:m2: (jo j1) (jo <j1>) (jo j2) (jo <j2>)))

(run  <person> (: new)
      (: m1: (jo j1) (jo <j1>) m2: (jo j2) (jo <j2>)))

(note
  (def new/method (jojo (note method/body method/name -> method) cons))

  (def defmethod
    (jojo (note (defmethod :class-name :method-name ...)
                =>
                (bare-jojo ...) (jo :method-name) new/method
                :class-name swap cons
                (& :class-name) set)

      read/jo (> class-name)
      read/jo (> method-name)

      address-of-here (> bare-jojo)
      compile-jojo
      (jo end) here

      (< class-name) jo-as-var get
      (< bare-jojo) (< method-name) new/method
      cons

      (< class-name) jo-as-var set)))

(note
  (def <file> (bare-data empty-class))

  (def new/file
    (jojo (note string -> <file>)
      (jo <file>)))

  (defmethod <file> readable?
    (<< self) file/readable?)

  (run
    (string "READM") new/file (:: readable?)))

(note
 (module <module-name> function ...)
 (dep <module-name>)
 (include <path>)
 (clib <path>))
