      (note
        (+jojo zip-tree :t1! :t2!
          (note [tree tree] -> [maybe-tree])
          (cond [:t1 leaf? :t2 leaf? and]
                [:t1 .v :t2 .v cons leaf return-maybe]
                [:t1 node? :t2 node? and]
                (let-bind bind-maybe
                  :l [:t1 .l :t2 .l zip-tree]
                  :r [:t1 .r :t2 .r zip-tree]
                  [:l :r node return-maybe])
                else nothing)))
  (run core-flag-on)
    (+data <null>)
    (+data <cons> .car .cdr)
    (+jojo list-length (-> :list -> <int>)
      (case :list
        <null> 0
        <cons> [:list .cdr recur inc]))
    (+jojo list-member? (-> :a :list -- <bool>)
      (case :list
        <null> false
        <cons> [(if :a :list .car eq? then true end)
                :a :list .cdr recur]))
    (+jojo list-append (-> :left :right -> list)
      (case :left
        <null> [:right]
        <cons> [:left .cdr :right recur
                :left .car swap cons]))
    (+jojo tail-cons null cons list-append)
    (+jojo list-left (-> :list :pred -- left)
      (cond [:list null?] [null]
            [:list .car :pred apply] [null]
            else [:list .car
                  :list .cdr :pred recur
                  cons]))
    (+jojo list-right (-> :list :pred -- right)
      (cond [:list null?] [null]
            [:list .car :pred apply] [:list]
            else [:list .cdr :pred recur]))
    (+jojo list-split (-> :list :pred -- left right)
      (cond [:list null?] [null null]
            [:list .car :pred apply] [null :list]
            else [:list .car
                  :list .cdr :pred recur
                  :right! cons :right]))
    (+jojo list-map (-> :list :fun -- list)
      (case :list
        <null> null
        <cons> [:list .car :fun apply :list .cdr :fun recur cons]))
    (+jojo list-filter (-> :list :pred -- list)
      (cond [:list null?] [null]
            [:list .car :pred apply] [:list .car :list .cdr :pred recur cons]
            else [:list .cdr :pred recur]))
    (+jojo list-reverse null swap list-reverse-swap-append)

    (+jojo list-reverse-swap-append (-> left :list -- list)
      (case :list
        <null> []
        <cons> [:list .car swap cons :list .cdr recur]))
    (+jojo int-list-write
      "'" string-write
      round-bar jo-write space
      int-list-write/loop
      round-ket jo-write space)

    (+jojo int-list-write/loop (-> :list --)
      (case :list
        <null> [space]
        <cons> [:list .car int-write space
                :list .cdr recur]))

    (run
      0 1 2 3 4 null
      cons cons cons cons cons

      5 6 7 8 9 null
      cons cons cons cons cons

      list-append
      int-list-write newline)

    (run
      0 1 2 3 4 5 6 7 8 9 null
      cons cons cons cons cons
      cons cons cons cons cons

      {5 gt?} list-left
      int-list-write newline)

    (run
      0 1 2 3 4 5 6 7 8 9 null
      cons cons cons cons cons
      cons cons cons cons cons

      {5 gteq?} list-split
      int-list-write int-list-write newline)

    (run
      0 1 2 3 4 5 6 7 8 9 null
      cons cons cons cons cons
      cons cons cons cons cons

      {inc inc inc} list-map int-list-write newline)

    (run
      0 1 2 3 4 5 6 7 8 9 null
      cons cons cons cons cons
      cons cons cons cons cons

      {2 mod 0 eq?} list-filter int-list-write newline)

    (run
      0 1 2 3 4 5 6 7 8 9 null
      cons cons cons cons cons
      cons cons cons cons cons

      list-reverse int-list-write newline)
    (note atom of sexp can only be <string> and <jo>)
    (note sexp
      = <cons> -- sexp list
      | <string>
      | <jo>)
    (+jojo read-sexp (-> -- sexp)
      read-jo :jo!
      (cond [:jo round-bar eq?] [round-ket read-sexp/list]
            [:jo square-bar eq?] [square-ket read-sexp/list 'vec swap cons]
            [:jo flower-bar eq?] [flower-ket read-sexp/list 'clo swap cons]
            [:jo doublequote eq?] [read-string]
            else [:jo]))

    (+jojo read-sexp/list (-> :ket <jo> -- sexp list)
      read-jo :jo!
      (if :jo :ket eq?
          then null
          else :jo jo-unread read-sexp, :ket recur, cons))
    (+jojo sexp-write (-> :sexp --)
      (case :sexp
        <cons>  [round-bar jo-write space
                 :sexp sexp-list-write
                 round-ket jo-write space]
        <string> [doublequote jo-write
                  :sexp string-write
                  doublequote jo-write space]
        <jo> [:sexp jo-write space]))

    (+jojo sexp-list-write (-> :list sexp list --)
      (case :list
        <null> [space]
        <cons> [:list .car sexp-write :list .cdr recur]))
    (+jojo repl (-> :input-stack --)
      :input-stack reading-stack-push
      repl/loop
      reading-stack-drop)

    (+jojo repl/loop
      (if has-jo? not then end)
      read-jo :jo!
      (if :jo round-bar eq? then
          read-jo
          round-bar jo-unread read-sexp
          (note (-> sexp list -- [compiling-stack]))
          swap jo-apply)
      (if repl-flag then print-data-stack)
      recur)
    (+jojo compile-jojo (-> sexp list -- <jojo>)
      compiling-stack-tos-as-jojo
      swap sexp-list-compile
      emit-jojo-end)
    (+jojo sexp-list-compile (-> :list sexp list --)
      (cond
        [:list null?] [end]

        [:list .car ' ' eq?]
        [:list .cdr .car emit-lit
         :list .cdr .cdr recur]

        else [:list .car sexp-compile
              :list .cdr recur]))
    (+jojo sexp-compile (-> :sexp --)
      (cond
        [:sexp cons?] [:sexp .cdr :sexp .car jo-apply]
        [:sexp string?] [:sexp emit-lit]
        [:sexp jo?] [:sexp jo-compile]))
    (+jojo jo-compile (-> :jo --)
      (cond [:jo int-jo?]       [:jo jo->int emit-lit]
            [:jo get-local-jo?] [:jo jo-emit-get-local]
            [:jo set-local-jo?] [:jo jo-emit-set-local]
            [:jo get-field-jo?] [:jo jo-emit-get-field]
            [:jo set-field-jo?] [:jo jo-emit-set-field]
            else [:jo jo-emit-call]))
    (+jojo if-else-then (-> :body --)
      :body {'then eq?} list-split (-> :question :then-else)
      :then-else {'else eq?} list-split (-> :then :else)
      :question sexp-list-compile
      emit-jz :jz-address!
      :then .cdr sexp-list-compile
      emit-jmp :jmp-address!
      :jz-address set-offset-to-here
      :else .cdr sexp-list-compile
      :jmp-address set-offset-to-here)

    (+jojo if-then (-> :body --)
      :body {'then eq?} list-split (-> :question :then)
      :question sexp-list-compile
      emit-jz :jz-address!
      :then .cdr sexp-list-compile
      :jz-address set-offset-to-here)

    (+jojo core-if (-> :body --)
      (cond
        ['else :body list-member?
         'then :body list-member? and]
        [:body if-else-then]

        ['then :body list-member?] [:body if-then]

        else ["- if fail" string-write newline
              "  the body dose not has 'then" string-write newline
              "  body : " string-write :body sexp-list-write newline
              debug]))
    (+jojo maybe-vec->list (-> :maybe -- list)
      (cond
        [:maybe cons? not] [:maybe null cons]
        [:maybe .car 'vec eq?] [:maybe .cdr]
        else [:maybe null cons]))
    (+jojo cond/expend (-> :body -- sexp)
      (cond
        [:body list-length 2 eq?]
        [:body .car :body .cdr .car cond/if-then]

        else [:body .car :body .cdr .car cond/if-then
              'else tail-cons
              :body .cdr .cdr recur tail-cons]))

    (note
      (+jojo cond/if-then (-> :question :answer -- sexp)
        `(if @{(if :question 'else eq?
                   then '(true)
                   else :question maybe-vec->list)}
             then @{:answer maybe-vec->list})))

    (+jojo cond/if-then (-> :question :answer -- sexp)
      (if :question 'else eq?
          then 'true null cons
          else :question maybe-vec->list)
      'then tail-cons
      :answer maybe-vec->list list-append
      'if swap cons)
    (note
      (+jojo case/expend (-> :body -- sexp)
        `(begin @{:body .car maybe-vec->list}
                {:body .cdr case/expend-rest})))

    (+jojo case/expend (-> :body -- sexp)
      :body .car maybe-vec->list
      :body .cdr case/expend-rest tail-cons
      'begin swap cons)

    (+jojo case/expend-rest (-> :body -- sexp)
      (cond
        [:body list-length 2 eq?]
        [:body .car :body .cdr .car case/if-then]

        else [:body .car :body .cdr .car case/if-then
              'else tail-cons
              :body .cdr .cdr recur tail-cons]))

    (note
      (+jojo case/if-then (-> :tag :answer -- sexp)
        `(if @{(if :tag 'else eq?
                   then '(true)
                   else `(dup tag ' {:tag} eq?))}
             then drop @{:answer maybe-vec->list})))

    (+jojo case/if-then (-> :tag :answer -- sexp)
      (if :tag 'else eq?
          then 'true null cons
          else 'dup 'tag '' :tag 'eq? null cons cons cons cons cons)
      'then tail-cons
      'drop tail-cons
      :answer maybe-vec->list list-append
      'if swap cons)
    (+jojo arrow/expend (-> :body -- sexp)
      :body {'-- eq?} list-left
      {get-local-jo?} list-filter
      {get-local-jo->set-local-jo} list-map
      list-reverse
      'begin swap cons)
    (+jojo clo clo/expend sexp-compile)

    (note (+jojo clo/expend (-> :body -- sexp)
            ))
    (+jojo +jojo (-> :body sexp list --)
      :body .car, :body .cdr compile-jojo, bind-name)

    (run reading-stack-tos repl)
    (+jojo note drop)
    (+jojo run compile-jojo apply)
    (+jojo begin sexp-list-compile)
    (+jojo if core-if)
    (+jojo cond cond/expend sexp-compile)
    (+jojo case case/expend sexp-compile)
    (+jojo -> arrow/expend sexp-compile)
  (+jojo square dup mul)
  (run 123 square int-write newline)

  (run 1 :x!
    (if :x 1 eq?
        then "is 1" string-write newline
        else "not 1" string-write newline))

  (run 3 :x!
    (cond
      [:x 1 eq?] ["is 1" string-write newline]
      [:x 2 eq?] ["is 2" string-write newline]
      else ["not 1 not 2" string-write newline]))

  (+jojo list-length-2
    :list!
    (case :list
      <null> 0
      <cons> [:list .cdr recur inc]))

  (run 1 2 3 4 5 null cons cons cons cons cons list-length-2 int-write newline)

  (run
    1 2 (-> :x :y --)
    :y :y add int-write space
    :y :y add int-write space
    :x :x add int-write space newline)
  (+jojo the-story-begin
    repl-flag-on terminal-input-stack repl)
  (run the-story-begin)
