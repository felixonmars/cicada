(run testing-flag/on)
(test top-repl/printing-flag/on)



(def cons-size      (bare-data (int 3) cell-size mul))
(def cons-area-size (bare-data (int 1024 1024) mul cons-size mul))
(def cons-area      (bare-data cons-area-size allocate))
(def cons-area-top  (bare-data cons-area cons-area-size add))
(def cons-pointer   (bare-data cons-area))
(def current-mark   (bare-data (int 1)))
(def max-mark       (bare-data (int 1024 1024) mul))

(def cons-pointer/next
  (jojo (note -> [cons-pointer])
    cons-size cons-pointer add
    (& cons-pointer) set))

(def cons-pointer/init
  (jojo (note -> [cons-pointer])
    cons-area
    (& cons-pointer) set))

(def cons-pointer/next-free
  (jojo (note -> [cons-pointer])
    (if cons-pointer cons-area-top eq? then end)
    (if cons-pointer get current-mark eq? not then end)
    cons-pointer/next
    (loop)))

(def cons?
  (jojo (note cell -> bool)
    (if dup cons-area lt? then drop false end)
    (if dup cons-area-top gteq? then drop false end)
    cons-area sub cons-size mod (int 0) eq?))



(declare
 (car (note cons -> cell))
 (cdr (note cons -> cell)))

(def cons-area/report/loop
  (jojo (note cons -> [io])
    (if dup cons-area-top eq? then drop end)
    (string "#:") string/print
    dup dot
    (string "mark: ") string/print
    dup get dot
    (string "car: ") string/print
    dup car dot
    (string "cdr: ") string/print
    dup cdr dot
    newline
    cons-size add
    (loop)))

(def cons-area/report
  (jojo (note -> [io])
    cons-area cons-area/report/loop))



(def sweep-cons-area/loop
  (jojo (note cons -> [io])
    (if dup cons-area-top eq? then drop end)
    dup (int 0)  swap set
    cons-size add
    (loop)))

(def sweep-cons-area
  (jojo (note -> [cons-area])
    cons-area sweep-cons-area/loop))



(note root from :
      stack
      defbare-data)

(def mark-cons
  (jojo (note cons -> [cons-area])
    (if dup cons? not then drop end)
    dup current-mark swap set
    dup car mark-cons
    cdr (loop)))

(def mark-cons-area/def-record
  (jojo (note def-record -> [cons-area])
    (if dup get (int 0) eq? then drop end)
    dup get mark-cons
    cell-size add
    (loop)))

(def mark-cons-area/argument-stack
  (jojo (note stack -> [cons-area])
    (if dup stack-base eq? then drop end)
    cell-size sub
    dup get mark-cons
    (loop)))

(def mark-cons-area
  (jojo (note -> [cons-area])
    (if current-mark max-mark eq? then
        sweep-cons-area
        (int 0) (& current-mark) set)
    current-mark (int 1) add (& current-mark) set
    def-record mark-cons-area/def-record
    stack-pointer
    mark-cons-area/argument-stack))



(note cons :
      mark
      car
      cdr)

(def new/cons
  (jojo (note -> cons)
    (if cons-pointer cons-area-top eq? then
        mark-cons-area
        cons-pointer/init
        cons-pointer/next-free
        (if cons-pointer cons-area-top eq? then
            (string "fatal error : cons-area is full") string/print
            newline bye)
        (loop))
    (if cons-pointer get current-mark eq? then
        cons-pointer/next (loop))
    cons-pointer
    cons-pointer/next end))

(def set-car
  (jojo (note cell cons ->)
    cell-size add
    set))

(def set-cdr
  (jojo (note cell cons ->)
    cell-size add
    cell-size add
    set))

(def car
  (jojo (note cons -> cell)
    cell-size add
    get))

(def cdr
  (jojo (note cons -> cell)
    cell-size add
    cell-size add
    get))

(def cons
  (jojo (note cdr-cell car-cell -> cons)
    new/cons
    tuck set-car
    tuck set-cdr))


(note the following tests are for small cons-area)

(note (test (int 0)
            (int 1) cons
            (int 2) cons
            dup car dot
            dup cdr car dot
            dup cdr cdr dot

            dup cons? dot
            dup cdr cons? dot
            dup car cons? dot
            dup cdr car cons? dot
            dup cdr cdr cons? dot
            dot

            current-mark
            dot))

(note (test newline
            new/cons dot
            new/cons dot
            new/cons dot
            new/cons dot
            new/cons dot
            current-mark dot
            newline
            cons-area/report
            newline))



(note under :class-name we have
      method-record
      [method-record alone for now])

(note object = :data :class-name
      i.e. two value on the stack)

(note when defining a class
      different interface-generator can be used to generate method list
      for example
      inherit
      low level array like data with free
      - free must free everything
      high level list list data using gc)

(note
  (class
    (note basd on one superclass
          thus single inheritance)
    (note shared variable list)
    (note instance variable list
          i.e. parts of the object)
    (note class method list)
    (note object method list
          where super can be used to use an method of superclass
          to implement a new method to override it)))

(note object creation

      two ways to implement this :
      (1) to use meta class -- class is an object
      (2) to use meta method -- class is not an object

      i will use (2))


(note syntax in a class

      inheritance

      object variable list
      (= ...)
      object method list
      (: ...)

      class variable list
      (meta (= ...))
      class method list
      (meta (: ...))

      (note syntax in a method

            get and set local variable
            (< ...)
            (> ...)
            (<< ...)
            (>> ...)

            message to object
            (: m1: ... m2: ...)
            get and set object variable
            (<= ...)
            (=> ...)

            message to class
            (: m1: ... m2: ...)
            get and set class variable
            (<= ...)
            (=> ...)))



(def class
  (jojo (note)
    compile-jojo
    (jo instruction/lit) here
    (jo <class>) here))

(def class/superclass          (jojo cdr cdr cdr cdr car))
(def class/meta-variable-list  (jojo cdr cdr cdr car))
(def class/meta-method-list    (jojo cdr cdr car))
(def class/variable-list       (jojo cdr car))
(def class/method-list         (jojo car))

(def <person>
  (class

    null

    (jo <no>)
    cons

    null
    (jo k1) (int 1) cons cons
    (jo k2) (int 2) cons cons
    cons

    null
    (jo new) (jojo null) drop cons cons
    (jo new2) (jojo null null cons) drop cons cons
    cons

    null
    (jo age1) (int 111) cons cons
    (jo age2) (int 222) cons cons
    cons

    null
    (jo grow) (jojo dup dot) drop cons cons
    (jo grow2) (jojo dup dot) drop cons cons
    cons

    ))

(run <person> jo/print newline
     class/superclass jo/print)




(run <person> (jo new) send-to-class
     over over (jo grow) send-to-object
     (<= age) dot)


(def send-to-class
  (jojo (note)
    ))

(note (def send-to-object )
      )



(def class-name/method-record (jojo jo/apply))


(def method-record/search
  (jojo (note message method-record -> (or method false))
    (if dup null eq? then
        drop drop false end)
    (if over over car method/name eq? then
        swap drop car method/body end)
    cdr (loop)))

(def send
  (jojo (note object message -> [depends on object and message])
    (> message)
    (> class-name)
    (> data)
    (< message)
    (< class-name)
    class-name/method-record method-record/search
    (if dup false eq? not then
        local-area-pointer
        (< data) (jo self) local-in
        apply-with-local-area-pointer end)
    (string "can not find message : ") string/print
    (< message) jo/print newline
    (string "object/class-name : ") string/print
    (< class-name) jo/print newline))

(def ::
  (jojo (note (:: message ...)
              =>
              (> object) (bare-jojo ...) apply
              (< object) (jo message) send)

    read/jo (> message)
    (jo ::) generate-jo (> object-jo)

    (jo instruction/lit) here
    (< object-jo) here
    (jo local-in) here

    bare-jojo (jo apply) here

    (jo instruction/lit) here
    (< object-jo) here
    (jo local-out) here

    (jo instruction/lit) here
    (< message) here
    (jo send) here))
