      (note
        (+jojo zip-tree :t1! :t2!
          (note [tree tree] -> [maybe-tree])
          (cond [:t1 leaf? :t2 leaf? and]
                [:t1 .v :t2 .v cons leaf return-maybe]
                [:t1 node? :t2 node? and]
                (let-bind bind-maybe
                  :l [:t1 .l :t2 .l zip-tree]
                  :r [:t1 .r :t2 .r zip-tree]
                  [:l :r node return-maybe])
                else nothing)))
  (run core-flag-on)
    (+data <null>)
    (+data <cons> .car .cdr)
    (note atom of jexp can only be <string> and <jo>)
    (note jexp
      = <round-bar-ket>
      | <square-bar-ket>
      | <flower-bar-ket>
      | <string>
      | <jo>)

    (+data <round-bar-ket>  .list)
    (+data <square-bar-ket> .list)
    (+data <flower-bar-ket> .list)
    (+jojo read-jexp (-> -- jexp)
      read-jo :jo!
      (cond [:jo round-bar eq?] [round-ket read-jexp/list round-bar-ket]
            [:jo square-bar eq?] [square-ket read-jexp/list square-bar-ket]
            [:jo flower-bar eq?] [flower-ket read-jexp/list flower-bar-ket]
            [:jo double-quote eq?] [read-string]
            else [:jo]))

    (+jojo read-jexp/list (-> :ket <jo> -- jexp list)
      read-jo :jo!
      (if :jo :ket eq?
          then null
          else :jo jo-unread read-jexp, :ket recur, cons))
    (+jojo jexp-write (-> :jexp --)
      (case :jexp
        <round-bar-ket>  [round-bar jo-write space
                          :jexp .list jexp-write/list
                          round-ket jo-write space]
        <square-bar-ket> [square-bar jo-write space
                          :jexp .list jexp-write/list
                          square-ket jo-write space]
        <flower-bar-ket> [flower-bar jo-write space
                          :jexp .list jexp-write/list
                          flower-ket jo-write space]
        <string> [double-quote jo-write
                  :jexp string-write
                  double-quote jo-write space]
        <jo> [:jexp jo-write space]))

    (+jojo jexp-write/list (-> :list jexp list --)
      (case :list
        <null> [space]
        <cons> [:list .car jexp-write :list .cdr recur]))
    (+jojo repl (-> :input-stack --)
      :input-stack reading-stack-push
      repl/loop
      reading-stack-drop)

    (+jojo repl/loop
      (if has-jo? not then end)
      read-jo :jo!
      (if :jo round-bar eq? then
          read-jo
          round-bar jo-unread read-jexp .list
          (note (-> jexp list -- [compiling-stack]))
          swap jo-apply)
      recur)
    (+jojo compile-jojo (-> jexp list -- <jojo>)
      new-jojo-from-compiling-stack-tos
      swap compile-jojo/help)

    (+jojo compile-jojo/help (-> :list jexp list --)
      (if :list null? then
          'end jo-emit-call
          0 int-emit-data
          0 int-emit-data
          end)
      :list .car :jexp!
      (cond [:jexp round-bar-ket?] [:jexp .list .cdr
                                    :jexp .list .car
                                    jo-apply]
            [:jexp square-bar-ket?] []
            [:jexp flower-bar-ket?] []
            [:jexp string?] [:jexp emit-lit]
            [:jexp jo?] [:jexp compile-jojo/jo])
      :list .cdr recur)

    (+jojo compile-jojo/jo (-> :jo --)
      (cond [:jo int-jo?]       [:jo jo->int emit-lit]
            [:jo get-local-jo?] [:jo jo-emit-get-local]
            [:jo set-local-jo?] [:jo jo-emit-set-local]
            [:jo get-field-jo?] [:jo jo-emit-get-field]
            [:jo set-field-jo?] [:jo jo-emit-set-field]
            else [:jo jo-emit-call]))
    (+jojo +jojo (-> :list jexp list --)
      :list .car, :list .cdr compile-jojo, bind-name)

    (run reading-stack-tos repl)
    (+jojo run compile-jojo apply)
    (+jojo note drop)
    (note (+jojo if-else-then
            )

      (+jojo if-then
        )

      (+jojo if (-> :l --)
        ))
    (+jojo square dup mul)
    (run 123 square int-write newline)
    (run terminal-input-stack repl)
