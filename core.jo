      (note
        (+jojo zip-tree :t1! :t2!
          (note [tree tree] -> [maybe-tree])
          (cond [:t1 leaf? :t2 leaf? and]
                [:t1 .v :t2 .v cons leaf return-maybe]
                [:t1 node? :t2 node? and]
                (let-bind bind-maybe
                  :l {:t1 .l :t2 .l zip-tree}
                  :r {:t1 .r :t2 .r zip-tree}
                  {:l :r node return-maybe})
                else nothing)))
  (run core-flag-on)
      (note jexp
        = jexp <cons>
        | jexp <vons>
        | jexp <fons>
        | <string>
        | <jo>)
    (+data <null>)
    (+data <cons> .car .cdr)
    (+data <vons> .var .vdr)
    (+data <fons> .far .fdr)
    (+jojo read-jexp (-> -- jexp)
      read-jo :jo!
      (cond [:jo round-bar eq?]  [read-jexp/cons]
            [:jo square-bar eq?] [read-jexp/vons]
            [:jo flower-bar eq?] [read-jexp/fons]
            [:jo double-quote eq?] [read-string]
            else [:jo]))

    (+jojo read-jexp/cons
      read-jo :jo!
      (if :jo round-ket eq?
          then null
          else :jo jo-unread read-jexp recur cons))

    (+jojo read-jexp/vons
      read-jo :jo!
      (if :jo round-ket eq?
          then null
          else :jo jo-unread read-jexp recur vons))

    (+jojo read-jexp/fons
      read-jo :jo!
      (if :jo round-ket eq?
          then null
          else :jo jo-unread read-jexp recur fons))
    (+jojo jexp-write (-> :jexp --)
      (case :jexp
        <cons> [round-bar  jo-write space :jexp jexp-write/cons]
        <vons> [square-bar jo-write space :jexp jexp-write/vons]
        <fons> [flower-bar jo-write space :jexp jexp-write/fons]
        <string> [double-quote jo-write
                  :jexp string-write
                  double-quote jo-write
                  space]
        <jo> [:jexp jo-write space]))

    (+jojo jexp-write/cons (-> :l --)
      (case :l
        <null> [round-ket jo-write space]
        <cons> [:l .car jexp-write
                :l .cdr recur]))

    (+jojo jexp-write/vons (-> :l --)
      (case :l
        <null> [square-bar jo-write space]
        <cons> [:l .car jexp-write
                :l .cdr recur]))

    (+jojo jexp-write/fons (-> :l --)
      (case :l
        <null> [flower-bar jo-write space]
        <cons> [:l .car jexp-write
                :l .cdr recur]))
    (+jojo repl
      push-terminal-to-reading-stack
      (if has-jo? not then drop-reading-stack end)
      read-jo :jo!
      (if :jo round-bar eq? then
          read-jo
          round-bar jo-unread read-jexp
          swap jo-apply)
      recur)
    (note
      (+jojo compile-jojo (-> :l jexp <cons> -- <jojo>)
        new-jojo-from-compiling-stack-tos
        swap compile-jojo/help)

      (+jojo compile-jojo/jo (-> :jo --)
        (cond
          [:jo number-jo?] [:jo jo->int emit-lit]
          [:jo get-local-jo?] [:jo jo-emit-get-local]
          [:jo set-local-jo?] [:jo jo-emit-set-local]
          [:jo get-field-jo?] [:jo jo-emit-get-field]
          [:jo set-field-jo?] [:jo jo-emit-set-field]
          else [:jo jo-emit-call]))

      (+jojo compile-jojo/help (-> :l jexp <cons> --)
        (if :l null? then
            'end jo-emit-call
            0 int-emit-data
            0 int-emit-data
            end)
        :l .car :jexp!
        (cond [:jexp cons?] [:jexp .cdr :jexp .car jo-apply]
              [:jexp vons?] []
              [:jexp fons?] []
              [:jexp string?] [:jexp emit-lit]
              [:jexp jo?] [:jexp compile-jojo/jo])
        :l .cdr recur))
    (note
      (+jojo +jojo (-> :l --)
        :l .car
        :l .cdr compile-jojo
        bind-name))
    (note (run repl))
    (note (+jojo run
            ))
    (note
      (+jojo square dup mul)
      (run ))
