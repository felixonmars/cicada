(run testing-flag/on)
(test top-repl/printing-flag/on)

(def cons-size      (data (integer 3) cell-size mul))
(def cons-area-size (data (integer 1024 1024) mul cons-size mul))
(def cons-area      (data cons-area-size allocate))
(def cons-area-top  (data cons-area cons-area-size add))
(def cons-pointer   (data cons-area))
(def current-mark   (data (integer 1)))
(def max-mark       (data (integer 1024 1024) mul))

(def cons-pointer/next
  (jojo
    (note -> [cons-pointer])
    cons-size cons-pointer add
    (& cons-pointer) set-cell))

(def cons-pointer/init
  (jojo
    (note -> [cons-pointer])
    cons-area
    (& cons-pointer) set-cell))

(def cons-pointer/next-free
  (jojo
    (note -> [cons-pointer])
    (if cons-pointer cons-area-top eq? then end)
    (if cons-pointer get-cell current-mark eq? not then end)
    cons-pointer/next
    (loop)))

(def cons?
  (jojo
    (note cell -> bool)
    (if dup cons-area lt? then drop false end)
    (if dup cons-area-top gteq? then drop false end)
    cons-area sub cons-size mod (integer 0) eq?))



(declare
 (car (note cons -> cell))
 (cdr (note cons -> cell)))

(def cons-area/report/loop
  (jojo
    (note cons -> [io])
    (if dup cons-area-top eq? then drop end)
    (string "#:") string/print
    dup dot
    (string "mark: ") string/print
    dup get-cell dot
    (string "car: ") string/print
    dup car dot
    (string "cdr: ") string/print
    dup cdr dot
    newline
    cons-size add
    (loop)))

(def cons-area/report
  (jojo
    (note -> [io])
    cons-area cons-area/report/loop))



(def sweep-cons-area/loop
  (jojo
    (note cons -> [io])
    (if dup cons-area-top eq? then drop end)
    dup (integer 0)  swap set-cell
    cons-size add
    (loop)))

(def sweep-cons-area
  (jojo
    (note -> [cons-area])
    cons-area sweep-cons-area/loop))



(note root from :
      stack
      def)

(def mark-cons
  (jojo
    (note cons -> [cons-area])
    (if dup cons? not then drop end)
    dup current-mark swap set-cell
    dup car mark-cons
    cdr (loop)))

(def mark-cons-area/def-record
  (jojo
    (note def-record -> [cons-area])
    (if dup get-cell (integer 0) eq? then drop end)
    dup get-cell mark-cons
    cell-size add
    (loop)))

(def mark-cons-area/argument-stack
  (jojo
    (note stack -> [cons-area])
    (if dup stack-base eq? then drop end)
    cell-size sub
    dup get-cell mark-cons
    (loop)))

(def mark-cons-area
  (jojo
    (note -> [cons-area])
    (if current-mark max-mark eq? then
        sweep-cons-area
        (integer 0) (& current-mark) set-cell)
    current-mark (integer 1) add (& current-mark) set-cell
    def-record mark-cons-area/def-record
    stack-pointer
    mark-cons-area/argument-stack))



(note cons :
      mark
      car
      cdr)

(def new/cons
  (jojo
    (note -> cons)
    (if cons-pointer cons-area-top eq? then
        mark-cons-area
        cons-pointer/init
        cons-pointer/next-free
        (if cons-pointer cons-area-top eq? then
            (string "fatal error : cons-area is full") string/print
            newline bye)
        (loop))
    (if cons-pointer get-cell current-mark eq? then
        cons-pointer/next (loop))
    cons-pointer
    cons-pointer/next end))

(def set-car
  (jojo
    (note cell cons ->)
    cell-size add
    set-cell))

(def set-cdr
  (jojo
    (note cell cons ->)
    cell-size add
    cell-size add
    set-cell))

(def car
  (jojo
    (note cons -> cell)
    cell-size add
    get-cell))

(def cdr
  (jojo
    (note cons -> cell)
    cell-size add
    cell-size add
    get-cell))

(def cons
  (jojo
    (note cdr-cell car-cell -> cons)
    new/cons
    tuck set-car
    tuck set-cdr))


(note the following tests are for small cons-area)

(note (test (integer 0)
            (integer 1) cons
            (integer 2) cons
            dup car dot
            dup cdr car dot
            dup cdr cdr dot

            dup cons? dot
            dup cdr cons? dot
            dup car cons? dot
            dup cdr car cons? dot
            dup cdr cdr cons? dot
            dot

            current-mark
            dot))

(note (test newline
            new/cons dot
            new/cons dot
            new/cons dot
            new/cons dot
            new/cons dot
            current-mark dot
            newline
            cons-area/report
            newline))

(def assq
  (jojo
    (note assoc-list value -> pair or null)
    (if over null eq? then drop drop null end)
    (if over car cdr over eq? then drop car end)
    swap cdr swap (loop)))

(def assoc/find
  (jojo
    (note assoc-list value -> [pair true] or [false])
    (if over null eq? then drop drop false end)
    (if over car cdr over eq? then drop car true end)
    swap cdr swap (loop)))

(def list/print
  (jojo
    (note list -> [output])
    (if dup null eq? then drop (jo null) jo/print (string " ") string/print end)
    (if dup cons? not then dot end)
    dup cdr (recur)
    car (recur) (jo cons) jo/print (string " ") string/print))

(def list/copy
  (jojo
    (note list -> list)
    (note circles are not handled)
    (if dup cons? then end)
    dup cdr (recur)
    car (recur)
    swap
    cons))

(note
  (run (integer 1) (integer 2) cons
       (integer 3) null cons
       cons
       dup
       cons
       dup list/print newline
       dup list/copy list/print newline
       dup list/copy list/print newline
       drop))

(def set-tail
  (jojo
    (note element list ->)
    (if dup cdr null eq? then
        swap
        null swap cons
        swap
        set-cdr end)
    (el cdr (loop))))

(def lev
  (note lev denotes leave-data-here)
  (keyword
    read/jo
    (if dup round-ket eq? then drop end)
    (if dup round-bar eq? then drop
        read/jo
        (if dup (jo esc) eq? then
            drop compile-jojo (loop))
        (el jo/apply (jo here) here (loop)))
    (el (jo ins/lit) here
        here
        (jo here) here (loop))))

(def alias
  (keyword
    read/jo (> nick)
    (if (< nick) round-ket eq? then end)
    read/jo (> name)
    (if (< name) round-ket eq? then
        (string "- alias meet uneven list") string/print newline
        (string "  last nick : ") string/print (< nick) jo/print
        newline
        end)
    (el (lev ins/lit (< nick)
             ins/lit (< name)
             alias-push)
        (loop))))

(def cat
  (keyword
    read/jo
    (if dup round-ket eq? then drop end)
    (if dup double-quote eq? then
        drop one-string
        (lev string/print)
        (loop))
    (if dup round-bar eq? then drop
        read/jo jo/apply (loop))
    (el here (loop))))

(note (run (cat "1 2 3" newline "4 5 6" newline "7 8 9" newline)))

(def class/get-tag                 (jojo (jo tag) assq car))

(def class/has-superclass?         (jojo (jo inherit) assq null eq? not))
(def class/get-super-tag           (jojo (jo inherit) assq car))

(def class/has-meta-variable-list? (jojo (jo meta-variable) assq null eq? not))
(def class/get-meta-variable-list  (jojo (jo meta-variable) assq car))

(def class/has-meta-method-list?   (jojo (jo meta-method) assq null eq? not))
(def class/get-meta-method-list    (jojo (jo meta-method) assq car))

(def class/has-variable-list?      (jojo (jo variable) assq null eq? not))
(def class/get-variable-list       (jojo (jo variable) assq car))

(def class/has-method-list?        (jojo (jo method) assq null eq? not))
(def class/get-method-list         (jojo (jo method) assq car))

(def define-class/keyword/one-variable
  (keyword
    (lev ins/lit
         (esc read/jo here
              compile-jojo)
         cons cons cons)))

(def define-class/keyword/one-bare-variable
  (keyword
    (lev ins/lit
         (esc read/jo here
              compile-jojo)
         ins/lit <data>
         cons cons cons)))

(def jo-ending-with-colon?
  (jojo
    (note jo -> bool)
    jo->string string/last-char
    (string ":") string/last-char eq?))

(def define-class/keyword/one-method/complex-message
  (keyword
    (note sum-jo -> sum-jo)
    read/jo
    (if dup round-ket eq? then drop end)
    (if dup jo-ending-with-colon? then
        jo/append
        (loop))
    swap (recur) swap
    (lev ins/lit
         (esc here)
         local-in)))

(def define-class/keyword/one-method/message
  (keyword
    (note -> jo)
    read/jo
    (if dup round-bar eq? not then end)
    drop read/jo drop
    empty-jo define-class/keyword/one-method/complex-message))

(def define-class/keyword/one-method/help
  (keyword
    (lev ins/jump)
    compiling-stack/tos (> offset-place)
    compiling-stack/inc
    compiling-stack/tos (> bare-jojo-place)
    define-class/keyword/one-method/message (> message)
    compile-jojo
    (lev end)
    compiling-stack/tos (< offset-place) set-cell
    (lev ins/lit (< bare-jojo-place)
         ins/lit (< message)
         swap
         cons)))

(def define-class/keyword/one-method
  (keyword
    define-class/keyword/one-method/help
    (lev cons)))

(def define-class/keyword/inherit
  (keyword
    (lev ins/lit inherit
         ins/lit
         (esc read/jo here
              ignore)
         cons
         cons)))

(def define-class/keyword/meta-variable-list
  (keyword
    (alias = define-class/keyword/one-variable
           - define-class/keyword/one-bare-variable)
    (lev ins/lit meta-variable
         null
         (esc compile-jojo)
         cons
         cons)))

(def define-class/keyword/meta-method-list
  (keyword
    (alias * define-class/keyword/one-method)
    (lev ins/lit meta-method
         null
         (esc compile-jojo)
         cons
         cons)))

(def define-class/keyword/variable-list
  (keyword
    (alias = define-class/keyword/one-variable
           - define-class/keyword/one-bare-variable)
    (lev ins/lit variable
         null
         (esc compile-jojo)
         cons
         cons)))

(def define-class/keyword/method-list
  (keyword
    (alias * define-class/keyword/one-method)
    (lev ins/lit method
         null
         (esc compile-jojo)
         cons
         cons)))

(def define-class/help
  (keyword
    read/jo (> tag)
    (alias
      inherit       define-class/keyword/inherit
      meta-method   define-class/keyword/meta-method-list
      meta-variable define-class/keyword/meta-variable-list
      variable      define-class/keyword/variable-list
      method        define-class/keyword/method-list)
    (lev null
         ins/lit tag
         ins/lit (< tag)
         cons
         cons
         (esc compile-jojo)
         ins/lit <class>
         ins/lit (< tag))))

(def define-class
  (keyword
    compiling-stack/tos (> begin)
    define-class/help
    (lev end)
    (< begin) apply
    bind-name))

(def send-to-class/find-meta-method
  (jojo
    (note class message -> [value <*> true] or [false])
    (> message)
    (> class)
    (if (< class) class/has-meta-method-list? then
        (< class) class/get-meta-method-list
        (< message)
        assoc/find
        (if then
            car
            true
            end))
    (if (< class) class/has-superclass? then
        (< class) class/get-super-tag jo/apply drop
        (< message)
        (loop))
    false))

(def send-to-class
  (jojo
    (> message)
    (> tag)
    (> class)
    (< class) (< message)
    send-to-class/find-meta-method
    (if then
        current-local-pointer swap
        (< class) (< tag) (jo self) local-in
        apply-with-local-pointer
        end)
    (string "- send-to-class : can not find message : ") string/print
    (< message) jo/print newline))

(def send-to-object/find-method
  (jojo
    (note tag message -> [bare-jojo true] or [false])
    (> message)
    (> tag)
    (< tag) jo/apply drop (> class)
    (if (< class) class/has-method-list? then
        (< class) class/get-method-list
        (< message) assoc/find
        (if then
            car
            true
            end))
    (if (< class) class/has-superclass? then
        (< class) class/get-super-tag
        (< message)
        (loop))
    false))

(def send-to-object
  (jojo
    (> message)
    (> tag)
    (> data)
    (< tag) (< message)
    send-to-object/find-method
    (if then
        current-local-pointer swap
        (< data) (< tag) (jo self) local-in
        apply-with-local-pointer
        end)
    (string "- send-to-object : can not find message : ") string/print
    (< message) jo/print newline
    (string "  object/tag : ") string/print
    (< tag) jo/print newline))

(def send
  (jojo
    (if over (jo <class>) eq? then send-to-class end)
    send-to-object))

(def send/sugar/complex
  (keyword
    (note sum-jo -> sum-jo)
    read/jo
    (if dup round-ket eq? then drop end)
    (if dup round-bar eq? then drop read/jo jo/apply (loop))
    (if dup jo-ending-with-colon? then jo/append (loop))
    here (loop)))

(def :
  (keyword
    (jo :) generate-jo (> object-jo)
    (lev ins/lit (< object-jo)
         local-in
         (esc read/jo
              (if dup jo-ending-with-colon? not
                  then (> message) compile-jojo
                  else send/sugar/complex (> message)))
         ins/lit (< object-jo)
         local-out
         ins/lit (< message)
         send)))

(def get-instance-variable
  (jojo
    (note [instance-variable-list tag name] -> [data tag])
    (> name)
    (> tag)
    (> instance-variable-list)
    (< instance-variable-list)
    (< name)
    assoc/find
    (if then car dup car swap cdr swap end)
    (el (cat "- get-instance-variable fail" newline
             "  name : " name jo/print newline
             "  tag : " (< tag) jo/print newline))))

(def get-meta-variable
  (jojo
    (note [class (jo <class>) name] -> [data tag])
    (> name)
    (> tag)
    (> class)
    (if (< class) class/has-meta-variable-list? not then
        (cat "- get-meta-variable fail" newline
             "  the class do not has meta-variable-list" newline
             "  name : " name jo/print newline
             "  class-name : " (< class) class/get-tag jo/print newline)
        end)
    (< class) class/get-meta-variable-list
    (> meta-variable-list)
    (< meta-variable-list)
    (< name)
    assoc/find
    (if then car dup car swap cdr swap end)
    (el (cat "- get-meta-variable fail" newline
             "  name : " name jo/print newline
             "  class-name : " (< class) class/get-tag jo/print newline))))

(def get-variable
  (jojo
    (note [data tag name] -> [data tag])
    (if over (jo <class>) eq? not then
        get-instance-variable end)
    (el get-meta-variable)))


(def get
  (keyword
    (lev ins/lit
         (esc read/jo here
              ignore)
         get-variable)))

(def get-data
  (keyword
    (lev ins/lit
         (esc read/jo here
              ignore)
         get-variable drop)))

(def get-tag
  (keyword
    (lev ins/lit
         (esc read/jo here
              ignore)
         get-variable swap drop)))



(def set-instance-variable
  (jojo
    (note [data tag instance-variable-list source-tag name] -> [])
    (> name)
    (> source-tag)
    (> instance-variable-list)
    (>> object)
    (< instance-variable-list)
    (< name)
    assoc/find
    (if then (> variable)
        (<< object) cons
        (< variable) set-car
        end)
    (el (cat "- set-instance-variable fail" newline
             "  name : " name jo/print newline))))

(def set-meta-variable
  (jojo
    (note [data tag class (jo <class>) name] -> [])
    (> name)
    drop
    (> class)
    (>> object)
    (if (< class) class/has-meta-variable-list? not then
        (cat "- set-meta-variable fail" newline
             "  the class do not has meta-variable-list" newline
             "  name : " name jo/print newline
             "  class-name : " (< class) class/get-tag jo/print newline)
        end)
    (< class) class/get-meta-variable-list
    (> meta-variable-list)
    (< meta-variable-list)
    (< name)
    assoc/find
    (if then (> variable)
        (<< object) cons
        (< variable) set-car
        end)
    (el (cat "- set-meta-variable fail" newline
             "  name : " name jo/print newline
             "  class-name : " (< class) class/get-tag jo/print newline))))

(def set-variable
  (jojo
    (note [data tag source-data source-tag name] -> [])
    (if over (jo <class>) eq? not then
        set-instance-variable end)
    (el set-meta-variable)))

(def set
  (keyword
    (lev ins/lit
         (esc read/jo here
              ignore)
         set-variable)))

(def set-data-in-instance-variable
  (jojo
    (note [data instance-variable-list source-tag name] -> [])
    (> name)
    (> source-tag)
    (> instance-variable-list)
    (> data)
    (< instance-variable-list)
    (< name)
    assoc/find
    (if then (> variable)
        (< variable) car cdr (> tag-in-variable)
        (< data) (< tag-in-variable) cons
        (< variable) set-car
        end)
    (el (cat "- set-data-in-instance-variable fail" newline
             "  name : " name jo/print newline))))

(def set-data-in-meta-variable
  (jojo
    (note [data class (jo <class>) name] -> [])
    (> name)
    drop
    (> class)
    (> data)
    (if (< class) class/has-meta-variable-list? not then
        (cat "- set-data-in-meta-variable fail" newline
             "  the class do not has meta-variable-list" newline
             "  name : " name jo/print newline
             "  class-name : " (< class) class/get-tag jo/print newline)
        end)
    (< class) class/get-meta-variable-list
    (> meta-variable-list)
    (< meta-variable-list)
    (< name)
    assoc/find
    (if then (> variable)
        (< variable) car cdr (> tag-in-variable)
        (< data) (< tag-in-variable) cons
        (< variable) set-car
        end)
    (el (cat "- set-data-in-meta-variable fail" newline
             "  name : " name jo/print newline
             "  class-name : " (< class) class/get-tag jo/print newline))))

(def set-data-in-variable
  (jojo
    (note [data source-data source-tag name] -> [])
    (if over (jo <class>) eq? not then
        set-data-in-instance-variable end)
    (el set-data-in-meta-variable)))

(def set-data
  (keyword
    (lev ins/lit
         (esc read/jo here
              ignore)
         set-data-in-variable)))

(def set-tag-in-instance-variable
  (jojo
    (note [tag instance-variable-list source-tag name] -> [])
    (> name)
    (> source-tag)
    (> instance-variable-list)
    (> tag)
    (< instance-variable-list)
    (< name)
    assoc/find
    (if then (> variable)
        (< variable) car car (> data-in-variable)
        (< data-in-variable) (< tag) cons
        (< variable) set-car
        end)
    (el (cat "- set-tag-in-instance-variable fail" newline
             "  name : " name jo/print newline))))

(def set-tag-in-meta-variable
  (jojo
    (note [tag class (jo <class>) name] -> [])
    (> name)
    drop
    (> class)
    (> tag)
    (if (< class) class/has-meta-variable-list? not then
        (cat "- set-tag-in-meta-variable fail" newline
             "  the class do not has meta-variable-list" newline
             "  name : " name jo/print newline
             "  class-name : " (< class) class/get-tag jo/print newline)
        end)
    (< class) class/get-meta-variable-list
    (> meta-variable-list)
    (< meta-variable-list)
    (< name)
    assoc/find
    (if then (> variable)
        (< variable) car car (> data-in-variable)
        (< data-in-variable) (< tag) cons
        (< variable) set-car
        end)
    (el (cat "- set-tag-in-meta-variable fail" newline
             "  name : " name jo/print newline
             "  class-name : " (< class) class/get-tag jo/print newline))))

(def set-tag-in-variable
  (jojo
    (note [tag source-data source-tag name] -> [])
    (if over (jo <class>) eq? not then
        set-tag-in-instance-variable end)
    (el set-tag-in-meta-variable)))

(def set-tag
  (keyword
    (lev ins/lit
         (esc read/jo here
              ignore)
         set-tag-in-variable)))

(def add-method
  (keyword
    read/jo (> tag)
    (< tag) jo/apply drop (> class)
    compiling-stack/tos (> begin)
    define-class/keyword/one-method/help
    (lev end)
    (< begin) apply (> method)

    (if (< class) class/has-method-list? not then
        (jo method) (< method) cons
        (< class) set-tail end)
    (el (< method)
        (< class) class/get-method-list
        set-tail)))

(define-class <object>
  (meta-method
    (* new
       (if (< self) class/has-variable-list? then
           (< self) class/get-variable-list list/copy
           (< self) class/get-tag end)
       null
       (< self) class/get-tag)))

(define-class <int>
  (method
    (* inc (< self) inc (<% self))
    (* dec (< self) dec (<% self))
    (* neg (< self) neg (<% self))

    (* (: add: i) (< self) (< i) add (<% self))
    (* (: sub: i) (< self) (< i) sub (<% self))
    (* (: mul: i) (< self) (< i) mul (<% self))
    (* (: div: i) (< self) (< i) div (<% self))
    (* (: mod: i) (< self) (< i) mod (<% self))

    (* (: eq?: i) (< self) (< i) eq?)
    (* (: gt?: i) (< self) (< i) gt?)
    (* (: lt?: i) (< self) (< i) lt?)
    (* (: gteq?: i) (< self) (< i) gteq?)
    (* (: lteq?: i) (< self) (< i) lteq?)

    (* print (< self) integer/print)
    (* dot (< self) integer/dot)
    (* write (string "(int ") string/print
       (<< self) (: print)
       (string ") ") string/print)))

(def int
  (keyword
    (jo integer) jo/apply
    (lev ins/lit <int>)))

(define-class <str>
  (method
    (* print (< self) string/print)
    (* length (< self) string/length (jo <int>))
    (* write
       (string "(str ") string/print
       double-quote jo/print
       (<< self) (: print)
       double-quote jo/print
       (string ") ") string/print)))

(def str
  (keyword
    (jo string) jo/apply
    (lev ins/lit <str>)))

(note
  (test (str "k1 k2 k3")
        2dup (: print) newline
        2dup (: write) newline
        2dup (: length) (: print) newline
        2dup (: length) (: write) newline
        2drop))

(define-class <jojo>
  (method
    (* apply (< self) apply)))

(define-class <table>
  (method
    (* find )))

(define-class <bare-stack>
  (inherit <object>)
  (variable
    (- stack null))
  (method
    (* pop
       (<< self) (get-data stack)
       dup car (> data)
       cdr (<< self) (set-data stack)
       (< data))
    (* (: push: data)
       (<< self) (get-data stack)
       (< data)
       cons
       (<< self) (set-data stack))))

(note (define-class <stack>
        (inherit <bare-stack>)
        (method
          (* pop
             )
          (* (: push: value)
             ))))

(test current-dir string/print newline)

(test (string "HOME") var-string->env-string
      string/print newline)

(test (string "PATH") var-string->env-string
      string/print newline)

(def command-line/print-argument/loop
  (jojo (note index -> [io])
    (if dup argument-counter lt? then
        dup index->argument-string string/print
        newline
        (integer 1) add
        (loop))
    drop end))

(def command-line/print-argument
  (jojo (note -> [io])
    (integer 0) command-line/print-argument/loop))

(test command-line/print-argument)

(note (test def-report))

(define-class <path>
  (inherit <str>)
  (method
    (* write
       (string "(path ") string/print
       double-quote jo/print
       (<< self) (: print)
       double-quote jo/print
       (string ") ") string/print)))

(add-method <str> to-path
  (< self) (jo <path>))

(test (str "/home/") (: to-path) (: write))

(note

  (define-class <file>
    (method
      (* close)))

  (add-method <path> open-for-reading
    (< self) string/open-for-reading)

  (add-method <path> (: open-for: flags)
    (note fd = open(pathname, flags, mode)
          if the file doesn’t exist,
          open() may create it,
          depending on the settings of the flags bitmask argument.
          the flags argument also specifies
          whether the file is to be opened for reading, writing, or both.))

  (add-method <path> (: open-for: flags with: mode)
    (note the mode argument specifies the permissions
          to be placed on the file if it is created by this call.
          If the open() call is not being used to create a file,
          this argument is ignored and can be omitted))

  (note numread = read(fd, buffer, count)
        reads at most count bytes from the open file
        referred to by fd and stores them in buffer.
        The read() call returns the number of bytes actually read.
        If no further bytes could be read
        (i.e., end-of-file was encountered),
        read() returns 0.)

  (note numwritten = write(fd, buffer, count)
        writes up to count bytes from buffer to the open file
        referred to by fd.
        The write() call returns the number of bytes actually written,
        which may be less than count.)

  (note status = close(fd)
        is called after all I/O has been completed,
        in order to release the file descriptor fd
        and its associated kernel resources.))

(test (string "README") file/size dot)

(test (string "README") file/readable? dot)

(test (string "README")
      dup file/size
      allocate tuck file/copy-to-buffer
      drop
      string/print
      newline)

(note
  (module module-name [version])
  (use module-name [version]
       ...)
  (include "path"))

(note
  (load-module module-name[version])

  module-stack module-name[version]

  define name
  def module-name[version].name

  defining-stack name module-name[version].name)

(note
  (def module-stack
    ))

(note
  (def module-record
    ))

(note
  (include "path")
  (clib "path"))

(define-class <person>
  (inherit <object>)
  (meta-variable
    (= testing-meta-variable (int 666)))
  (variable
    (- bare-age (integer 5))
    (= age (int 13))
    (= language (str "chinese")))
  (method
    (* grow
       (<< self) (get age) (: inc)
       (<< self) (set age))
    (* (: grow-by: years)
       (<< self) (get age) (: add: (<< years))
       (<< self) (set age))
    (* (: grow-by: year1 and-by: year2)
       (<< self) (get age) (: add: (<< year1)) (: add: (<< year2))
       (<< self) (set age))
    (* report
       (cat "bare-age : "
            (<< self) (get-data bare-age) integer/print newline
            "age : "
            (<< self) (get age) (: print) newline
            "languege : "
            (<< self) (get language) (: print) newline
            newline))))

(def xieyuheng <person> (: new))

(run xieyuheng (: report)
     xieyuheng (: grow)
     xieyuheng (: report)
     xieyuheng (: grow-by: (int 10))
     xieyuheng (: report)
     xieyuheng (: grow-by: (int 10))
     xieyuheng (: report)
     xieyuheng (: grow-by: (int 10) and-by: (int 10))
     xieyuheng (: report))

(run <person> (get testing-meta-variable) (: write)
     (int 777)
     <person> (set testing-meta-variable)
     <person> (get testing-meta-variable) (: write)
     (int 888)
     <person> (set testing-meta-variable)
     <person> (get testing-meta-variable) (: write))

(note (test (string "asd") open-for-reading dot)
      (test (string "README") open-for-reading dot))

(def module-stack <bare-stack> (: new))

(test module-stack (: push: (data (integer 1)))
      module-stack (: push: (data (integer 2)))
      module-stack (: push: (data (integer 3)))
      module-stack (: pop) integer/print newline
      module-stack (: pop) integer/print newline
      module-stack (: pop) integer/print newline)
