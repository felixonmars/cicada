      (note
        (+jojo zip-tree :t1! :t2!
          (note [tree tree] -> [maybe-tree])
          (cond [:t1 leaf? :t2 leaf? and]
                [:t1 .v :t2 .v cons leaf return-maybe]
                [:t1 node? :t2 node? and]
                (let-bind bind-maybe
                  :l {:t1 .l :t2 .l zip-tree}
                  :r {:t1 .r :t2 .r zip-tree}
                  {:l :r node return-maybe})
                else nothing)))
  (run core-flag-on)
    (note jexp
      = jexp <cons>
      | jexp <vons>
      | jexp <fons>
      | <string>
      | <jo>)

    (+data <null>)
    (+data <cons> .car .cdr)
    (+data <vons> .var .vdr)
    (+data <fons> .far .fdr)
    (+jojo list-print (-> :l :f --)
      (case :l
        <null> ["null" string-write space]
        <cons> [:l .cdr :f recur
                :l .car :f apply space
                "swap cons" string-write space]))
    (note

      (+var list-0
        null
        1 swap cons
        2 swap cons)

      (run list-0 {int-write} list-print))
    (+jojo read-jexp (-> -- jexp)
      read-jo :jo!
      (cond [:jo round-bar eq?]  [read-jexp/cons]
            [:jo square-bar eq?] [read-jexp/vons]
            [:jo flower-bar eq?] [read-jexp/fons]
            [:jo double-quote eq?] [read-string]
            else [:jo]))

    (+jojo read-jexp/cons
      read-jo :jo!
      (if :jo round-ket eq?
          then null
          else :jo jo-unread read-jexp recur cons))

    (+jojo read-jexp/vons
      read-jo :jo!
      (if :jo round-ket eq?
          then null
          else :jo jo-unread read-jexp recur vons))

    (+jojo read-jexp/fons
      read-jo :jo!
      (if :jo round-ket eq?
          then null
          else :jo jo-unread read-jexp recur fons))
    (+jojo jexp-write (-> :jexp --)
      (case :jexp
        <cons> [round-bar  jo-write space :jexp jexp-write/cons]
        <vons> [square-bar jo-write space :jexp jexp-write/vons]
        <fons> [flower-bar jo-write space :jexp jexp-write/fons]
        <string> [double-quote jo-write
                  :jexp string-write
                  double-quote jo-write
                  space]
        <jo> [:jexp jo-write space]))

    (+jojo jexp-write/cons (-> :l --)
      (case :l
        <null> [round-ket jo-write space]
        <cons> [:l .car jexp-write
                :l .cdr recur]))

    (+jojo jexp-write/vons (-> :l --)
      (case :l
        <null> [square-bar jo-write space]
        <cons> [:l .car jexp-write
                :l .cdr recur]))

    (+jojo jexp-write/fons (-> :l --)
      (case :l
        <null> [flower-bar jo-write space]
        <cons> [:l .car jexp-write
                :l .cdr recur]))
    (+jojo repl
      push-terminal-to-reading-stack
      (if has-jo? not then drop-reading-stack end)
      read-jo :jo!
      (if :jo round-bar eq? then
          read-jo
          round-bar jo-unread read-jexp
          swap jo-apply)
      recur)
    (+jojo echo-jexp (-> :jexp --)
      :jexp jexp-write)
  (run repl)
