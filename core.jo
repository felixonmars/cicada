(defun square (: int int -> int)
  dup mul end)

(run (# 11) square dot)

(defun apply-key (: jo -> *)
  (if dup jo-used? -> apply end)
  (string "undefined keyword : ") print-string
  jo->string print-string end)

(defun stack-repl (: [io] -> *)
  (if read-jo round-bar eq? -> read-jo apply-key print-stack)
  (loop))

(run stack-repl)

(run (if true -> true dot end)
     (if false -> false dot end))

(defun factorial (: int -> int)
  (if dup (# 1) lteq? -> drop (# 1) end)
  dup (# 1) sub (recur) mul end)

(run (# 0) factorial dot
     (# 1) factorial dot
     (# 2) factorial dot
     (# 3) factorial dot
     (# 4) factorial dot)

(run (# 18 5) mod dot)

(run (string "test1" "test2")
     print-string print-string)

(run (string "README")
     (# 1024) allocate tuck
     (# 1024) read-file dot
     print-string)

(run getcwd print-string newline)

(defvar var1 (# 666) (# 666) add)
(run var1 dot)

(run (jo null) jo->string print-string newline)

(defvar cons-size (# 3) cell-size mul)
(defvar cons-area-size (# 5) (: (# 1024 1024) mul) cons-size mul)

(defvar cons-area cons-area-size allocate)
(defvar cons-area-top cons-area cons-area-size add)

(defvar cons-pointer cons-area)

(defvar current-mark (# 1))
(defvar max-mark (# 3))

(defun cons-pointer/next (: -> [cons-pointer])
  cons-size cons-pointer add
  (var cons-pointer) set)

(defun cons-pointer/init (: -> [cons-pointer])
  cons-area
  (var cons-pointer) set)

(defun cons-pointer/next-free (: -> [cons-pointer])
  (if cons-pointer cons-area-top eq? -> end)
  (if cons-pointer get current-mark eq? not -> end)
  cons-pointer/next
  (loop))

(defun cons? (: cell -> bool)
  (if dup cons-area lt? -> drop false end)
  (if dup cons-area-top gteq? -> drop false end)
  cons-area sub cons-size mod (# 0) eq?)

(declare
  (car (: cons -> cell))
  (cdr (: cons -> cell)))

(defun cons-area-report/loop (: cons -> [io])
  (if dup cons-area-top eq? -> drop end)
  (string "#:") print-string
  dup dot
  (string "mark: ") print-string
  dup get dot
  (string "car: ") print-string
  dup car dot
  (string "cdr: ") print-string
  dup cdr dot
  newline
  cons-size add
  (loop))

(defun cons-area-report (: -> [io])
  cons-area cons-area-report/loop)

(defun sweep-cons-area/loop (: cons -> [io])
  (if dup cons-area-top eq? -> drop end)
  dup (# 0)  swap set
  cons-size add
  (loop))

(defun sweep-cons-area (: -> [cons-area])
  cons-area sweep-cons-area/loop)

(defun mark-cons (: cons -> [cons-area])
  (if dup cons? not -> drop end)
  dup current-mark swap set
  dup car mark-cons
  cdr (loop))

(defun mark-cons-area-for-defvar (: defvar-record/addr -> [cons-area])
  (if dup get (# 0) eq? -> drop end)
  dup get mark-cons
  cell-size add
  (loop))

(defun mark-cons-area-for-stack (: stack/addr -> [cons-area])
  (if dup stack-base eq? -> drop end)
  cell-size sub
  dup get mark-cons
  (loop))

(defun mark-cons-area (: -> [cons-area])
  (if current-mark max-mark eq? ->
      sweep-cons-area
      (# 0) (var current-mark) set)
  current-mark (# 1) add (var current-mark) set
  defvar-record mark-cons-area-for-defvar
  stack-pointer
  mark-cons-area-for-stack)

(defun new-cons (: -> cons)
  (if cons-pointer cons-area-top eq? ->
      mark-cons-area
      cons-pointer/init
      cons-pointer/next-free
      (if cons-pointer cons-area-top eq? ->
          (string "fatal error : cons-area is full") print-string
          newline bye)
      (loop))
  (if cons-pointer get current-mark eq? ->
      cons-pointer/next (loop))
  cons-pointer
  cons-pointer/next end)

(defun set-car (: cell cons -> cons)
  tuck
  cell-size add
  set)

(defun set-cdr (: cell cons -> cons)
  tuck
  cell-size add
  cell-size add
  set)

(defun car (: cons -> cell)
  cell-size add
  get)

(defun cdr (: cons -> cell)
  cell-size add
  cell-size add
  get)

(defun cons (: cdr-cell car-cell -> cons)
  new-cons set-car set-cdr)

(: (run (# 0)
        (# 1) cons
        (# 2) cons
        dup car dot
        dup cdr car dot
        dup cdr cdr dot

        dup cons? dot
        dup cdr cons? dot
        dup car cons? dot
        dup cdr car cons? dot
        dup cdr cdr cons? dot
        dot

        current-mark
        dot))

(: (run newline
        new-cons dot
        new-cons dot
        new-cons dot
        new-cons dot
        new-cons dot
        current-mark dot
        newline
        cons-area-report
        newline))

(: {a {b c} d}
   null
   a cons
     null
     b cons
     c cons
   cons
   d cons)

(defun one-list (: [io] -> [compile])
  read-jo
  (if dup flower-bar eq? ->
      drop null here
      (recur) (jo cons) here
      (loop))
  (if dup flower-ket eq? ->
      drop end)
  (if dup round-bar eq? ->
      drop read-jo apply-key
      (jo cons) here
      (loop))
  (else (jo i-lit) here
        here
        (jo cons) here
        (loop)))

(defun list (: [io] -> [compile])
  read-jo
  (if dup round-ket eq? -> drop end)
  (if dup flower-bar eq? ->
      drop null here
      one-list (loop))
  (else drop (loop)))

(run (list {a {b c} d})
     dup car jo->string print-string
     dup cdr car car jo->string print-string
     dup cdr car cdr car jo->string print-string
     dup cdr car cdr cdr jo->string print-string
     dup cdr cdr car jo->string print-string
     dup cdr cdr cdr jo->string print-string
     drop)

(run (list {(# 1) {(# 2) (jojo (# 1 2) add)} (# 4)})
     dup car dot
     dup cdr car car dot
     dup cdr car cdr car dot
     dup cdr car cdr cdr dot
     dup cdr cdr car dot
     dup cdr cdr cdr dot
     drop)

(declare (print-int-list (: cons -> [io])))

(defun print-int-list/rest (: cons -> [io])
  (if dup null eq? -> drop end)
  dup cdr print-int-list/rest
  car
  (if dup cons? -> print-int-list end)
  (else dot end))

(defun print-int-list (: cons -> [io])
  (string "{ ") print-string
  print-int-list/rest
  (string "} ") print-string)

(declare (print-jo-list (: cons -> [io])))

(defun dot-jo (: jo -> [io])
  jo->string print-string
  (string " ") print-string)

(defun print-jo-list/rest (: cons -> [io])
  (if dup null eq? -> drop end)
  dup cdr print-jo-list/rest
  car
  (if dup cons? -> print-jo-list end)
  (else dot-jo end))

(defun print-jo-list (: cons -> [io])
  (string "{ ") print-string
  print-jo-list/rest
  (string "} ") print-string)

(run (list {a {b c} d})
     print-jo-list)

(run (list {(# 1) {(# 2) (jojo (# 1 2) add)} (# 4)})
     print-int-list)

(defvar case-stack (# 1024) cell-size mul allocate)
(defvar case-stack-pointer case-stack)
(defun case-stack-pop (: -> stack/addr)
  case-stack-pointer cell-size sub
  (var case-stack-pointer) set
  case-stack-pointer get)
(defun case-stack-push (: stack/addr ->)
  case-stack-pointer set
  case-stack-pointer cell-size add
  (var case-stack-pointer) set)

(defun one-case (: [io] -> [compile])
  )

(defun case (: [io] -> [compile])
  read-jo
  (if dup round-bar eq? -> one-case (loop))
  (if dup round-ket eq? -> drop end)
  (loop))

(: (run defprim-report
        defun-report
        defvar-report))
