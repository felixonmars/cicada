(defvar cons-size (int 3) cell-size mul)
(defvar cons-area-size
  (: (int 5) (: for testing))
  (int 1024 1024) mul
  cons-size mul)

(defvar cons-area cons-area-size allocate)
(defvar cons-area-top cons-area cons-area-size add)

(defvar cons-pointer cons-area)

(defvar current-mark (int 1))
(defvar max-mark (: (int 3) (: for testing))
        (int 1024 1024) mul)

(defun cons-pointer/next (: -> [cons-pointer])
  cons-size cons-pointer add
  (var cons-pointer) set)

(defun cons-pointer/init (: -> [cons-pointer])
  cons-area
  (var cons-pointer) set)

(defun cons-pointer/next-free (: -> [cons-pointer])
  (if cons-pointer cons-area-top eq? -> end)
  (if cons-pointer get current-mark eq? not -> end)
  cons-pointer/next
  (loop))

(defun cons? (: cell -> bool)
  (if dup cons-area lt? -> drop false end)
  (if dup cons-area-top gteq? -> drop false end)
  cons-area sub cons-size mod (int 0) eq?)

(declare
  (car (: cons -> cell))
  (cdr (: cons -> cell)))

(defun cons-area/report/loop (: cons -> [io])
  (if dup cons-area-top eq? -> drop end)
  (string "#:") string/print
  dup dot
  (string "mark: ") string/print
  dup get dot
  (string "car: ") string/print
  dup car dot
  (string "cdr: ") string/print
  dup cdr dot
  newline
  cons-size add
  (loop))

(defun cons-area/report (: -> [io])
  cons-area cons-area/report/loop)

(defun sweep-cons-area/loop (: cons -> [io])
  (if dup cons-area-top eq? -> drop end)
  dup (int 0)  swap set
  cons-size add
  (loop))

(defun sweep-cons-area (: -> [cons-area])
  cons-area sweep-cons-area/loop)

(defun mark-cons (: cons -> [cons-area])
  (if dup cons? not -> drop end)
  dup current-mark swap set
  dup car mark-cons
  cdr (loop))

(defun mark-cons-area/defvar-record (: defvar-record -> [cons-area])
  (if dup get (int 0) eq? -> drop end)
  dup get mark-cons
  cell-size add
  (loop))

(defun mark-cons-area/argument-stack (: stack -> [cons-area])
  (if dup stack-base eq? -> drop end)
  cell-size sub
  dup get mark-cons
  (loop))

(defun mark-cons-area (: -> [cons-area])
  (if current-mark max-mark eq? ->
      sweep-cons-area
      (int 0) (var current-mark) set)
  current-mark (int 1) add (var current-mark) set
  defvar-record mark-cons-area/defvar-record
  stack-pointer
  mark-cons-area/argument-stack)

(defun new/cons (: -> cons)
  (if cons-pointer cons-area-top eq? ->
      mark-cons-area
      cons-pointer/init
      cons-pointer/next-free
      (if cons-pointer cons-area-top eq? ->
          (string "fatal error : cons-area is full") string/print
          newline bye)
      (loop))
  (if cons-pointer get current-mark eq? ->
      cons-pointer/next (loop))
  cons-pointer
  cons-pointer/next end)

(defun set-car (: cell cons ->)
  cell-size add
  set)

(defun set-cdr (: cell cons ->)
  cell-size add
  cell-size add
  set)

(defun car (: cons -> cell)
  cell-size add
  get)

(defun cdr (: cons -> cell)
  cell-size add
  cell-size add
  get)

(defun cons (: cdr-cell car-cell -> cons)
  new/cons
  tuck set-car
  tuck set-cdr)

(: the following tests are for small cons-area)

(: (test (int 0)
         (int 1) cons
         (int 2) cons
         dup car dot
         dup cdr car dot
         dup cdr cdr dot

         dup cons? dot
         dup cdr cons? dot
         dup car cons? dot
         dup cdr car cons? dot
         dup cdr cdr cons? dot
         dot

         current-mark
         dot))

(: (test newline
         new/cons dot
         new/cons dot
         new/cons dot
         new/cons dot
         new/cons dot
         current-mark dot
         newline
         cons-area/report
         newline))

(: {a {b c} d}
   null
   a cons
   null
   b cons
   c cons
   cons
   d cons)

(defun list/one (: [io] -> [compile])
  read/jo
  (if dup flower-bar eq? ->
      drop null here
      (recur) (jo cons) here
      (loop))
  (if dup flower-ket eq? ->
      drop end)
  (if dup round-bar eq? ->
      drop read/jo key-jo/apply
      (jo cons) here
      (loop))
  (else (jo instruction/lit) here
        here
        (jo cons) here
        (loop)))

(defun list (: [io] -> [compile])
  read/jo
  (if dup round-ket eq? -> drop end)
  (if dup flower-bar eq? ->
      drop null here
      list/one (loop))
  (else drop (loop)))

(test (list {a {b c} d})
      dup car jo->string string/print
      dup cdr car car jo->string string/print
      dup cdr car cdr car jo->string string/print
      dup cdr car cdr cdr jo->string string/print
      dup cdr cdr car jo->string string/print
      dup cdr cdr cdr jo->string string/print
      drop)

(test (list {(int 1) {(int 2) (do (int 1 2) add)} (int 4)})
      dup car dot
      dup cdr car car dot
      dup cdr car cdr car dot
      dup cdr car cdr cdr dot
      dup cdr cdr car dot
      dup cdr cdr cdr dot
      drop)

(defun list/length (: list -> nat)
  (if dup cons? not -> drop (int 0) end)
  (else cdr (recur) (int 1) add end))

(test newline
      (list {a {b c} d}) list/length dot
      newline
      (list {}) list/length dot)

(declare (int-list/print (: cons -> [io])))

(defun int-list/print/rest (: cons -> [io])
  (if dup null eq? -> drop end)
  dup cdr int-list/print/rest
  car
  (if dup cons? -> int-list/print end)
  (else dot end))

(defun int-list/print (: cons -> [io])
  (string "{ ") string/print
  int-list/print/rest
  (string "} ") string/print)

(test (list {(int 1) {(int 2) (do (int 1 2) add)} (int 4)})
      int-list/print)

(defun jo/map (: {... a} (a -> b) -> {... b})
  (if over null eq? -> drop end)
  over car over jo/apply
  (int 2 1) xy-swap
  swap cdr swap (recur)
  swap cons)

(defun jo/itr (: {... a} (a ->) ->)
  (if over null eq? -> drop drop end)
  over car over jo/apply
  swap cdr swap (loop))

(defun add1 (: int -> int)
  (int 1) add)

(test (int 1)
      (jo add1) jo/apply
      dot)

(test (int 1) (int 2) (int 3) (int 4)
      (int 2 1) xy-swap dot dot dot dot)

(test (list {(int 1) (int 2) (int 3) (int 4)})
      (jo add1) jo/map
      int-list/print)

(test (list {(int 1) (int 2) (int 3) (int 4)})
      (jo dot) jo/itr)

(defun map (: {... a} (a -> b) -> {... b})
  (if over null eq? -> drop end)
  over car over apply
  (int 2 1) xy-swap
  swap cdr swap (recur)
  swap cons)

(defun itr (: {... a} (a ->) ->)
  (if over null eq? -> drop drop end)
  over car over apply
  swap cdr swap (loop))

(test (list {(int 1) (int 2) (int 3) (int 4)})
      (jojo (int 1) add) map
      (jojo (int 1) add) map
      (jojo (int 1) add) map
      (jojo (int 1) add) map
      (jojo (int 1) add) map
      int-list/print)

(test (list {(int 1) (int 2) (int 3) (int 4)})
      (jojo dup dot dot) itr)

(defun list/ref (: {... a} int -> a)
  (if dup (int 0) lteq? -> drop car end)
  (else swap cdr swap (int 1) sub (loop)))

(test (list {(int 1) (int 2) (int 3) (int 4)})
      (int 1) list/ref dot)

(defun list/drop (: {... a} nat -> {... a})
  (if dup (int 0) lteq? -> drop end)
  (else swap cdr swap (int 1) sub (loop)))

(defun list/take (: {... a} nat -> {... a})
  (if dup (int 0) lteq? -> drop null end)
  (else over car (int 2 1) xy-swap
        swap cdr swap (int 1) sub (recur)
        swap cons end))

(declare (jo-list/print (: cons -> [io])))

(defun jo-list/print/rest (: cons -> [io])
  (if dup null eq? -> drop end)
  dup cdr jo-list/print/rest
  car
  (if dup cons? -> jo-list/print end)
  (else jo/dot end))

(defun jo-list/print (: cons -> [io])
  (string "{ ") string/print
  jo-list/print/rest
  (string "} ") string/print)

(test (list {a {b c} d})
      jo-list/print)

(declare (string-list/print (: cons -> [io])))

(defun string-list/print/rest (: cons -> [io])
  (if dup null eq? -> drop end)
  dup cdr string-list/print/rest
  car
  (if dup cons? -> string-list/print end)
  (else string/dot end))

(defun string-list/print (: cons -> [io])
  (string "{ ") string/print
  string-list/print/rest
  (string "} ") string/print)

(test (list {(string "111") {(string "222") (string "333")} (string "444")})
      string-list/print)
