(defun case/one (: [io] back-place -> [compile])
  (> back-place)
  (jo dup) here
  (jo ->) compile-jojo/until-meet-jo
  (jo eq?) here
  (jo instruction/jump-if-false) here
  compiling-stack/tos (> place) compiling-stack/inc
  (jo drop) here
  square-ket compile-jojo/until-meet-jo
  (jo instruction/jump) here
  (< back-place) here
  compiling-stack/tos (< place) set)

(defun case/loop (: [io] back-place -> [compile])
  read/jo
  (if dup round-ket eq? -> drop drop end)
  (if dup round-bar eq? -> drop read/jo key-jo/apply (loop))
  (if dup square-bar eq? -> drop dup case/one (loop))
  here (loop))

(defun case (: [io] -> [compile])
  (jo instruction/jump) here
  compiling-stack/tos (> place0) compiling-stack/inc
  compiling-stack/tos (> back-place)
  (jo instruction/jump) here
  compiling-stack/tos (> place1) compiling-stack/inc
  compiling-stack/tos (< place0) set
  (< back-place) case/loop
  compiling-stack/tos (< place1) set)

(: (test
     (jo a)
     (case
       [(jo a) -> (string "a") string/print newline]
       (: comment)
       (string "between a & b") string/print newline
       [(jo b) -> (string "b") string/print newline]))

   (test
     (jo b)
     (case
       [(jo a) -> (string "a") string/print newline]
       [(jo b) -> (string "b") string/print newline]))

   (test
     (jo b)
     (case
       [(jo a) ->
        (string "a") string/print
        (jo b) (case
                 [(jo a) -> (string "a") string/print newline]
                 [(jo b) -> (string "b") string/print newline])]
       [(jo b) -> (string "b") string/print newline])))
