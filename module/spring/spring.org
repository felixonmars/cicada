#+PROPERTY: tangle spring.jo
#+title: spring

* todo

  - optimize line-mode/view
  - use list/take

* line-mode

*** line-mode

    #+begin_src jojo
    (: line {... char})
    (: currently char is utf8-jo
       to use jo is to waste jotable
       need better design for this)

    (: line-mode {{... line} base cursor})
    (: base {x y})
    (: cursor {x y})

    (defun line-mode/cursor    (: line-mode -> point) car)
    (defun line-mode/base      (: line-mode -> point) cdr car)
    (defun line-mode/line-list (: line-mode -> {... line}) cdr cdr car)

    (defun line-mode/set-cursor    (: point line-mode ->) set-car)
    (defun line-mode/set-base      (: point line-mode ->) cdr set-car)
    (defun line-mode/set-line-list (: {... line} line-mode ->) cdr cdr set-car)

    (defun point/y (: point -> int) car)
    (defun point/x (: point -> int) cdr car)

    (defun point/set-y (: int point ->) set-car)
    (defun point/set-x (: int point ->) cdr set-car)

    (defun make/point (: int int -> point)
      swap null swap cons swap cons)

    (defun line-mode/current-line (: line-mode -> line)
      dup line-mode/line-list
      swap line-mode/cursor point/y
      list/ref)

    (defun make/line-mode (: {... line} -> line-mode)
      null swap cons
      (int 0 0) make/point cons
      (int 0 0) make/point cons)
    #+end_src

*** buffer->string-list

    #+begin_src jojo
    (defun buffer->string-list/cursor (: buffer cursor -> {... string})
      (if dup get-byte (int 0) eq? ->
          drop null swap cons end)
      (if dup get-byte (int 10) eq? ->
          (: buffer cursor) dup (int 0) swap set-byte (int 1) add dup
          (: buffer cursor cursor) (recur)
          (: buffer {... string}) swap cons end)
      (else (int 1) add
            (loop)))

    (defun buffer->string-list (: buffer -> {... string})
      dup buffer->string-list/cursor)
    #+end_src

*** string->line

    #+begin_src jojo
    (defun string/empty? (: string -> bool)
      get-byte (int 0) eq?)

    (: utf8
       1 0xxxxxxx
       2 110xxxxx 10xxxxxx
       3 1110xxxx 10xxxxxx 10xxxxxx
       4 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
       5 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
       6 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx)


    (defun char->length (: char -> length)
      (if dup (bin 10000000) bit/and (bin 00000000) eq? -> drop (int 1) end)
      (if dup (bin 11100000) bit/and (bin 11000000) eq? -> drop (int 2) end)
      (if dup (bin 11110000) bit/and (bin 11100000) eq? -> drop (int 3) end)
      (if dup (bin 11111000) bit/and (bin 11110000) eq? -> drop (int 4) end)
      (if dup (bin 11111100) bit/and (bin 11111000) eq? -> drop (int 5) end)
      (if dup (bin 11111110) bit/and (bin 11111100) eq? -> drop (int 6) end)
      (else drop (int 0) end))

    (defun next-char (: string -> rest-string char)
      dup get-byte char->length
      (if dup (int 0) eq? -> drop (int 1) add (loop))
      (else over over string/length->jo (int 2 1) xy-swap
            add swap end))

    (defun string->char-list (: string -> {... char})
      (if dup string/empty? -> drop null end)
      next-char swap (recur) swap cons)

    (defun string->line (: string -> line)
      string->char-list)
    #+end_src

*** parse/line-mode

    #+begin_src jojo
    (defvar line-mode/buffer-size (int 1024 1024) mul)

    (defun parse/line-mode (: file -> line-mode)
      (: file) line-mode/buffer-size allocate tuck
      (: buffer file buffer) file/copy-to-buffer drop dup
      (: buffer buffer) buffer->string-list
      (: buffer {... string}) (jojo string->line) map
      (: buffer {... line}) swap free
      (: {... line}) make/line-mode)
    #+end_src

*** line-mode/print

    #+begin_src jojo
    (defun line/print (: line -> [io])
      (jojo jo/print) itr newline)

    (defun line-mode/print (: line-mode -> [io])
      line-mode/line-list (jojo line/print) itr)
    #+end_src

*** test

    #+begin_src jojo
    (test (string "cn中文")
          next-char dup jo/dot swap
          next-char dup jo/dot swap
          next-char dup jo/dot swap
          next-char dup jo/dot swap
          drop
          newline)

    (test (string "module.jo") parse/line-mode line-mode/print)
    #+end_src

*** line-mode/adjust-base

    #+begin_src jojo
    (defun point/sub (: point point -> point)
      over over
      point/x swap point/x swap
      sub
      (int 2 1) xy-swap
      point/y swap point/y swap
      sub
      make/point)

    (defun point/add (: point point -> point)
      over over
      point/x swap point/x swap
      add
      (int 2 1) xy-swap
      point/y swap point/y swap
      add
      make/point)

    (defun line-mode/relative-cursor (: line-mode -> point)
      dup line-mode/base
      swap line-mode/cursor
      point/sub)

    (defun line-mode/adjust-base (: line-mode ->)
      (: to keep cursor in window)
      dup line-mode/relative-cursor
      (if dup point/x
          x-border (int 1) sub
          gt? ->
          dup point/x
          x-border (int 1) sub
          sub (int 2 1) xy-swap)
      (else (int 0) (int 2 1) xy-swap)
      (if dup point/y
          y-border (int 1) sub
          gt? ->
          dup point/y
          y-border (int 1) sub
          sub (int 2 1) xy-swap)
      (else (int 0) (int 2 1) xy-swap)
      drop
      (int 2 1) xy-swap make/point
      over line-mode/base point/add
      swap line-mode/set-base)
    #+end_src

*** line-mode/view

    #+begin_src jojo
    (defun line/draw-by-base (: line x-nat -> [window])
      (if over list/length over lteq? -> drop drop (int 10) byte/draw end)
      list/drop (jojo jo->string string/draw) itr
      (int 10) byte/draw end)

    (defun pre/line/draw-by-base (: {... line} point -> line x-nat)
      tuck point/y list/ref
      swap point/x)

    (defun line-mode/view/content/loop (: {... line} point -> [window])
      (if over over point/y swap list/length gteq? -> drop drop end)
      over over pre/line/draw-by-base line/draw-by-base
      dup point/y (int 1) add
      over point/set-y
      (loop))

    (defun line-mode/view/content (: line-mode -> [window])
      dup line-mode/line-list
      swap line-mode/base
      line-mode/view/content/loop)

    (defun line-mode/view/cursor (: line-mode -> [window])
      line-mode/cursor
      dup point/x set-x-cursor
      point/y set-y-cursor)

    (defun line-mode/view (: line-mode -> [window])
      dup line-mode/adjust-base
      dup line-mode/view/content
      line-mode/view/cursor
      text-ui/refresh)
    #+end_src

* >< undo-stack

  - every editing function should be reversible
    a record of editing functions help undo

  #+begin_src jojo
  (: (defvar undo-stack ))
  #+end_src
