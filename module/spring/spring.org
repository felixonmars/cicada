#+PROPERTY: tangle spring.jo
#+title: spring

* todo

  - optimize line-mode/view
  - use list/take

* line-mode

*** line-mode

    #+begin_src jojo
    (: line {... char})
    (: currently char is utf8-jo
       to use jo is to waste jotable
       need better design for this)

    (: line-mode {{... line} base cursor})
    (: base {x y})
    (: cursor {x y})

    (defun line-mode/cursor    (: line-mode -> point) car)
    (defun line-mode/base      (: line-mode -> point) cdr car)
    (defun line-mode/line-list (: line-mode -> {... line}) cdr cdr car)

    (defun line-mode/set-cursor    (: point line-mode ->) set-car)
    (defun line-mode/set-base      (: point line-mode ->) cdr set-car)
    (defun line-mode/set-line-list (: {... line} line-mode ->) cdr cdr set-car)

    (defun point/y (: point -> int) car)
    (defun point/x (: point -> int) cdr car)

    (defun point/set-y (: int point ->) set-car)
    (defun point/set-x (: int point ->) cdr set-car)

    (defun make/point (: int int -> point)
      swap null swap cons swap cons)

    (defun line-mode/current-line (: line-mode -> line)
      dup line-mode/line-list
      swap line-mode/cursor point/y
      list/ref)

    (defun make/line-mode (: {... line} -> line-mode)
      null swap cons
      (int 0 0) make/point cons
      (int 0 0) make/point cons)
    #+end_src

*** buffer->string-list

    #+begin_src jojo
    (defun buffer->string-list/cursor (: buffer cursor -> {... string})
      (if dup get-byte (int 0) eq? ->
          drop null swap cons end)
      (if dup get-byte (int 10) eq? ->
          (: buffer cursor) dup (int 0) swap set-byte (int 1) add dup
          (: buffer cursor cursor) (recur)
          (: buffer {... string}) swap cons end)
      (else (int 1) add
            (loop)))

    (defun buffer->string-list (: buffer -> {... string})
      dup buffer->string-list/cursor)
    #+end_src

*** string->line

    #+begin_src jojo
    (defun string/empty? (: string -> bool)
      get-byte (int 0) eq?)

    (: utf8
       1 0xxxxxxx
       2 110xxxxx 10xxxxxx
       3 1110xxxx 10xxxxxx 10xxxxxx
       4 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
       5 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
       6 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx)


    (defun char->length (: char -> length)
      (if dup (bin 10000000) bit/and (bin 00000000) eq? -> drop (int 1) end)
      (if dup (bin 11100000) bit/and (bin 11000000) eq? -> drop (int 2) end)
      (if dup (bin 11110000) bit/and (bin 11100000) eq? -> drop (int 3) end)
      (if dup (bin 11111000) bit/and (bin 11110000) eq? -> drop (int 4) end)
      (if dup (bin 11111100) bit/and (bin 11111000) eq? -> drop (int 5) end)
      (if dup (bin 11111110) bit/and (bin 11111100) eq? -> drop (int 6) end)
      (else drop (int 0) end))

    (defun next-char (: string -> rest-string char)
      dup get-byte char->length
      (if dup (int 0) eq? -> drop (int 1) add (loop))
      (else over over string/length->jo (int 2 1) xy-swap
            add swap end))

    (defun string->char-list (: string -> {... char})
      (if dup string/empty? -> drop null end)
      next-char swap (recur) swap cons)

    (defun string->line (: string -> line)
      string->char-list)
    #+end_src

*** parse/line-mode

    #+begin_src jojo
    (defvar line-mode/buffer-size (int 1024 1024) mul)

    (defun parse/line-mode (: file -> line-mode)
      (: file) line-mode/buffer-size allocate tuck
      (: buffer file buffer) file/copy-to-buffer drop dup
      (: buffer buffer) buffer->string-list
      (: buffer {... string}) (jojo string->line) map
      (: buffer {... line}) swap free
      (: {... line}) make/line-mode)
    #+end_src

*** line-mode/print

    #+begin_src jojo
    (defun line/print (: line -> [io])
      (jojo jo/print) itr newline)

    (defun line-mode/print (: line-mode -> [io])
      line-mode/line-list (jojo line/print) itr)
    #+end_src

*** test

    #+begin_src jojo
    (test (string "cn中文")
          next-char dup jo/dot swap
          next-char dup jo/dot swap
          next-char dup jo/dot swap
          next-char dup jo/dot swap
          drop
          newline)

    (test (string "module.jo") parse/line-mode line-mode/print)
    #+end_src

*** line-mode/adjust-base

    #+begin_src jojo
    (defun point/sub (: point point -> point)
      over over
      point/x swap point/x swap
      sub
      (int 2 1) xy-swap
      point/y swap point/y swap
      sub
      make/point)

    (defun point/add (: point point -> point)
      over over
      point/x swap point/x swap
      add
      (int 2 1) xy-swap
      point/y swap point/y swap
      add
      make/point)

    (defun line-mode/relative-cursor (: line-mode -> point)
      dup line-mode/base
      swap line-mode/cursor
      point/sub)

    (defun line-mode/adjust-base (: line-mode ->)
      (: to keep cursor in window)
      dup line-mode/relative-cursor
      (if dup point/x
          x-border (int 1) sub
          gt? ->
          dup point/x
          x-border (int 1) sub
          sub (int 2 1) xy-swap)
      (else (int 0) (int 2 1) xy-swap)
      (if dup point/y
          y-border (int 1) sub
          gt? ->
          dup point/y
          y-border (int 1) sub
          sub (int 2 1) xy-swap)
      (else (int 0) (int 2 1) xy-swap)
      drop
      (int 2 1) xy-swap make/point
      over line-mode/base point/add
      swap line-mode/set-base)
    #+end_src

*** line-mode/view

    #+begin_src jojo
    (defun line/draw-by-base (: line x-nat -> [window])
      (if over list/length over lteq? -> drop drop (int 10) byte/draw end)
      list/drop (jojo jo->string string/draw) itr
      (int 10) byte/draw end)

    (defun pre/line/draw-by-base (: {... line} point -> line x-nat)
      tuck point/y list/ref
      swap point/x)

    (defun line-mode/view/content/loop (: {... line} point -> [window])
      (if over over point/y swap list/length gteq? -> drop drop end)
      over over pre/line/draw-by-base line/draw-by-base
      dup point/y (int 1) add
      over point/set-y
      (loop))

    (defun line-mode/view/content (: line-mode -> [window])
      dup line-mode/line-list
      swap line-mode/base
      line-mode/view/content/loop)

    (defun line-mode/view/cursor (: line-mode -> [window])
      line-mode/cursor
      dup point/x set-x-cursor
      point/y set-y-cursor)

    (defun line-mode/view (: line-mode -> [window])
      dup line-mode/adjust-base
      dup line-mode/view/content
      line-mode/view/cursor
      text-ui/refresh)
    #+end_src

*** note key

    - input is limited by term-ui
    - key-binding is actually byte-binding
      <esc> is ignored
    - the only modkey is ctrl

*** byte->key

    #+begin_src jojo
    (defun key jo)

    (defun key->byte (: key -> byte)
      )

    (defun byte->key (: byte -> key)
      (case
        [(hex 00) -> (jo C-@)]
        [(hex 01) -> (jo C-A)]
        [(hex 02) -> (jo C-B)]
        [(hex 03) -> (jo C-C)]
        [(hex 04) -> (jo C-D)]
        [(hex 05) -> (jo C-E)]
        [(hex 06) -> (jo C-F)]
        [(hex 07) -> (jo C-G)]
        [(hex 08) -> (jo C-H)]
        [(hex 09) -> (jo C-I)]
        [(hex 0A) -> (jo C-J)]
        [(hex 0B) -> (jo C-K)]
        [(hex 0C) -> (jo C-L)]
        [(hex 0D) -> (jo C-M)]
        [(hex 0E) -> (jo C-N)]
        [(hex 0F) -> (jo C-O)]
        [(hex 10) -> (jo C-P)]
        [(hex 11) -> (jo C-Q)]
        [(hex 12) -> (jo C-R)]
        [(hex 13) -> (jo C-S)]
        [(hex 14) -> (jo C-T)]
        [(hex 15) -> (jo C-U)]
        [(hex 16) -> (jo C-V)]
        [(hex 17) -> (jo C-W)]
        [(hex 18) -> (jo C-X)]
        [(hex 19) -> (jo C-Y)]
        [(hex 1A) -> (jo C-Z)]
        [(hex 1B) -> (jo C-square-bar)]
        [(hex 1C) -> (jo C-backslash)]
        [(hex 1D) -> (jo C-square-ket)]
        [(hex 1E) -> (jo C-^)]
        [(hex 1F) -> (jo C-_)]
        [(hex 7F) -> (jo C-?)]
        [(hex 20) -> (jo whitespace)]
        [(hex 21) -> (jo !)]
        [(hex 22) -> (jo double-quote)]
        [(hex 23) -> (jo #)]
        [(hex 24) -> (jo $)]
        [(hex 25) -> (jo %)]
        [(hex 26) -> (jo &)]
        [(hex 27) -> (jo ')]
        [(hex 28) -> round-bar]
        [(hex 29) -> round-ket]
        [(hex 2A) -> (jo *)]
        [(hex 2B) -> (jo +)]
        [(hex 2C) -> (jo ,)]
        [(hex 2D) -> (jo -)]
        [(hex 2E) -> (jo .)]
        [(hex 2F) -> (jo /)]
        [(hex 30) -> (jo 0)]
        [(hex 31) -> (jo 1)]
        [(hex 32) -> (jo 2)]
        [(hex 33) -> (jo 3)]
        [(hex 34) -> (jo 4)]
        [(hex 35) -> (jo 5)]
        [(hex 36) -> (jo 6)]
        [(hex 37) -> (jo 7)]
        [(hex 38) -> (jo 8)]
        [(hex 39) -> (jo 9)]
        [(hex 3A) -> (jo :)]
        [(hex 3B) -> (jo ;)]
        [(hex 3C) -> (jo <)]
        [(hex 3D) -> (jo =)]
        [(hex 3E) -> (jo >)]
        [(hex 3F) -> (jo ?)]
        [(hex 40) -> (jo @)]
        [(hex 41) -> (jo A)]
        [(hex 42) -> (jo B)]
        [(hex 43) -> (jo C)]
        [(hex 44) -> (jo D)]
        [(hex 45) -> (jo E)]
        [(hex 46) -> (jo F)]
        [(hex 47) -> (jo G)]
        [(hex 48) -> (jo H)]
        [(hex 49) -> (jo I)]
        [(hex 4A) -> (jo J)]
        [(hex 4B) -> (jo K)]
        [(hex 4C) -> (jo L)]
        [(hex 4D) -> (jo M)]
        [(hex 4E) -> (jo N)]
        [(hex 4F) -> (jo O)]
        [(hex 50) -> (jo P)]
        [(hex 51) -> (jo Q)]
        [(hex 52) -> (jo R)]
        [(hex 53) -> (jo S)]
        [(hex 54) -> (jo T)]
        [(hex 55) -> (jo U)]
        [(hex 56) -> (jo V)]
        [(hex 57) -> (jo W)]
        [(hex 58) -> (jo X)]
        [(hex 59) -> (jo Y)]
        [(hex 5A) -> (jo Z)]
        [(hex 5B) -> square-bar]
        [(hex 5C) -> backslash]
        [(hex 5D) -> square-ket]
        [(hex 5E) -> (jo ^)]
        [(hex 5F) -> (jo _)]
        [(hex 60) -> (jo `)]
        [(hex 61) -> (jo a)]
        [(hex 62) -> (jo b)]
        [(hex 63) -> (jo c)]
        [(hex 64) -> (jo d)]
        [(hex 65) -> (jo e)]
        [(hex 66) -> (jo f)]
        [(hex 67) -> (jo g)]
        [(hex 68) -> (jo h)]
        [(hex 69) -> (jo i)]
        [(hex 6A) -> (jo j)]
        [(hex 6B) -> (jo k)]
        [(hex 6C) -> (jo l)]
        [(hex 6D) -> (jo m)]
        [(hex 6E) -> (jo n)]
        [(hex 6F) -> (jo o)]
        [(hex 70) -> (jo p)]
        [(hex 71) -> (jo q)]
        [(hex 72) -> (jo r)]
        [(hex 73) -> (jo s)]
        [(hex 74) -> (jo t)]
        [(hex 75) -> (jo u)]
        [(hex 76) -> (jo v)]
        [(hex 77) -> (jo w)]
        [(hex 78) -> (jo x)]
        [(hex 79) -> (jo y)]
        [(hex 7A) -> (jo z)]
        [(hex 7B) -> flower-bar]
        [(hex 7C) -> (jo |)]
        [(hex 7D) -> flower-ket]
        [(hex 7E) -> (jo ~)])
      drop (jo unknow))
    #+end_src

*** receive/key

    #+begin_src jojo
    (defun receive/key (: [io] -> key)
      )
    #+end_src

*** key/bind

    #+begin_src jojo
    (defun key/bind (: ->))
    #+end_src

*** key->editing-function

    #+begin_src jojo
    (defun key->editing-function (: ->))
    #+end_src

* >< undo-stack

  - every editing function should be reversible
    a record of editing functions help undo

  #+begin_src jojo
  (: (defvar undo-stack ))
  #+end_src
