(defun compile-with/jump-if-false (note * -> *)
  (> j)
  (jo instruction/jump-if-false) here
  compiling-stack/tos (> place) compiling-stack/inc
  (< j) apply
  compiling-stack/tos (< place) set)

(defun case/one (note [io] back-place -> [compile])
  (jo dup) here
  (jo ->) compile-jojo/until-meet-jo
  (jo eq?) here
  (jojo (jo drop) here
        square-ket compile-jojo/until-meet-jo
        (jo instruction/jump) here
        (note back-place) here)
  compile-with/jump-if-false)

(note (defun case/one (note [io] back-place -> [compile])
     (> back-place)
     (jo dup) here
     (jo ->) compile-jojo/until-meet-jo
     (jo eq?) here
     (jo instruction/jump-if-false) here
     compiling-stack/tos (> place) compiling-stack/inc
     (jo drop) here
     square-ket compile-jojo/until-meet-jo
     (jo instruction/jump) here
     (< back-place) here
     compiling-stack/tos (< place) set))

(defun case/loop (note [io] back-place -> [compile])
  read/jo
  (if dup round-ket eq? then drop drop end)
  (if dup round-bar eq? then drop read/jo key-jo/apply (loop))
  (if dup square-bar eq? then drop dup case/one (loop))
  here (loop))

(defun case (note [io] -> [compile])
  (jo instruction/jump) here
  compiling-stack/tos (> place0) compiling-stack/inc
  compiling-stack/tos (> back-place)
  (jo instruction/jump) here
  compiling-stack/tos (> place1) compiling-stack/inc
  compiling-stack/tos (< place0) set
  (< back-place) case/loop
  compiling-stack/tos (< place1) set)

(note (test
     (jo a)
     (case
       [(jo a) -> (string "a") string/print newline]
       (note comment)
       (string "between a & b") string/print newline
       [(jo b) -> (string "b") string/print newline]))

   (test
     (jo b)
     (case
       [(jo a) -> (string "a") string/print newline]
       [(jo b) -> (string "b") string/print newline]))

   (test
     (jo b)
     (case
       [(jo a) ->
        (string "a") string/print
        (jo b) (case
                 [(jo a) -> (string "a") string/print newline]
                 [(jo b) -> (string "b") string/print newline])]
       [(jo b) -> (string "b") string/print newline])))
