* object

*** note

    #+begin_src jojo
    (note class is also an object
          we can send new to it)

    (note under <class-name> we have
          method-record
          [method-record alone for now])

    (note object = <class-name> <data> cons)

    (note when defining a class
          different interface-generator can be used to generate method list
          for example
          inherit
          low level array like data with free
          - free must free everything
          high level list list data using gc)

    (note when using defmethod
          a function can assuming certain named local points
          such as self)
    #+end_src

*** class

    #+begin_src jojo
    (def empty-class
      (list))
    #+end_src

*** defmethod

    #+begin_src jojo
    (def new/method (note method/body method/name -> method) (jojo cons))
    (def method/name (jojo car))
    (def method/body (jojo cdr))

    (def defmethod
      (note (defmethod <class-name> <method-name> ...)
            =>
            (jojo ...) (jo <method-name>) new/method
            <class-name> swap cons
            (var <class-name>) set)
      (jojo
        read/jo (>> class-name)
        read/jo (>> method-name)

        address-of-here (>> jojo)
        compile-jojo
        (jo end) here

        (<< class-name) jo-as-var get
        (<< jojo) (<< method-name) new/method
        cons

        (<< class-name) jo-as-var set))
    #+end_src

*** send

    #+begin_src jojo
    (def object/class-name (jojo cdr))
    (def object/data (jojo car))
    (def object/method-record (jojo object/class-name jo/apply))

    (defun method-record/search
      (note message method-record -> (or method false))
      (jojo
       (if dup null eq? then
           drop drop false end)
       (if over over car method/name eq? then
           swap drop car method/body end)
       cdr (loop)))

    (defun send
      (note object message -> [depends on object and message])
      (jojo
       (>> message)
       (>> object)
       (<< message)
       (<< object)
       object/method-record
       method-record/search
       (if dup false eq? not then
           (<< object) (jo self) apply-with-local-binding end)
       (string "can not find message : ") string/print
       (<< message) jo/print newline
       (string "object/class-name : ") string/print
       (<< object) object/class-name jo/print newline))

    (def ::
      (note (:: message ...)
            =>
            (>> object) (jojo ...) apply
            (<< object) (jo message) send)

      (jojo
       read/jo (>> message)
       generate-jo (>> object-jo)

       (jo instruction/lit) here
       (<< object-jo) here
       (jo local-in) here

       jojo (jo apply) here

       (jo instruction/lit) here
       (<< object-jo) here
       (jo local-out) here

       (jo instruction/lit) here
       (<< message) here
       (jo send) here))
    #+end_src

*** test

    #+begin_src jojo
    (def person empty-class)

    (def new/person
      (jojo (jo person) (int 13) cons))

    (defmethod person print-age
      (jojo (<< self) car dot))

    (run
      new/person (:: print-age))
    #+end_src
