* file

  #+begin_src jojo
  (note

    (define-class <file>
      (method
        (* close)))

    (add-method <path> open-for-reading
      (< self) string/open-for-reading)

    (add-method <path> (: open-for: flags)
      (note fd = open(pathname, flags, mode)
            if the file doesn’t exist,
            open() may create it,
            depending on the settings of the flags bitmask argument.
            the flags argument also specifies
            whether the file is to be opened for reading, writing, or both.))

    (add-method <path> (: open-for: flags with: mode)
      (note the mode argument specifies the permissions
            to be placed on the file if it is created by this call.
            If the open() call is not being used to create a file,
            this argument is ignored and can be omitted))

    (note numread = read(fd, buffer, count)
          reads at most count bytes from the open file
          referred to by fd and stores them in buffer.
          The read() call returns the number of bytes actually read.
          If no further bytes could be read
          (i.e., end-of-file was encountered),
          read() returns 0.)

    (note numwritten = write(fd, buffer, count)
          writes up to count bytes from buffer to the open file
          referred to by fd.
          The write() call returns the number of bytes actually written,
          which may be less than count.)

    (note status = close(fd)
          is called after all I/O has been completed,
          in order to release the file descriptor fd
          and its associated kernel resources.))
  #+end_src

* note

  - x -
    我們應該如何設計 file 有關的底層的 io 操作 ?
    我能想到兩種方法
    1. 直接把 unix 的 file io 函數暴露到 jojo 中
    2. 簡化 unix 的 file io

  - k -
    你還是難以忍受這些 c 函數 ?
    也許現在是面對這些東西的瑣碎細節的時候了

  - x -
    我不忍受這些瑣碎的細節
    我決定簡化它
    需要的時候再用一個 oo module 實現更複雜的 <file>
