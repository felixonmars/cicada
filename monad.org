#+property: tangle monad.jo
#+title: monad

* [note]

*** bind and compose can implement each ohter

    #+begin_src jojo
    (note

      (+jojo bind
        (-> (: :1m [:<1> <monad>])
            (: :1-2m (-> :<1> -- :<2> <monad>))
         -- (: :2m [:<2> <monad>]))
        dummy {drop :1m} :1-2m compose apply)

      (+jojo compose
        (-> (: :0-1m (-> :<0> -- :<1> <monad>))
            (: :1-2m (-> :<1> -- :<2> <monad>))
         -- (: :0-2m (-> :<0> -- :<2> <monad>)))
        {:0-1m apply :1-2m bind}))
    #+end_src

* tree

  #+begin_src jojo
  (+data <leaf> .v)
  (+data <node> .l .r)
  #+end_src

* tree-write

  #+begin_src jojo
  (+jojo tree-write (-> :tree :fun --)
    (case :tree
      <leaf> [:tree .v :fun apply "leaf" string-write space]
      <node> [:tree .l :fun recur
              :tree .r :fun recur "node" string-write space]))
  #+end_src

* tree-map

  #+begin_src jojo
  (+jojo tree-map (-> :tree :fun -- tree)
    (case :tree
      <leaf> [:tree .v :fun apply leaf]
      <node> [:tree .l :fun recur
              :tree .r :fun recur node]))
  #+end_src

* [test]

  #+begin_src jojo
  (test

    (+jojo tree-1
      1 leaf 2 leaf node
      3 leaf 4 leaf node
      5 leaf node
      node)

    (run tree-1
      {100 add} tree-map
      {int-write space} tree-write))
  #+end_src

* maybe monad

  #+begin_src jojo
  (+data <nothing>)
  (+data <just> .v)
  #+end_src

* tree-zip -- maybe monad

  #+begin_src jojo
  (+jojo return-maybe just)

  (+jojo bind-maybe (-> :m :v->m -- maybe)
    (case :m
      <nothing> nothing
      <just> [:m .v :v->m apply]))

  (+jojo tree-zip (-> :t1 :t2 -- tree maybe)
    (cond
      [:t1 leaf? :t2 leaf? and]
      [:t1 .v :t2 .v cons leaf return-maybe]

      [:t1 node? :t2 node? and]
      [:t1 .l :t2 .l tree-zip
       {:l! :t1 .r :t2 .r tree-zip
        {:r! :l :r node return-maybe}
        bind-maybe}
       bind-maybe]

      else nothing))

  (note
    (+jojo tree-zip (-> :t1 :t2 -- tree maybe)
      (cond
        [:t1 leaf? :t2 leaf? and]
        [:t1 .v :t2 .v cons leaf return-maybe]

        [:t1 node? :t2 node? and]
        (let-bind bind-maybe
          :l [:t1 .l :t2 .l tree-zip]
          :r [:t1 .r :t2 .r tree-zip]
          [:l :r node return-maybe])

        else nothing)))

  (note
    (+jojo tree-zip (-> :t1 :t2 -- tree maybe)
      (case [:t1 :t2]
        <leaf> <leaf> [:t1 .v :t2 .v cons leaf return-maybe]
        <node> <node> (let-bind bind-maybe
                        :l [:t1 .l :t2 .l tree-zip]
                        :r [:t1 .r :t2 .r tree-zip]
                        [:l :r node return-maybe])
        else nothing)))
  #+end_src

* [test]

  #+begin_src jojo
  (+jojo maybe-write (-> :m :f --)
    (case :m
      <nothing> ['nothing jo-write space]
      <just> [:m .v :f apply 'just jo-write space]))

  (+jojo tree-maybe-write
    {{dup .cdr int-write space
      .car int-write space
      "cons" string-write space}
     tree-write}
    maybe-write)

  (+jojo tree-2
    1 leaf 2 leaf node
    3 leaf 4 leaf node
    5 leaf node
    node)

  (run tree-2 dup
    tree-zip tree-maybe-write)

  (run tree-2 1 leaf
    tree-zip tree-maybe-write)
  #+end_src

* >< number-tree/m -- state monad

* number-tree -- intrinsic state monad

  #+begin_src jojo
  (+jojo number-tree (-> number, :tree -- number, tree)
    (case :tree
      <leaf> [dup inc swap leaf]
      <node> [:tree .l recur :l!
              :tree .r recur :r!
              :l :r node]))
  #+end_src

* [test]

  #+begin_src jojo
  (test

    (+jojo tree-2
      "1" leaf "2" leaf node
      "3" leaf "4" leaf node
      "5" leaf node
      node)

    (run
      tree-2
      0 swap number-tree
      swap drop
      {int-write space} tree-write newline))
  #+end_src

* >< list -- monad

  #+begin_src jojo
  (note
    (+jojo return-list)
    (+jojo bind-list))
  #+end_src
