#+property: tangle basic.jo
#+title: basic

* [todo-stack]

*** dynamic scope and moand interface

    - example
      #+begin_src jojo :tangle no
      (+jojo zip-tree :t1! :t2!
        (note [tree tree] -> [maybe-tree])
        (cond [:t1 leaf? :t2 leaf? and]
              [:t1 .v :t2 .v cons leaf return-maybe]
              [:t1 node? :t2 node? and]
              [(% :t1 .l :t2 .l zip-tree) :l!
               (% :t1 .r :t2 .r zip-tree) :r!
               (% :l :r node return-maybe)]
              else nothing))

      (% (% :t1 .l :t2 .l zip-tree) (% :l!)
         (% :t1 .r :t2 .r zip-tree) (% :r!)
         (% (dynamic :l) (dynamic :r) node return-maybe))
      apply-into-stack


      (+jojo bind-trivial :rest! :binder! :m!
        (% :m apply
           :binder binder-apply
           :rest apply))
      #+end_src

    - 爲甚用 compose 來複合 closure 不能達到所需要的效果 ?

    - to form a new monad interface
      we also need to handle a list of closure

      - (let-bind) as interface to monad

    - 一個 dynamic scope 的 block
      其 dynamic free variable 可以被看成是 有名參數

    - learn more about monad by
      1. inline monads
      2. uncurry functions

    - and test closure by more examples
      such as 'counter'

*** dynamic scope

    - function with effect on tos of global stack
      can be replaced by dynamic scoped variable in function ?

*** about closure

    - to catch unnamed data into returned closure

*** about not dynamic dispatch

    - 因爲沒有 dispatch
      所以當一個函數需要多一個參數才能正常行爲的時候
      就多傳遞一個參數
      - 不要改變大的設計 而是在 closure 中提供 dynamic variable 語法

*** about algebraic data type

    - 沒有構造子的
      type-alias of sumtype
      type-alias of function type
      可以使得函數總是能作用與它可以所用於的類型
      但是這可能並不是想要的性狀
      因爲 即便是可以作用 也不想作用 而是要做更細緻的限制

    - 也許對於動態語言來說
      簡化的用法是合理的

*** syntax macro

    - syntax macro
      - the interface of monad needs nested closure
        this can not be abstracted by combinator
        this can only be abstracted by syntax macro

    - syntax for curry
      - prefix or postfix ?
      - from which side of the arguments ?
      - prefix from left side of the arguments
        will bring prefix notation back
      - prefix from right side of the arguments
        will mimic infix notation

    - (case) as macro and to handle multi-value

*** test

    - use EOPL to test the language

* list

*** <null> & <cons>

    #+begin_src jojo
    (+data <null>)
    (+data <cons> .cdr .car)

    (+jojo list-print :f! :l!
      (case :l
        <null> ["null" string-write space]
        <cons> [:l .cdr :f (recur)
                :l .car :f apply space
                "cons" string-write space]))
    #+end_src

*** [test]

    #+begin_src jojo
    (note

      (+var a-list
        null
        1 cons
        2 cons)

      (run a-list (% int-write) list-print))
    #+end_src

* <closure>

*** [test]

    #+begin_src jojo
    (note
      (+jojo t0 1 :a0! 2 :b0! (% :a0 :b0 add))
      (run t0 dup
        apply int-write space
        apply int-write space
        newline)

      (+jojo t1 1 :a! 2 :b! (% :a (% :b t0 apply add)))
      (run t1 apply apply add)


      (+jojo t0 1 :a! (% :a))
      (+jojo t1 2 :a! (% (% t0 apply)))
      (run t1 apply apply)


      (+jojo t0 1 :a! (% :a))
      (+jojo t1 2 :a! (% (% t0)))
      (run t1 apply apply apply)

      (+jojo t0 1 :a! (% :a))
      (+jojo t1 (% (% t0 apply)))
      (run t1 apply apply)

      (run t1 apply))

    (note
      (+jojo com :m1! :m2!
       (% :m2 apply
          :m1 apply))
      (run (% 1) (% 2) com apply add int-write)
      (run (% 1) (% 2) com (% 3) com apply add add int-write)
      (run (% 1) (% 2) (% 3) com com apply add add int-write)
      (run step (% 1) (% 2) (% 3) com com apply add add int-write))
    #+end_src

* <socket>

*** server

    #+begin_src jojo
    (+var server "8888" 5 tcp-socket-listen)
    (+jojo run-server
      server socket-accept :addr! :client!
      "got a connection from " string-write :addr string-write newline
      :client "thank you for connecting" socket-send
      :client close (loop))
    (note (run run-server))
    #+end_src

*** client

    #+begin_src jojo
    (+var clinet "cicada" "8888" tcp-socket-connect)
    (+jojo run-clinet
      clinet socket-recv string-write newline)
    (note (run run-clinet))
    #+end_src

* <monad>

*** maybe

    #+begin_src jojo
    (+data <nothing>)
    (+data <just> .v)
    #+end_src

*** tree

    #+begin_src jojo
    (+data <leaf> .v)
    (+data <node> .l .r)

    (+jojo tree-write :f! :t!
      (note [tree fun] -> [])
      (case :t
        <leaf> [:t .v :f apply "leaf" string-write space]
        <node> [:t .l :f (recur)
                :t .r :f (recur) "node" string-write space]))

    (+jojo tree-map :f! :t!
      (note [tree fun] -> [tree])
      (case :t
        <leaf> [:t .v :f apply leaf]
        <node> [:t .l :f (recur)
                :t .r :f (recur) node]))
    #+end_src

*** [test] tree

    #+begin_src jojo
    (+var a-tree
      1 leaf 2 leaf node
      3 leaf 4 leaf node
      5 leaf node
      node)

    (run a-tree
      (% 100 add) tree-map
      (% int-write space) tree-write)
    #+end_src

*** >< zip-tree -- composition

    #+begin_src jojo
    (+jojo maybe-nothing :m1! :m2!
      (% :m2 apply
         (if dup nothing? then end)
         :m1 apply))

    (note not ok
      can not call maybe-nothing twice ?
      (+jojo zip-tree :t1! :t2!
        (note [tree tree] -> [tree | nothing])
        (cond [:t1 leaf? :t2 leaf? and]
              [:t1 .v :t2 .v cons leaf]
              [:t1 node? :t2 node? and]
              [(% :t1 .l :t2 .l zip-tree)
               (% :t1 .r :t2 .r zip-tree)
               (% node)
               maybe-nothing
               maybe-nothing
               apply]
              else nothing)))

    (+jojo zip-tree :t1! :t2!
      (note [tree tree] -> [tree | nothing])
      (cond [:t1 leaf? :t2 leaf? and]
            [:t1 .v :t2 .v cons leaf]
            [:t1 node? :t2 node? and]
            [(% :t1 .l :t2 .l zip-tree)
             (% :t1 .r :t2 .r zip-tree
                (if dup nothing? then end)
                node)
             maybe-nothing apply]
            else nothing))

    (note ok
      (+jojo zip-tree :t1! :t2!
        (note [tree tree] -> [tree | nothing])
        (cond [:t1 leaf? :t2 leaf? and]
              [:t1 .v :t2 .v cons leaf]
              [:t1 node? :t2 node? and]
              [(% :t1 .l :t2 .l zip-tree)
               (% :t1 .r :t2 .r zip-tree
                  (if dup nothing? then end)
                  node)
               maybe-nothing apply]
              else nothing)))

    (note ok
      (+jojo zip-tree :t1! :t2!
        (note [tree tree] -> [tree | nothing])
        (cond [:t1 leaf? :t2 leaf? and]
              [:t1 .v :t2 .v cons leaf]
              [:t1 node? :t2 node? and]
              [:t1 .l :t2 .l zip-tree (if dup nothing? then end)
               :t1 .r :t2 .r zip-tree (if dup nothing? then end)
               node]
              else nothing)))

    (+jojo write-tree-or-nothing
      (if dup nothing? then drop "nothing" string-write end)
      (el (% dup .cdr int-write space
             .car int-write space
             "cons" string-write space)
          tree-write))

    (run
      a-tree 1 leaf zip-tree
      write-tree-or-nothing)

    (run
      1 leaf a-tree zip-tree
      write-tree-or-nothing)

    (run
      a-tree 1 leaf 1 leaf node zip-tree
      write-tree-or-nothing)

    (run
      1 leaf 1 leaf node a-tree zip-tree
      write-tree-or-nothing)

    (run
      a-tree dup zip-tree
      write-tree-or-nothing)
    #+end_src

*** number-tree

    #+begin_src jojo
    (+jojo number-tree
      (note (-> <int>, :<t> <tree> -- <int>, <int> <tree>))
      :t!
      (case :t
        <leaf> [dup inc swap leaf]
        <node> [:t .l (recur) :l!
                :t .r (recur) :r!
                :l :r node]))

    (+var tree-2
      "1" leaf "2" leaf node
      "3" leaf "4" leaf node
      "5" leaf node
      node)

    (run
      tree-2
      0 swap number-tree
      swap drop
      (% int-write space) tree-write newline)
    #+end_src

*** list -- monad

    #+begin_src jojo :tangle no
    (+jojo return-list)
    (+jojo bind-list)
    #+end_src

* ><

  #+begin_src jojo
  (+jojo square dup mul)
  #+end_src
