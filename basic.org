#+title: basic

* w

  #+begin_src jojo
  (+gene w (-> :x --))
  (+disp w (-> <int> --) int-write)
  (+disp w (-> <string> --) string-write)
  (run 1 w newline "one" w newline)

  (+gene ww (-> :a :b --))
  (+disp ww (-> <int> <int> --) swap int-write space int-write space)
  (+disp ww (-> <int> <string> --) swap int-write space string-write space)
  (run 1 2 ww)
  (run 1 "two" ww)
  (note (run "two" 1 ww))
  #+end_src

* <closure>

*** [test]

    #+begin_src jojo
    (note
      (+jojo t0 1 :a0! 2 :b0! {:a0 :b0 add})
      (run t0 dup
        apply int-write space
        apply int-write space
        newline)

      (+jojo t1 1 :a! 2 :b! {:a {:b t0 apply add}})
      (run t1 apply apply add)


      (+jojo t0 1 :a! {:a})
      (+jojo t1 2 :a! {{t0 apply}})
      (run t1 apply apply)


      (+jojo t0 1 :a! {:a})
      (+jojo t1 2 :a! {{t0}})
      (run t1 apply apply apply)

      (+jojo t0 1 :a! {:a})
      (+jojo t1 {{t0 apply}})
      (run t1 apply apply)

      (run t1 apply))

    (note
      (+jojo com :m1! :m2!
        {:m2 apply
         :m1 apply})
      (run {1} {2} com apply add int-write)
      (run {1} {2} com {3} com apply add add int-write)
      (run {1} {2} {3} com com apply add add int-write)
      (run step {1} {2} {3} com com apply add add int-write))
    #+end_src

* <socket>

*** server

    #+begin_src jojo
    (+var server "8888" 5 tcp-socket-listen)
    (+jojo run-server
      server socket-accept :addr! :client!
      "got a connection from " string-write :addr string-write newline
      :client "thank you for connecting" socket-send
      :client close recur)
    (note (run run-server))
    #+end_src

*** client

    #+begin_src jojo
    (+var clinet "cicada" "8888" tcp-socket-connect)
    (+jojo run-clinet
      clinet socket-recv string-write newline)
    (note (run run-clinet))
    #+end_src

* <monad>

*** maybe

    #+begin_src jojo
    (+data <nothing>)
    (+data <just> .v)
    #+end_src

*** tree

    #+begin_src jojo
    (+data <leaf> .v)
    (+data <node> .l .r)

    (+jojo tree-write :f! :t!
      (note [tree fun] -> [])
      (case :t
        <leaf> [:t .v :f apply "leaf" string-write space]
        <node> [:t .l :f recur
                :t .r :f recur "node" string-write space]))

    (+jojo tree-map :f! :t!
      (note [tree fun] -> [tree])
      (case :t
        <leaf> [:t .v :f apply leaf]
        <node> [:t .l :f recur
                :t .r :f recur node]))
    #+end_src

*** [test] tree

    #+begin_src jojo
    (+var a-tree
      1 leaf 2 leaf node
      3 leaf 4 leaf node
      5 leaf node
      node)

    (run a-tree
      {100 add} tree-map
      {int-write space} tree-write)
    #+end_src

*** >< zip-tree -- composition

    #+begin_src jojo
    (+jojo maybe-nothing :m1! :m2!
      {:m2 apply
       (if dup nothing? then end)
       :m1 apply})

    (note not ok
      can not call maybe-nothing twice ?
      (+jojo zip-tree :t1! :t2!
        (note [tree tree] -> [tree | nothing])
        (cond [:t1 leaf? :t2 leaf? and]
              [:t1 .v :t2 .v cons leaf]
              [:t1 node? :t2 node? and]
              [{:t1 .l :t2 .l zip-tree}
               {:t1 .r :t2 .r zip-tree}
               {node}
               maybe-nothing
               maybe-nothing
               apply]
              else nothing)))

    (+jojo zip-tree :t1! :t2!
      (note [tree tree] -> [tree | nothing])
      (cond [:t1 leaf? :t2 leaf? and]
            [:t1 .v :t2 .v cons leaf]
            [:t1 node? :t2 node? and]
            [{:t1 .l :t2 .l zip-tree}
             {:t1 .r :t2 .r zip-tree
              (if dup nothing? then end)
              node}
             maybe-nothing apply]
            else nothing))

    (note ok
      (+jojo zip-tree :t1! :t2!
        (note [tree tree] -> [tree | nothing])
        (cond [:t1 leaf? :t2 leaf? and]
              [:t1 .v :t2 .v cons leaf]
              [:t1 node? :t2 node? and]
              [{:t1 .l :t2 .l zip-tree}
               {:t1 .r :t2 .r zip-tree
                (if dup nothing? then end)
                node}
               maybe-nothing apply]
              else nothing)))

    (note ok
      (+jojo zip-tree :t1! :t2!
        (note [tree tree] -> [tree | nothing])
        (cond [:t1 leaf? :t2 leaf? and]
              [:t1 .v :t2 .v cons leaf]
              [:t1 node? :t2 node? and]
              [:t1 .l :t2 .l zip-tree (if dup nothing? then end)
               :t1 .r :t2 .r zip-tree (if dup nothing? then end)
               node]
              else nothing)))

    (+jojo write-tree-or-nothing
      (if dup nothing? then drop "nothing" string-write end)
      {dup .car int-write space
       .cdr int-write space
       "cons" string-write space}
      tree-write)

    (run
      a-tree 1 leaf zip-tree
      write-tree-or-nothing)

    (run
      1 leaf a-tree zip-tree
      write-tree-or-nothing)

    (run
      a-tree 1 leaf 1 leaf node zip-tree
      write-tree-or-nothing)

    (run
      1 leaf 1 leaf node a-tree zip-tree
      write-tree-or-nothing)

    (run
      a-tree dup zip-tree
      write-tree-or-nothing)
    #+end_src

*** number-tree

    #+begin_src jojo
    (+jojo number-tree
      (note (-> <int>, :<t> <tree> -- <int>, <int> <tree>))
      :t!
      (case :t
        <leaf> [dup inc swap leaf]
        <node> [:t .l recur :l!
                :t .r recur :r!
                :l :r node]))

    (+var tree-2
      "1" leaf "2" leaf node
      "3" leaf "4" leaf node
      "5" leaf node
      node)

    (run
      tree-2
      0 swap number-tree
      swap drop
      {int-write space} tree-write newline)
    #+end_src

*** >< list -- monad

    #+begin_src jojo
    (note
      (+jojo return-list)
      (+jojo bind-list))
    #+end_src

*** bind & compose

    #+begin_src jojo
    (note

      (+jojo bind
        (-> (: :1m [:<1> <monad>])
            (: :1-2m (-> :<1> -- :<2> <monad>))
         -- (: :2m [:<2> <monad>]))
        dummy {drop :1m} :1-2m compose apply)

      (+jojo compose
        (-> (: :0-1m (-> :<0> -- :<1> <monad>))
            (: :1-2m (-> :<1> -- :<2> <monad>))
         -- (: :0-2m (-> :<0> -- :<2> <monad>)))
        {:0-1m apply :1-2m bind}))
    #+end_src
