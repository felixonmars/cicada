#+title: basic

* <socket>

*** server

    #+begin_src jojo
    (+jojo server "8888" 5 tcp-socket-listen)
    (+jojo run-server
      server socket-accept :addr! :client!
      "got a connection from " string-write :addr string-write newline
      :client "thank you for connecting" socket-send
      :client close recur)
    (note (run run-server))
    #+end_src

*** client

    #+begin_src jojo
    (+jojo clinet "cicada" "8888" tcp-socket-connect)
    (+jojo run-clinet
      clinet socket-recv string-write newline)
    (note (run run-clinet))
    #+end_src

* tree

  #+begin_src jojo
  (+data <leaf> .v)
  (+data <node> .l .r)
  #+end_src

* tree-write

  #+begin_src jojo
  (+jojo tree-write (-> :tree :fun --)
    (case :tree
      <leaf> [:tree .v :fun apply "leaf" string-write space]
      <node> [:tree .l :fun recur
              :tree .r :fun recur "node" string-write space]))
  #+end_src

* tree-map

  #+begin_src jojo
  (+jojo tree-map (-> :tree :fun -- tree)
    (case :tree
      <leaf> [:tree .v :fun apply leaf]
      <node> [:tree .l :fun recur
              :tree .r :fun recur node]))
  #+end_src

* [test]

  #+begin_src jojo
  (test

    (+jojo tree-1
      1 leaf 2 leaf node
      3 leaf 4 leaf node
      5 leaf node
      node)

    (run tree-1
      {100 add} tree-map
      {int-write space} tree-write))
  #+end_src

* maybe monad

  #+begin_src jojo
  (+data <nothing>)
  (+data <just> .v)
  #+end_src

* zip-tree -- maybe monad

  #+begin_src jojo
  (+jojo return-maybe just)

  (+jojo bind-maybe (-> :m :v->m -- maybe)
    (case :m
      <nothing> nothing
      <just> [:m .v :v->m apply]))

  (+jojo zip-tree (-> :t1 :t2 -- maybe tree)
    (cond
      [:t1 leaf? :t2 leaf? and]
      [:t1 .v :t2 .v cons leaf return-maybe]

      [:t1 node? :t2 node? and]
      [:t1 .l :t2 .l zip-tree
       {:l! :t1 .r :t2 .r zip-tree
        {:r! :l :r node return-maybe}
        bind-maybe}
       bind-maybe]

      else nothing))
  #+end_src

* [test]

  #+begin_src jojo
  (+jojo maybe-write (-> :m :f --)
    (case :m
      <nothing> ["nothing" string-write space]
      <just> [:m .v :f apply "just" string-write space]))

  (+jojo test-zip-tree
    zip-tree
    {{ dup .cdr int-write space
      .car int-write space
      "cons" string-write space}
     tree-write}
    maybe-write)

  (+var tree-2
    1 leaf 2 leaf node
    3 leaf 4 leaf node
    5 leaf node
    node)

  (run tree-2 dup zip-tree
    test-zip-tree)

  (run tree-2 1 leaf
    test-zip-tree)
  #+end_src

* number-tree

  #+begin_src jojo
  (+jojo number-tree
    (note (-> <int>, :<t> <tree> -- <int>, <int> <tree>))
    :t!
    (case :t
      <leaf> [dup inc swap leaf]
      <node> [:t .l recur :l!
              :t .r recur :r!
              :l :r node]))

  (+jojo tree-2
    "1" leaf "2" leaf node
    "3" leaf "4" leaf node
    "5" leaf node
    node)

  (run
    tree-2
    0 swap number-tree
    swap drop
    {int-write space} tree-write newline)
  #+end_src

* >< list -- monad

  #+begin_src jojo
  (note
    (+jojo return-list)
    (+jojo bind-list))
  #+end_src

* bind and compose can implement each ohter

  #+begin_src jojo
  (note

    (+jojo bind
      (-> (: :1m [:<1> <monad>])
          (: :1-2m (-> :<1> -- :<2> <monad>))
       -- (: :2m [:<2> <monad>]))
      dummy {drop :1m} :1-2m compose apply)

    (+jojo compose
      (-> (: :0-1m (-> :<0> -- :<1> <monad>))
          (: :1-2m (-> :<1> -- :<2> <monad>))
       -- (: :0-2m (-> :<0> -- :<2> <monad>)))
      {:0-1m apply :1-2m bind}))
  #+end_src
