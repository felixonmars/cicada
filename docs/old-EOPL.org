#+title: interp -- little interpreters from EOPL

* LET -- a simple language

*** <expval>

    #+begin_src jojo
    (+type-alias <expval> (type-sum <number> <bool>))
    #+end_src

*** <env>

    #+begin_src jojo
    (+type <env> (-> (: .val-type :t) <<type>>)
      empty-env  (-> [] [:t <env>])
      extend-env (-> [(: .old [:t <env>])
                      (: .var <var>)
                      (: .val :t)]
                     [:t <env>]))

    (+fun env-apply (-> [(: :var <var>) (: :env [:t <env>])] :t)
      (match :env
        empty-env error
        extend-env (match [:env.var :var equal?]
                     true  :val
                     false [:var :env.old recur])))

    (+fun init-env (-> [] [<expval> <env>])
      empty-env
      'x 10 extend-env
      'v 5  extend-env
      'i 1  extend-env)
    #+end_src

*** <exp>

    #+begin_src jojo
    (+type-alias <program> <exp>)

    (+simple-type <exp>
      const-exp (: .num <number>)
      zero?-exp (: .exp1 <exp>)
      if-exp    (: .exp1 .exp2 .exp3 <exp>)
      diff-exp  (: .exp1 .exp2 <exp>)
      var-exp   (: .var <var>)
      let-exp   (: .var <var>) (: .exp1 .body <exp>))

    (+fun program-eval (-> (: :program <program>) <expval>)
      :program init-env eval)

    (+fun eval (-> [(: :exp <exp>) (: :env [<expval> <env>])] <expval>)
      (match :exp
        const-exp [:exp.num]
        zero?-exp [:exp.exp1 :env recur zero equal?]
        if-exp    (match [:exp.exp1 :env recur]
                    true  [:exp.exp2 :env recur]
                    false [:exp.exp3 :env recur])
        diff-exp  [:exp.exp1 :env recur
                   :exp.exp2 :env recur sub]
        var-exp   [:exp.var :env env-apply]
        let-exp   [:exp.exp1 :env recur :val!
                   :exp.body :env :exp.var :val extend-env recur]))
    #+end_src

* PROC -- a language with procedures

*** <proc>

    #+begin_src jojo
    (+class <proc>
      (: .var <var>)
      (: .body <exp>)
      (: .saved-env [<expval> <env>]))

    (note a <proc> is viewed as of type (-> <expval> <expval>))

    (+fun proc-apply (-> [(: :proc <proc>) (: :val <expval>)] <expval>)
      :proc.body
      :proc.saved-env :proc.var :val extend-env
      eval)
    #+end_src

*** <expval>

    #+begin_src jojo
    (+type-alias <expval> (type-sum <number> <bool> <proc>))
    #+end_src

*** <env>

    #+begin_src jojo
    (+type <env> (-> (: .val-type :t) <<type>>)
      empty-env  (-> [] [:t <env>])
      extend-env (-> [(: .old [:t <env>])
                      (: .var <var>)
                      (: .val :t)]
                     [:t <env>]))

    (+fun env-apply (-> [(: :var <var>) (: :env [:t <env>])] :t)
      (match :env
        empty-env error
        extend-env (match [:env.var :var equal?]
                     true  :val
                     false [:var :env.old recur])))

    (+fun init-env (-> [] [<expval> <env>])
      empty-env
      'x 10 extend-env
      'v 5  extend-env
      'i 1  extend-env)
    #+end_src

*** <exp>

    #+begin_src jojo
    (+type-alias <program> <exp>)

    (+simple-type <exp>
      const-exp (: .num <number>)
      zero?-exp (: .exp1 <exp>)
      if-exp    (: .exp1 .exp2 .exp3 <exp>)
      diff-exp  (: .exp1 .exp2 <exp>)
      var-exp   (: .var <var>)
      let-exp   (: .var <var>) (: .exp1 .body <exp>)
      proc-exp  (: .var <var>) (: .body <exp>)
      call-exp  (: .rator .rand <exp>))

    (+fun program-eval (-> (: :program <program>) <expval>)
      :program init-env eval)

    (+fun eval (-> [(: :exp <exp>) (: :env [<expval> <env>])] <expval>)
      (match :exp
        const-exp [:exp.num]
        zero?-exp [:exp.exp1 :env recur .num zero equal?]
        if-exp    (match [:exp.exp1 :env recur]
                    true  [:exp.exp2 :env recur]
                    false [:exp.exp3 :env recur])
        diff-exp  [:exp.exp1 :env recur
                   :exp.exp2 :env recur sub]
        var-exp   [:exp.var :env env-apply]
        let-exp   [:exp.exp1 :env recur :val!
                   :exp.body :env :exp.var :val extend-env recur]
        proc-exp  [:exp.var :exp.body :env proc]
        call-exp  [:exp.rator :env recur :exp.rand :env recur proc-apply]))
    #+end_src

* LETREC -- a language with recursive procedures

*** <proc>

    #+begin_src jojo
    (+class <proc>
      (: .var <var>)
      (: .body <exp>)
      (: .saved-env [<expval> <env>]))

    (note a <proc> is viewed as of type (-> <expval> <expval>))

    (+fun proc-apply (-> [(: :proc <proc>) (: :val <expval>)] <expval>)
      :proc.body
      :proc.saved-env :proc.var :val extend-env
      eval)
    #+end_src

*** <expval>

    #+begin_src jojo
    (+type-alias <expval> (type-sum <number> <bool> <proc>))
    #+end_src

*** <exp>

    #+begin_src jojo
    (+simple-type <exp>
      ++
      letrec (: .var .bind <var>) (: .body .letrec-body <exp>))

    (+fun eval (-> [(: :exp <exp>) (: :env [<expval> <env>])] <expval>)
      (match :exp
        ++
        letrec [:exp.letrec-body
                :env :exp.var :exp.bind :exp.body extend-rec
                recur]))


    (+type <env> (-> :t <<type>>)
      ++
      extend-rec (-> [(: .old [:t <env>])
                      (: .var <var>)
                      (: .bind <var>)
                      (: .body <exp>)]
                     [:t <env>]))

    (+fun env-apply (-> [(: :var <var>)
                         (: :env [:t <env>])]
                        :t)
      (match :env
        ++
        extend-rec (match [:env.var :var equal?]
                     true  [:env.bind :env.body :env proc]
                     false [:var :env.old recur])))
    #+end_src

* >< NAMELESS -- optimize searching to indexing

* >< EXPLICIT-REFS -- a language with explicit references
