#+title: interp -- little interpreters from EOPL

* LETREC -- a language with recursive procedures

*** <proc>

    #+begin_src jojo
    (+class <proc>
      (: .var <var>)
      (: .body <exp>)
      (: .saved-env [<expval> <env>]))

    (note a <proc> is viewed as of type (-> <expval> <expval>))

    (+fun proc-apply (-> [(: :proc <proc>) (: :val <expval>)] <expval>)
      :proc.body
      :proc.saved-env :proc.var :val extend-env
      eval)
    #+end_src

*** <expval>

    #+begin_src jojo
    (+type-alias <expval> (type-sum <number> <bool> <proc>))
    #+end_src

*** <exp>

    #+begin_src jojo
    (+simple-type <exp>
      ++
      letrec (: .var .bind <var>) (: .body .letrec-body <exp>))

    (+fun eval (-> [(: :exp <exp>) (: :env [<expval> <env>])] <expval>)
      (match :exp
        ++
        letrec [:exp.letrec-body
                :env :exp.var :exp.bind :exp.body extend-rec
                recur]))


    (+type <env> (-> :t <<type>>)
      ++
      extend-rec (-> [(: .old [:t <env>])
                      (: .var <var>)
                      (: .bind <var>)
                      (: .body <exp>)]
                     [:t <env>]))

    (+fun env-apply (-> [(: :var <var>)
                         (: :env [:t <env>])]
                        :t)
      (match :env
        ++
        extend-rec (match [:env.var :var equal?]
                     true  [:env.bind :env.body :env proc]
                     false [:var :env.old recur])))
    #+end_src
