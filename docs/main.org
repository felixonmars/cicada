#+title: main

* judgment and inference rule

*** inference rules are formed about judgment

    - a type constructor is a judgment
      its data constructors are its inference rules
      - the type of the data constructor is the inference rule
      - the name of the data constructor is the name of the inference rule

    - inference rules can generate directed graph
      where judgment is node
      and inference is directed star in the graph

    - a proof is formed by an inference tree
      a function is a proof
      - the type of the function is the theorem to be proved
      - the body of the function record the inference tree

    - both inference rule and theorem are
      expressed in the form of arrow

*** judgment and predicate

    - a judgment reads like a predicate
      a predicate can be viewed as a set

    - a judgment can generate a predicate
      by searching its inference rules
      - the searching can be viewed as happening in
        the directed graph generated by inference rules

    - a judgment is like a predicate written in
      logic programming language

*** meta judgment

    - in the above we used ':' such as :
      type constructor : inference rule
      proof : theorem
      function : type

    - note that
      ':' itself is a name of a judgment !
      - thus if we want to write a type checker
        we can model ':' as a judgment
        just like an interpreter is a program

* unification

*** what to unify ?

    - in cicada
      <term> := <type-term>, <union-term>, <data-term>
      --- (data <hypo>), (type <hypo>)
      --- <trunk>
      <type-term>  := (<type-constructor> <term> ...)
      <union-term> := (<union-constructor> <term> ...)
      <data-term>  := (<data-constructor> <term> ...)
      <trunk> := function application to be reduced

      data-bind-dict -- <hypo> to data <term>
      type-bind-dict -- <hypo> to type <term>

      <trunk> will be formed,
      when among arguments of a function application
      there is a <hypo> that is not bound to data
      or there is a non-reduce-able <trunk>

    - in logic
      <term> := <predicate-term>, <var>, <constant>
      <predicate-term> := (<predicate-symbol> <term> ...)

*** feature structures

    - <var> with two fields type and data,
      can be viewed as feature structures
      in unification theory

* vector vs list

  - vector and list have the same data-constructor shape

  - it is *not* true that
    every function can be defined for vector
    can also be defined for list

    - for example zip can be defined for vector of same length

    - when defining zip for vector
      more informations in type
      can help to rule out some not meaningful cases

    list -> list
    vector -> vector
    can *not* be composed to
    list -> vector

  - it is true that
    every function can be defined for list
    can also be defined for vector

    - by dropping the length information

    vector -> vector
    list -> list
    can be composed
    vector -> list

  - vector can be viewed as subtype of list
    we can assert so
    and use this subtype relation to reuse functions

    - in some case [when namings are so different]
      we also need to assert relation between
      fields of type and data-constructors

* proof search

*** the natural of the proof space

* provability as a judgment

  - it looks like a meta thing
    but function abstraction give us just it.
    by useing '->'

  - can we also bring down the meta-ness of ':' ?

  - can we really view function abstraction as
    bringing down provability ?

  - f : Y Z -> X
    g : Z -> (Y -> X)
    ------------------
    (let z) {z f}

  - x -
    我们之前把 judgment 理解为 type-constructor
    inference rule 理解为 data-constructor
    这正确吗 ?
