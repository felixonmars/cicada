#+html_head: <link rel="stylesheet" href="../../css/org-page.css"/>
#+title: Essentials of Programming Languages

- by Daniel P. Friedman and Mitchell Wand

* 1 Inductive Sets of Data

*** 1.1 Recursively Specified Data

    - proof by structural induction -

      To prove that a proposition IH(s)
      is true for all structures s,
      prove the following:

      1. IH is true on simple structures
         (those without substructures).
      2. If IH is true on the substructures of s,
         then it is true on s itself.

*** 1.2 Deriving Recursive Programs

    - the smaller-subproblem principle -

      If we can reduce a problem to a smaller subproblem,
      we can call the procedure that solves the problem
      to solve the subproblem.

    - follow the grammar! -

      When defining a procedure
      that operates on inductively defined data,
      the structure of the program
      should be patterned after the structure of the data.

*** 1.3 Auxiliary Procedures and Context Arguments

    - no mysterious auxiliaries! -

      When defining an auxiliary procedure,
      always specify what it does on all arguments,
      not just the initial values.

*** 1.4 Exercises

* 2 Data Abstraction

*** 2.1 Specifying Data via Interfaces

    - All the knowledge about how the data is represented
      must therefore reside in the code of the implementation.

      The most important part of an implementation
      is the specification of how the data is represented.

      We use the notation [^ v ^] for
      "the representation of data v."

      - x -
        - in concrete implementation,
          if v is language A,
          B is the language we want to implement in A,

        - then,
          [^ v ^] can be viewed as,
          "build a value [^ v ^] on top of v"

        - if x is a value in B,
          [_ x _] can be viewed as,
          "push a value x down to A"

        - and we have,
          1. [_ [^ v ^] _] == v
          2. [^ [_ x _] ^] == x

    - x -
      we do not need type class to be abstract about data type.

    - Most interfaces will contain

      1. some *constructors*
         that build elements of the data type,

      2. and some *observers*
         that extract information from values of the data type.

*** 2.2 Representation Strategies for Data Types

    - the interpreter recipe -

      1. look at a piece of data.
      2. decide what kind of data it represents.
      3. extract the components of the datum
         and do the right thing with them.

    - x -
      interpreter of a programming language.
      interprets data which encode program.

      such data is called expression.

*** 2.3 Interfaces for Recursive Data Types

    - designing an interface for a recursive data type -

      1. Include one constructor
         for each kind of data in the data type.
      2. Include one predicate
         for each kind of data in the data type.
      3. Include one extractor
         for each piece of data
         passed to a constructor of the data type.

*** 2.4 A Tool for Defining Recursive Data Types

*** 2.5 Abstract Syntax and Its Representation

* 3 Expressions

*** 3.1 Specification and Implementation Strategy

    - specification will consist of assertions of the form :

      (value-of exp ρ) = val

      meaning that
      the value of expression exp
      in environment ρ
      should be val.

    - We write down rules of inference and equations,
      like those in chapter 1,
      that will enable us to derive such assertions.

      We use the rules and equations by hand
      to find the intended value of some expressions.

*** 3.2 LET: A Simple Language

    - [[./LET/LET.html][LET]]

*** 3.3 PROC: A Language with Procedures

    - [[./PROC/PROC.html][PROC]]

*** 3.4 LETREC: A Language with Recursive Procedures

    - [[./LETREC/LETREC.html][LETREC]]

*** 3.5 Scoping and Binding of Variables

    - In most programming languages,
      variables may appear in two different ways :
      1. as references or as declarations.
      2. A variable reference is a use of the variable.

    - Declarations in most programming languages have a limited scope,
      so that the same variable name
      may be used for different purposes
      in different parts of a program.

    - Every programming language must have some rules
      to determine the declaration to which each variable reference refers.
      These rules are typically called scoping rules.

    - The portion of the program in which a declaration is valid
      is called the scope of the declaration.

    - We can determine which declaration is associated with
      each variable use without executing the program.

    - Properties like this,
      which can be computed without executing the program,
      are called static properties.

    - The extent of a binding is the time interval
      during which the binding is maintained.

    - In our little language, all bindings have semiinfinite extent,
      meaning that once a variable gets bound,
      that binding must be maintained indefinitely (at least potentially).

    - This is because the binding might be
      hidden inside a closure that is returned.

    - In languages with semi-infinite extent,
      the garbage collector collects bindings
      when they are no longer reachable.

    - This is only determinable at run-time,
      so we say that this is a dynamic property.

    - "dynamic" might mean
      1. during the evaluation of an expression.
      2. not calculable in advance.

*** NAMELESS -- optimize searching to indexing

***** 3.6 Eliminating Variable Names

      - de Bruijn indices [or Lexical Address]

      - This way of recording the information is useful
        because the lexical address predicts
        just where in the environment
        any particular variable will be found.

      - x -
        thus, no runtime searching overhead.

***** 3.7 Implementing Lexical Addressing

      - [[./NAMELESS/NAMELESS.html][NAMELESS]]

* 4 State

*** 4.1 Computational Effects

    - So far, we have only considered the *value*
      produced by a computation.
      But a computation may have *effects* as well.

      - Different from producing a value
        an effect is global, it is seen by the *entire* computation.

    - We will be concerned primarily with a single effect :
      assignment to a location in memory.

      - Assignment is different from binding.
        binding is local, but variable assignment
        is potentially global.

    - It is about the sharing of values between
      otherwise unrelated portions of the computation.

      1. Two procedures can share information
         if they both know about the same location in memory.

      2. A single procedure can share information
         with a future invocation of itself
         by leaving the information in a known location.

    - We model memory as a finite map from *locations*
      to a set of values called the *storable values*.

      - The storable values in a language
        are typically, but not always,
        the same as the expressed values of the language.
        This choice is part of the design of a language.

    - A data structure that represents a location
      is called a *reference*.

      - A location is a place in memory
        where a value can be stored,
        and a reference is a data structure
        that refers to that place.

      - References are sometimes called L-values.
        This name reflects the association
        of such data structures with variables
        appearing on the left-hand side of assignment statements.

      - Analogously, expressed values,
        such as the values of the right-hand side expressions
        of assignment statements,
        are known as R-values.

*** 4.2 EXPLICIT-REFS: A Language with Explicit References

    - EXPLICIT-REFS

*** 4.3 IMPLICIT-REFS: A Language with Implicit References

    - IMPLICIT-REFS

*** 4.4 MUTABLE-PAIRS: A Language with Mutable Pairs

    - MUTABLE-PAIRS

*** 4.5 Parameter-Passing Variations

***** CALL-BY-REFERENCE

***** Lazy Evaluation: CALL-BY-NAME and CALL-BY-NEED

* 5 Continuation-Passing Interpreters

*** 5.1 A Continuation-Passing Interpreter

*** 5.2 A Trampolined Interpreter

*** 5.3 An Imperative Interpreter

*** 5.4 Exceptions

*** 5.5 Threads

* 6 Continuation-Passing Style

*** 6.1 Writing Programs in Continuation-Passing Style

*** 6.2 Tail Form

*** 6.3 Converting to Continuation-Passing Style

*** 6.4 Modeling Computational Effects

* 7 Types

*** 7.1 Values and Their Types

*** 7.2 Assigning a Type to an Expression

*** 7.3 CHECKED: A Type-Checked Language

*** 7.4 INFERRED: A Language with Type Inference

* 8 Modules

*** 8.1 The Simple Module System

*** 8.2 Modules That Declare Types

*** 8.3 Module Procedures

* 9 Objects and Classes

*** 9.1 Object-Oriented Programming

*** 9.2 Inheritance

*** 9.3 The Language

*** 9.4 The Interpreter

*** 9.5 A Typed Language

*** 9.6 The Type Checker
