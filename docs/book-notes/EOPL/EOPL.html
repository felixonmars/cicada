<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2017-10-25 Wed 01:13 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Essentials of Programming Languages</title>
<meta name="generator" content="Org-mode" />
<meta name="author" content="xieyuheng" />
<link rel="stylesheet" href="../../css/org-page.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Essentials of Programming Languages</h1>
<div id="table-of-contents">
<h2>overview</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org3cca0c5"><span class="done _todo_stack_">[todo-stack]</span> </a>
<ul>
<li><a href="#orgdb39467">interface</a></li>
</ul>
</li>
<li><a href="#org25965f0">1 Inductive Sets of Data</a>
<ul>
<li><a href="#org779adf6">1.1 Recursively Specified Data</a></li>
<li><a href="#org3048fa2">1.2 Deriving Recursive Programs</a></li>
<li><a href="#orgfd09cf">1.3 Auxiliary Procedures and Context Arguments</a></li>
<li><a href="#org719be33">1.4 Exercises</a></li>
</ul>
</li>
<li><a href="#org7f9b7b5">2 Data Abstraction</a>
<ul>
<li><a href="#org40cff9e">2.1 Specifying Data via Interfaces</a></li>
<li><a href="#orgfced62">2.2 Representation Strategies for Data Types</a></li>
<li><a href="#orgfcdc765">2.3 Interfaces for Recursive Data Types</a></li>
<li><a href="#orgb86ae5f">2.4 A Tool for Defining Recursive Data Types</a></li>
<li><a href="#orgb228024">2.5 Abstract Syntax and Its Representation</a></li>
</ul>
</li>
<li><a href="#orgbb4907b">3 Expressions</a>
<ul>
<li><a href="#org558f7d9">3.1 Specification and Implementation Strategy</a></li>
<li><a href="#orgd2897a">3.2 LET: A Simple Language</a></li>
<li><a href="#org81988de">3.3 PROC: A Language with Procedures</a></li>
<li><a href="#org598f0cf">3.4 LETREC: A Language with Recursive Procedures</a></li>
<li><a href="#orgee3578b">3.5 Scoping and Binding of Variables</a></li>
<li><a href="#orgbe9e868">NAMELESS &#x2013; optimize searching to indexing</a>
<ul>
<li><a href="#orgb4942b3">3.6 Eliminating Variable Names</a></li>
<li><a href="#orga7fe7ba">3.7 Implementing Lexical Addressing</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org58230a3">4 State</a>
<ul>
<li><a href="#org24d9d85">4.1 Computational Effects</a></li>
<li><a href="#org84ae10d">4.2 EXPLICIT-REFS: A Language with Explicit References</a></li>
<li><a href="#org782df73">4.3 IMPLICIT-REFS: A Language with Implicit References</a></li>
<li><a href="#org7ca2ba3">4.4 MUTABLE-PAIRS: A Language with Mutable Pairs</a></li>
<li><a href="#orgf4db378">4.5 Parameter-Passing Variations</a>
<ul>
<li><a href="#orgeab5533">CALL-BY-REFERENCE</a></li>
<li><a href="#orgfe84e35">Lazy Evaluation: CALL-BY-NAME and CALL-BY-NEED</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgaebb334">5 Continuation-Passing Interpreters</a>
<ul>
<li><a href="#orgdb5e1d0">intro</a></li>
<li><a href="#org60a74fa">5.1 A Continuation-Passing Interpreter</a></li>
<li><a href="#org2b74351">5.2 A Trampolined Interpreter</a></li>
<li><a href="#org57565f4">5.3 An Imperative Interpreter</a></li>
<li><a href="#orgdd80166">5.4 Exceptions</a></li>
<li><a href="#orgc4cc41e">5.5 Threads</a></li>
</ul>
</li>
<li><a href="#org24974f">6 Continuation-Passing Style</a>
<ul>
<li><a href="#org2b5545d">6.1 Writing Programs in Continuation-Passing Style</a></li>
<li><a href="#orgee399f7">6.2 Tail Form</a></li>
<li><a href="#orge8c950d">6.3 Converting to Continuation-Passing Style</a></li>
<li><a href="#orge2d7908">6.4 Modeling Computational Effects</a></li>
</ul>
</li>
<li><a href="#org57233ed">7 Types</a>
<ul>
<li><a href="#orgd11c6bc">intro</a></li>
<li><a href="#orgc7e58f7">7.1 Values and Their Types</a></li>
<li><a href="#org47cc2">7.2 Assigning a Type to an Expression</a></li>
<li><a href="#org934292e">7.3 CHECKED: A Type-Checked Language</a></li>
<li><a href="#org75d6349">7.4 INFERRED: A Language with Type Inference</a></li>
</ul>
</li>
<li><a href="#org95ff0cf">8 Modules</a>
<ul>
<li><a href="#org9034a5a">8.1 The Simple Module System</a></li>
<li><a href="#org69d2b38">8.2 Modules That Declare Types</a></li>
<li><a href="#orged4814">8.3 Module Procedures</a></li>
</ul>
</li>
<li><a href="#org4c3b56c">9 Objects and Classes</a>
<ul>
<li><a href="#org1b65581">9.1 Object-Oriented Programming</a></li>
<li><a href="#orgd58e8f8">9.2 Inheritance</a></li>
<li><a href="#org47f8ee1">9.3 The Language</a></li>
<li><a href="#orge5215fa">9.4 The Interpreter</a></li>
<li><a href="#org22da4b7">9.5 A Typed Language</a></li>
<li><a href="#orgf7a19c2">9.6 The Type Checker</a></li>
</ul>
</li>
</ul>
</div>
</div>
<ul class="org-ul">
<li><p>by Daniel P. Friedman and Mitchell Wand</p></li></ul>

<div id="outline-container-org3cca0c5" class="outline-2">
<h2 id="org3cca0c5"><span class="done _todo_stack_">[todo-stack]</span> </h2>
<div class="outline-text-2" id="text-org3cca0c5">
</div><div id="outline-container-orgdb39467" class="outline-3">
<h3 id="orgdb39467">interface</h3>
<div class="outline-text-3" id="text-orgdb39467">
<ul class="org-ul">
<li><p>the use of macro like (LET) is not carefully designed</p><p>for example</p><p><ul class="org-ul"></p><p><li><p>one can not use</p><p>{(LET &#x2026;)} 100 times</p></li></p><p><li><p>and the use of '(begin) in the definition of (LET) is not good</p></li></ul></p></li>

<li><p>the implemented languages should be better embedded into jojo</p></li></ul>
</div>
</div>
</div>

<div id="outline-container-org25965f0" class="outline-2">
<h2 id="org25965f0">1 Inductive Sets of Data</h2>
<div class="outline-text-2" id="text-org25965f0">
</div><div id="outline-container-org779adf6" class="outline-3">
<h3 id="org779adf6">1.1 Recursively Specified Data</h3>
<div class="outline-text-3" id="text-org779adf6">
<ul class="org-ul">
<li><p><p></p><p>proof by structural induction -</p><p></p></p><p></p><p><p></p><p>To prove that a proposition IH(s)</p><p>is true for all structures s,</p><p>prove the following:</p><p></p></p><p></p><p><ol class="org-ol"></p><p><li>IH is true on simple structures</p><p>(those without substructures).</li></p><p><li>If IH is true on the substructures of s,</p><p>then it is true on s itself.</li></ol></p></li></ul>
</div>
</div>

<div id="outline-container-org3048fa2" class="outline-3">
<h3 id="org3048fa2">1.2 Deriving Recursive Programs</h3>
<div class="outline-text-3" id="text-org3048fa2">
<ul class="org-ul">
<li><p><p></p><p>the smaller-subproblem principle -</p><p></p></p><p></p><p><p></p><p>If we can reduce a problem to a smaller subproblem,</p><p>we can call the procedure that solves the problem</p><p>to solve the subproblem.</p><p></p></p></li>

<li><p><p></p><p>follow the grammar! -</p><p></p></p><p></p><p><p></p><p>When defining a procedure</p><p>that operates on inductively defined data,</p><p>the structure of the program</p><p>should be patterned after the structure of the data.</p><p></p></p></li></ul>
</div>
</div>

<div id="outline-container-orgfd09cf" class="outline-3">
<h3 id="orgfd09cf">1.3 Auxiliary Procedures and Context Arguments</h3>
<div class="outline-text-3" id="text-orgfd09cf">
<ul class="org-ul">
<li><p><p></p><p>no mysterious auxiliaries! -</p><p></p></p><p></p><p><p></p><p>When defining an auxiliary procedure,</p><p>always specify what it does on all arguments,</p><p>not just the initial values.</p><p></p></p></li></ul>
</div>
</div>

<div id="outline-container-org719be33" class="outline-3">
<h3 id="org719be33">1.4 Exercises</h3>
</div>
</div>

<div id="outline-container-org7f9b7b5" class="outline-2">
<h2 id="org7f9b7b5">2 Data Abstraction</h2>
<div class="outline-text-2" id="text-org7f9b7b5">
</div><div id="outline-container-org40cff9e" class="outline-3">
<h3 id="org40cff9e">2.1 Specifying Data via Interfaces</h3>
<div class="outline-text-3" id="text-org40cff9e">
<ul class="org-ul">
<li><p><p></p><p>All the knowledge about how the data is represented</p><p>must therefore reside in the code of the implementation.</p><p></p></p><p></p><p><p></p><p>The most important part of an implementation</p><p>is the specification of how the data is represented.</p><p></p></p><p></p><p><p></p><p>We use the notation [^ v ^] for</p><p>"the representation of data v."</p><p></p></p><p></p><p><ul class="org-ul"></p><p><li><p>x -</p><p><ul class="org-ul"></p><p><li><p>in concrete implementation,</p><p>if v is language A,</p><p>B is the language we want to implement in A,</p></li></p><p></p><p><li><p>then,</p><p>[^ v ^] can be viewed as,</p><p>"build a value [^ v ^] on top of v"</p></li></p><p></p><p><li><p>if x is a value in B,</p><p>[_ x _] can be viewed as,</p><p>"push a value x down to A"</p></li></p><p></p><p><li><p>and we have,</p><p><ol class="org-ol"></p><p><li>[_ [^ v ^] _] == v</li></p><p><li>[^ [_ x _] ^] == x</li></ol></p></li></ul></p></li></ul></p></li>

<li><p>x -</p><p>we do not need type class to be abstract about data type.</p></li>

<li><p>Most interfaces will contain</p><p></p><p><ol class="org-ol"></p><p><li>some <b>constructors</b></p><p>that build elements of the data type,</li></p><p></p><p><li>and some <b>observers</b></p><p>that extract information from values of the data type.</li></ol></p></li></ul>
</div>
</div>

<div id="outline-container-orgfced62" class="outline-3">
<h3 id="orgfced62">2.2 Representation Strategies for Data Types</h3>
<div class="outline-text-3" id="text-orgfced62">
<ul class="org-ul">
<li><p>the interpreter recipe -</p><p></p><p><ol class="org-ol"></p><p><li>look at a piece of data.</li></p><p><li>decide what kind of data it represents.</li></p><p><li>extract the components of the datum</p><p>and do the right thing with them.</li></ol></p></li>

<li><p><p></p><p>x -</p><p>interpreter of a programming language.</p><p>interprets data which encode program.</p><p></p></p><p></p><p><p></p><p>such data is called expression.</p><p></p></p></li></ul>
</div>
</div>

<div id="outline-container-orgfcdc765" class="outline-3">
<h3 id="orgfcdc765">2.3 Interfaces for Recursive Data Types</h3>
<div class="outline-text-3" id="text-orgfcdc765">
<ul class="org-ul">
<li><p>designing an interface for a recursive data type -</p><p></p><p><ol class="org-ol"></p><p><li>Include one constructor</p><p>for each kind of data in the data type.</li></p><p><li>Include one predicate</p><p>for each kind of data in the data type.</li></p><p><li>Include one extractor</p><p>for each piece of data</p><p>passed to a constructor of the data type.</li></ol></p></li></ul>
</div>
</div>

<div id="outline-container-orgb86ae5f" class="outline-3">
<h3 id="orgb86ae5f">2.4 A Tool for Defining Recursive Data Types</h3>
</div>

<div id="outline-container-orgb228024" class="outline-3">
<h3 id="orgb228024">2.5 Abstract Syntax and Its Representation</h3>
</div>
</div>

<div id="outline-container-orgbb4907b" class="outline-2">
<h2 id="orgbb4907b">3 Expressions</h2>
<div class="outline-text-2" id="text-orgbb4907b">
</div><div id="outline-container-org558f7d9" class="outline-3">
<h3 id="org558f7d9">3.1 Specification and Implementation Strategy</h3>
<div class="outline-text-3" id="text-org558f7d9">
<ul class="org-ul">
<li><p><p></p><p>specification will consist of assertions of the form :</p><p></p></p><p></p><p><p></p><p>(value-of exp ρ) = val</p><p></p></p><p></p><p><p></p><p>meaning that</p><p>the value of expression exp</p><p>in environment ρ</p><p>should be val.</p><p></p></p></li>

<li><p><p></p><p>We write down rules of inference and equations,</p><p>like those in chapter 1,</p><p>that will enable us to derive such assertions.</p><p></p></p><p></p><p><p></p><p>We use the rules and equations by hand</p><p>to find the intended value of some expressions.</p><p></p></p></li></ul>
</div>
</div>

<div id="outline-container-orgd2897a" class="outline-3">
<h3 id="orgd2897a">3.2 LET: A Simple Language</h3>
<div class="outline-text-3" id="text-orgd2897a">
<ul class="org-ul">
<li><p><a href="./LET/LET.html">LET</a></p></li></ul>
</div>
</div>

<div id="outline-container-org81988de" class="outline-3">
<h3 id="org81988de">3.3 PROC: A Language with Procedures</h3>
<div class="outline-text-3" id="text-org81988de">
<ul class="org-ul">
<li><p><a href="./PROC/PROC.html">PROC</a></p></li></ul>
</div>
</div>

<div id="outline-container-org598f0cf" class="outline-3">
<h3 id="org598f0cf">3.4 LETREC: A Language with Recursive Procedures</h3>
<div class="outline-text-3" id="text-org598f0cf">
<ul class="org-ul">
<li><p><a href="./LETREC/LETREC.html">LETREC</a></p></li></ul>
</div>
</div>

<div id="outline-container-orgee3578b" class="outline-3">
<h3 id="orgee3578b">3.5 Scoping and Binding of Variables</h3>
<div class="outline-text-3" id="text-orgee3578b">
<ul class="org-ul">
<li><p>In most programming languages,</p><p>variables may appear in two different ways :</p><p><ol class="org-ol"></p><p><li>as references or as declarations.</li></p><p><li>A variable reference is a use of the variable.</li></ol></p></li>

<li><p>Declarations in most programming languages have a limited scope,</p><p>so that the same variable name</p><p>may be used for different purposes</p><p>in different parts of a program.</p></li>

<li><p>Every programming language must have some rules</p><p>to determine the declaration to which each variable reference refers.</p><p>These rules are typically called scoping rules.</p></li>

<li><p>The portion of the program in which a declaration is valid</p><p>is called the scope of the declaration.</p></li>

<li><p>We can determine which declaration is associated with</p><p>each variable use without executing the program.</p></li>

<li><p>Properties like this,</p><p>which can be computed without executing the program,</p><p>are called static properties.</p></li>

<li><p>The extent of a binding is the time interval</p><p>during which the binding is maintained.</p></li>

<li><p>In our little language, all bindings have semiinfinite extent,</p><p>meaning that once a variable gets bound,</p><p>that binding must be maintained indefinitely (at least potentially).</p></li>

<li><p>This is because the binding might be</p><p>hidden inside a closure that is returned.</p></li>

<li><p>In languages with semi-infinite extent,</p><p>the garbage collector collects bindings</p><p>when they are no longer reachable.</p></li>

<li><p>This is only determinable at run-time,</p><p>so we say that this is a dynamic property.</p></li>

<li><p>"dynamic" might mean</p><p><ol class="org-ol"></p><p><li>during the evaluation of an expression.</li></p><p><li>not calculable in advance.</li></ol></p></li></ul>
</div>
</div>

<div id="outline-container-orgbe9e868" class="outline-3">
<h3 id="orgbe9e868">NAMELESS &#x2013; optimize searching to indexing</h3>
<div class="outline-text-3" id="text-orgbe9e868">
</div><div id="outline-container-orgb4942b3" class="outline-4">
<h4 id="orgb4942b3">3.6 Eliminating Variable Names</h4>
<div class="outline-text-4" id="text-orgb4942b3">
<ul class="org-ul">
<li><p>de Bruijn indices [or Lexical Address]</p></li>

<li><p>This way of recording the information is useful</p><p>because the lexical address predicts</p><p>just where in the environment</p><p>any particular variable will be found.</p></li>

<li><p>x -</p><p>thus, no runtime searching overhead.</p></li></ul>
</div>
</div>

<div id="outline-container-orga7fe7ba" class="outline-4">
<h4 id="orga7fe7ba">3.7 Implementing Lexical Addressing</h4>
<div class="outline-text-4" id="text-orga7fe7ba">
<ul class="org-ul">
<li><p><a href="./NAMELESS/NAMELESS.html">NAMELESS</a></p></li></ul>
</div>
</div>
</div>
</div>

<div id="outline-container-org58230a3" class="outline-2">
<h2 id="org58230a3">4 State</h2>
<div class="outline-text-2" id="text-org58230a3">
</div><div id="outline-container-org24d9d85" class="outline-3">
<h3 id="org24d9d85">4.1 Computational Effects</h3>
<div class="outline-text-3" id="text-org24d9d85">
<ul class="org-ul">
<li><p>So far, we have only considered the <b>value</b></p><p>produced by a computation.</p><p>But a computation may have <b>effects</b> as well.</p><p></p><p><ul class="org-ul"></p><p><li><p>Different from producing a value</p><p>an effect is global, it is seen by the <b>entire</b> computation.</p></li></ul></p></li>

<li><p>We will be concerned primarily with a single effect :</p><p>assignment to a location in memory.</p><p></p><p><ul class="org-ul"></p><p><li><p>Assignment is different from binding.</p><p>binding is local, but variable assignment</p><p>is potentially global.</p></li></ul></p></li>

<li><p>It is about the sharing of values between</p><p>otherwise unrelated portions of the computation.</p><p></p><p><ol class="org-ol"></p><p><li>Two procedures can share information</p><p>if they both know about the same location in memory.</li></p><p></p><p><li>A single procedure can share information</p><p>with a future invocation of itself</p><p>by leaving the information in a known location.</li></ol></p></li>

<li><p>We model memory as a finite map from <b>locations</b></p><p>to a set of values called the <b>storable values</b>.</p><p></p><p><ul class="org-ul"></p><p><li><p>The storable values in a language</p><p>are typically, but not always,</p><p>the same as the expressed values of the language.</p><p>This choice is part of the design of a language.</p></li></ul></p></li>

<li><p>A data structure that represents a location</p><p>is called a <b>reference</b>.</p><p></p><p><ul class="org-ul"></p><p><li><p>A location is a place in memory</p><p>where a value can be stored,</p><p>and a reference is a data structure</p><p>that refers to that place.</p></li></p><p></p><p><li><p>References are sometimes called L-values.</p><p>This name reflects the association</p><p>of such data structures with variables</p><p>appearing on the left-hand side of assignment statements.</p></li></p><p></p><p><li><p>Analogously, expressed values,</p><p>such as the values of the right-hand side expressions</p><p>of assignment statements,</p><p>are known as R-values.</p></li></ul></p></li></ul>
</div>
</div>

<div id="outline-container-org84ae10d" class="outline-3">
<h3 id="org84ae10d">4.2 EXPLICIT-REFS: A Language with Explicit References</h3>
<div class="outline-text-3" id="text-org84ae10d">
<ul class="org-ul">
<li><p>We leave the binding structures of the language unchanged,</p><p>but we add three new operations to create and use references.</p><p><ol class="org-ol"></p><p><li>newref</p><p>allocates a new location and returns a reference to it.</li></p><p><li>deref</p><p>dereferences a reference</p><p>it returns the contents of the location</p><p>that the reference represents.</li></p><p><li>setref</p><p>changes the contents of the location</p><p>that the reference represents.</li></ol></p></li></ul>
</div>
</div>

<div id="outline-container-org782df73" class="outline-3">
<h3 id="org782df73">4.3 IMPLICIT-REFS: A Language with Implicit References</h3>
<div class="outline-text-3" id="text-org782df73">
<ul class="org-ul">
<li><p>The explicit reference design</p><p>gives a clear account of allocation, dereferencing,</p><p>and mutation because all these operations</p><p>are explicit in the programmer’s code.</p></li>

<li><p>Most programming languages take common patterns of</p><p>allocation, dereferencing, and mutation,</p><p>and package them up as part of the language.</p><p>Then the programmer need not worry about</p><p>when to perform these operations,</p><p>because they are built into the language.</p></li></ul>
</div>
</div>

<div id="outline-container-org7ca2ba3" class="outline-3">
<h3 id="org7ca2ba3">4.4 MUTABLE-PAIRS: A Language with Mutable Pairs</h3>
</div>

<div id="outline-container-orgf4db378" class="outline-3">
<h3 id="orgf4db378">4.5 Parameter-Passing Variations</h3>
<div class="outline-text-3" id="text-orgf4db378">
</div><div id="outline-container-orgeab5533" class="outline-4">
<h4 id="orgeab5533">CALL-BY-REFERENCE</h4>
</div>

<div id="outline-container-orgfe84e35" class="outline-4">
<h4 id="orgfe84e35">Lazy Evaluation: CALL-BY-NAME and CALL-BY-NEED</h4>
</div>
</div>
</div>

<div id="outline-container-orgaebb334" class="outline-2">
<h2 id="orgaebb334">5 Continuation-Passing Interpreters</h2>
<div class="outline-text-2" id="text-orgaebb334">
</div><div id="outline-container-orgdb5e1d0" class="outline-3">
<h3 id="orgdb5e1d0">intro</h3>
<div class="outline-text-3" id="text-orgdb5e1d0">
<ul class="org-ul">
<li><p>In chapter 3,</p><p>we used the concept of environments</p><p>to explore the behavior of bindings,</p><p>which establish the data context</p><p>in which each portion of a program is executed.</p></li>

<li><p>Here we will do the same for the control context</p><p>in which each portion of a program is executed.</p></li>

<li><p>We will introduce the concept of a continuation</p><p>as an abstraction of the control context,</p><p>and we will write interpreters</p><p>that take a continuation as an argument,</p><p>thus making the control context explicit.</p></li>

<li><p>a principle -</p><p>It is evaluation of operands,</p><p>not the calling of procedures,</p><p>that makes the control context grow.</p></li></ul>
</div>
</div>

<div id="outline-container-org60a74fa" class="outline-3">
<h3 id="org60a74fa">5.1 A Continuation-Passing Interpreter</h3>
<div class="outline-text-3" id="text-org60a74fa">
<ul class="org-ul">
<li><p><a href="./CPI/CPI.html">CPI</a></p></li>

<li><p>an environment is a representation of a function</p><p>from symbols to denoted values.</p></li>

<li><p>The continuation of an expression</p><p>represents a procedure</p><p>that takes the result of the expression</p><p>and completes the computation.</p></li>

<li><p>Tail Calls Don’t Grow the Continuation -</p><p>If the value of exp1 is returned as the value of exp2 ,</p><p>then exp1 and exp2 should run in the same continuation.</p></li></ul>
</div>
</div>

<div id="outline-container-org2b74351" class="outline-3">
<h3 id="org2b74351">5.2 A Trampolined Interpreter</h3>
</div>

<div id="outline-container-org57565f4" class="outline-3">
<h3 id="org57565f4">5.3 An Imperative Interpreter</h3>
</div>

<div id="outline-container-orgdd80166" class="outline-3">
<h3 id="orgdd80166">5.4 Exceptions</h3>
</div>

<div id="outline-container-orgc4cc41e" class="outline-3">
<h3 id="orgc4cc41e">5.5 Threads</h3>
<div class="outline-text-3" id="text-orgc4cc41e">
<ul class="org-ul">
<li><p>THREADS</p></li></ul>
</div>
</div>
</div>

<div id="outline-container-org24974f" class="outline-2">
<h2 id="org24974f">6 Continuation-Passing Style</h2>
<div class="outline-text-2" id="text-org24974f">
</div><div id="outline-container-org2b5545d" class="outline-3">
<h3 id="org2b5545d">6.1 Writing Programs in Continuation-Passing Style</h3>
</div>

<div id="outline-container-orgee399f7" class="outline-3">
<h3 id="orgee399f7">6.2 Tail Form</h3>
</div>

<div id="outline-container-orge8c950d" class="outline-3">
<h3 id="orge8c950d">6.3 Converting to Continuation-Passing Style</h3>
</div>

<div id="outline-container-orge2d7908" class="outline-3">
<h3 id="orge2d7908">6.4 Modeling Computational Effects</h3>
</div>
</div>

<div id="outline-container-org57233ed" class="outline-2">
<h2 id="org57233ed">7 Types</h2>
<div class="outline-text-2" id="text-org57233ed">
</div><div id="outline-container-orgd11c6bc" class="outline-3">
<h3 id="orgd11c6bc">intro</h3>
<div class="outline-text-3" id="text-orgd11c6bc">
<ul class="org-ul">
<li><p>Our goal is to analyze a program</p><p>to predict whether evaluation of a program is <b>safe</b>,</p><p>that is, whether the evaluation will proceed</p><p>without certain kinds of errors.</p></li>

<li><p>Exactly what is meant by safety, however,</p><p>may vary from language to language.</p></li>

<li><p>we will consider languages that are similar to LETREC.</p><p>For these languages we say that an evaluation is safe</p><p>if and only if :</p><p></p><p><ol class="org-ol"></p><p><li>For every evaluation of a variable var,</p><p>the variable is bound.</li></p><p></p><p><li>For every evaluation of a difference expression</p><p>(diff-exp exp1 exp2),</p><p>the values of exp1 and exp2 are both num-vals.</li></p><p></p><p><li>For every evaluation of an expression of the form</p><p>(zero?-exp exp1),</p><p>the value of exp1 is a num-val.</li></p><p></p><p><li>For every evaluation of a conditional expression</p><p>(if-exp exp1 exp2 exp3),</p><p>the value of exp1 is a bool-val.</li></p><p></p><p><li>For every evaluation of a procedure call</p><p>(call-exp rator rand),</p><p>the value of rator is a proc-val.</li></ol></p></li></ul>
</div>
</div>

<div id="outline-container-orgc7e58f7" class="outline-3">
<h3 id="orgc7e58f7">7.1 Values and Their Types</h3>
</div>

<div id="outline-container-org47cc2" class="outline-3">
<h3 id="org47cc2">7.2 Assigning a Type to an Expression</h3>
</div>

<div id="outline-container-org934292e" class="outline-3">
<h3 id="org934292e">7.3 CHECKED: A Type-Checked Language</h3>
</div>

<div id="outline-container-org75d6349" class="outline-3">
<h3 id="org75d6349">7.4 INFERRED: A Language with Type Inference</h3>
</div>
</div>

<div id="outline-container-org95ff0cf" class="outline-2">
<h2 id="org95ff0cf">8 Modules</h2>
<div class="outline-text-2" id="text-org95ff0cf">
</div><div id="outline-container-org9034a5a" class="outline-3">
<h3 id="org9034a5a">8.1 The Simple Module System</h3>
</div>

<div id="outline-container-org69d2b38" class="outline-3">
<h3 id="org69d2b38">8.2 Modules That Declare Types</h3>
</div>

<div id="outline-container-orged4814" class="outline-3">
<h3 id="orged4814">8.3 Module Procedures</h3>
</div>
</div>

<div id="outline-container-org4c3b56c" class="outline-2">
<h2 id="org4c3b56c">9 Objects and Classes</h2>
<div class="outline-text-2" id="text-org4c3b56c">
</div><div id="outline-container-org1b65581" class="outline-3">
<h3 id="org1b65581">9.1 Object-Oriented Programming</h3>
</div>

<div id="outline-container-orgd58e8f8" class="outline-3">
<h3 id="orgd58e8f8">9.2 Inheritance</h3>
</div>

<div id="outline-container-org47f8ee1" class="outline-3">
<h3 id="org47f8ee1">9.3 The Language</h3>
</div>

<div id="outline-container-orge5215fa" class="outline-3">
<h3 id="orge5215fa">9.4 The Interpreter</h3>
</div>

<div id="outline-container-org22da4b7" class="outline-3">
<h3 id="org22da4b7">9.5 A Typed Language</h3>
</div>

<div id="outline-container-orgf7a19c2" class="outline-3">
<h3 id="orgf7a19c2">9.6 The Type Checker</h3>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: xieyuheng</p>
<p class="date">Created: 2017-10-25 Wed 01:13</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
