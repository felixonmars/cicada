(note program = exp)
(note exp
  = <const-exp>
  | <zero?-exp>
  | <if-exp>
  | <diff-exp>
  | <var-exp>
  | <let-exp>
  | <proc-exp>
  | <call-exp>
  | <letrec-exp>)

(+data <const-exp> .num)
(+data <zero?-exp> .exp1)
(+data <if-exp>    .exp1 .exp2 .exp3)
(+data <diff-exp>  .exp1 .exp2)
(+data <var-exp>   .var)
(+data <let-exp>   .var .exp1 .body)

(+data <proc-exp>  .var .body)
(+data <call-exp>  .rator .rand)

(+data <letrec-exp>
  .proc-name .bound-var .proc-body .letrec-body)

(note expval
  = <num-val>
  | <bool-val>
  | <proc-val>)

(+data <num-val>  .num)
(+data <bool-val> .bool)

(+data <proc-val> .proc)

(+data <proc> .var .body .saved-env)

(+jojo proc-apply (-> :val :proc :cont -- expval)
  :proc .body
  :proc .saved-env :proc .var :val cons-env
  :cont eval)

(note env = <null-env> | <cons-env>)

(+data <null-env>)
(+data <cons-env> .rest .var .val)
(+data <cons-rec-env> .rest .proc-name .bound-var .proc-body)

(+jojo env-apply (-> :var :env -- expval)
  (case :env
    <null-env> ["- env-apply fail" w nl
                "  can not find var : " w :var w nl
                debug]
    <cons-env> (if :var :env .var equal?
                 then :env .val
                 else :var :env .rest recur)
    <cons-rec-env> (cond [:var :env .proc-name equal?]
                         [:env .bound-var
                          :env .proc-body
                          :env proc proc-val]
                         else [:var :env .rest recur])))

(+jojo init-env
  null-env
  ':x 10 num-val cons-env
  ':v 5  num-val cons-env
  ':i 1  num-val cons-env)

(+jojo program-eval (-> :program -- expval)
  :program init-env end-cont eval)

(+jojo eval (-> :exp :env :cont -- expval)
  (case :exp
    <const-exp> [:exp .num num-val
                 :cont cont-apply]
    <var-exp>   [:exp .var :env env-apply
                 :cont cont-apply]
    <proc-exp>  [:exp .var :exp .body :env proc proc-val
                 :cont cont-apply]

    <letrec-exp> [:env
                  :exp .proc-name
                  :exp .bound-var
                  :exp .proc-body
                  cons-rec-env :new-env!
                  :exp .letrec-body :new-env
                  :cont recur]

    <zero?-exp> [:exp .exp1 :env
                 :cont zero1-cont
                 recur]

    <let-exp>   [:exp .exp1 :env
                 :exp .var, :exp .body, :env, :cont, let-exp-cont
                 recur]

    <if-exp>    [:exp .exp1 :env
                 :exp .exp2, :exp .exp3, :env, :cont, if-test-cont
                 recur]

    <diff-exp>  [:exp .exp1 :env
                 :exp .exp2, :env, :cont, diff1-cont
                 recur]

    <call-exp>  [:exp .rator :env
                 :exp .rand, :env, :cont, rator-cont
                 recur]))

(+data <end-cont>)
(+data <zero1-cont> .rest)

(+data <let-exp-cont> .var .body .env .rest)
(+data <if-test-cont> .exp2 .exp3 .env .rest)

(+data <diff1-cont> .exp2 .env .rest)
(+data <diff2-cont> .val .rest)

(+data <rator-cont> .rand .env .rest)
(+data <rand-cont> .val .rest)

(+jojo cont-apply (-> :val :cont -- expval)
  (case :cont

    <end-cont>
    ["end of computation." w nl :val]

    <zero1-cont>
    [:val .num 0 eq? bool-val :cont .rest recur]

    <let-exp-cont>
    [:cont .body
     :cont .env, :cont .var, :val, cons-env
     :cont .rest eval]

    <if-test-cont>
    (if :val .bool
      then :cont .exp2 :cont .env :cont .rest eval
      else :cont .exp3 :cont .env :cont .rest eval)

    <diff1-cont>
    [:cont .exp2 :cont .env
     :val, :cont .rest, diff2-cont
     eval]

    <diff2-cont>
    [:cont .val .num, :val .num, sub, num-val
     :cont .rest
     recur]

    <rator-cont>
    [:cont .rand :cont .env
     :val, :cont .rest, rand-cont
     eval]

    <rand-cont>
    [:val
     :cont .val .proc
     :cont .rest proc-apply]))

(note
  123 -- <const-exp>
  (diff ... ...) -- <diff-exp>
  (if ... ... ...) -- <if-exp>
  (zero? ...) -- <zero?-exp>
  :var -- <var-exp>
  (let :var ... ...) -- <let-exp>

  (proc :var ...) -- <proc-exp>
  (call :rator :rand) -- <call-exp>

  (letrec :proc-name :bound-var
    :proc-body
    :letrec-body) -- <letrec-exp>)

(+jojo parse (-> :sexp -- exp)
  (cond
    [:sexp int-jo?]   [:sexp jo->int const-exp]
    [:sexp local-jo?] [:sexp var-exp]
    [:sexp cons? not] ["- parse fail" w nl
                       "  can not parse sexp : " w
                       :sexp sexp-write nl
                       debug]
    else [:sexp parse/cons]))

(+jojo parse/cons (-> :sexp -- exp)
  :sexp .car :key!
  :sexp .cdr :body!
  (cond [:key 'zero? eq?] [:body parse/spread zero?-exp]
        [:key 'if eq?]    [:body parse/spread if-exp]
        [:key 'diff eq?]  [:body parse/spread diff-exp]
        [:key 'let eq?]   [:body .car
                           :body .cdr parse/spread let-exp]

        [:key 'proc eq?]  [:body .car
                           :body .cdr parse/spread proc-exp]
        [:key 'call eq?]  [:body parse/spread call-exp]

        [:key 'letrec eq?]
        [:body .car
         :body .cdr .car
         :body .cdr .cdr parse/spread letrec-exp]))

(+jojo parse/spread {parse} list-map list-spread)

(+jojo CPI (-> :body --)
  :body {parse program-eval expval-write nl} list-for-each)

(+jojo expval-write (-> :expval)
  (case :expval
    <num-val>  [:expval .num w]
    <bool-val> [:expval .bool w]))

(CPI
 1 2 3
 (diff 2 1)
 (diff 3 1)
 (let :y 5 (diff :x :y))
 (zero? 1)
 (zero? 0)
 (let :y (diff :x 3)
   (if (zero? :y) 0 666))

 (let :x 200
   (let :f (proc :z (diff :z :x) )
     (let :x 100
       (let :g (proc :z (diff :z :x))
         (diff (call :f 1)
           (call :g 1))))))

 (letrec :double :x
   (if (zero? :x) 0
     (diff (call :double (diff :x 1)) -2))
   (call :double 6)))
