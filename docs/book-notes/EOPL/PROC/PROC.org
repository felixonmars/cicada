#+html_head: <link rel="stylesheet" href="../../../css/org-page.css"/>
#+property: tangle PROC.jo
#+title: PROC

* intro

  - So far our language has only the operations
    that were included in the original language.
    For our interpreted language to be at all useful,
    we must allow new procedures to be created.
    We call the new language PROC.

* exp

  #+begin_src jojo
  (note program = exp)
  (note exp
    = <const-exp>
    | <zero?-exp>
    | <if-exp>
    | <diff-exp>
    | <var-exp>
    | <let-exp>
    | <proc-exp>
    | <call-exp>)

  (+data <const-exp> .num)
  (+data <zero?-exp> .exp1)
  (+data <if-exp>    .exp1 .exp2 .exp3)
  (+data <diff-exp>  .exp1 .exp2)
  (+data <var-exp>   .var)
  (+data <let-exp>   .var .exp1 .body)

  (+data <proc-exp>  .var .body)
  (+data <call-exp>  .rator .rand)
  #+end_src

* expval

  #+begin_src jojo
  (note expval
    = <num-val>
    | <bool-val>
    | <proc-val>)

  (+data <num-val>  .num)
  (+data <bool-val> .bool)

  (+data <proc-val> .proc)
  #+end_src

* proc

  #+begin_src jojo
  (+data <proc> .var .body .saved-env)

  (+jojo proc-apply (-> :val :proc -- expval)
    :proc .saved-env :proc .var :val cons-env
    :proc .body swap eval)
  #+end_src

* specifying proc-exp

  #+begin_src jojo
  (note
    (= :var :body proc-exp :env eval,
       :var :body :env proc proc-val))
  #+end_src

* specifying call-exp

  #+begin_src jojo
  (note
    (= :rator :rand call-exp :env eval,
       :rator :env recur .proc :proc!
       :rand  :env recur :arg!
       :arg :proc proc-apply))
  #+end_src

* environments

  #+begin_src jojo
  (note env = <null-env> | <cons-env>)

  (+data <null-env>)
  (+data <cons-env> .rest .var .val)

  (+jojo env-apply (-> :var :env -- expval)
    (case :env
      <null-env> ["- env-apply fail" w nl
                  "  can not find var : " w :var w nl
                  debug]
      <cons-env> (if :env .var :var equal?
                     then :env .val
                     else :var :env .rest recur)))
  #+end_src

* program

  #+begin_src jojo
  (+jojo init-env
    null-env
    ':x 10 num-val cons-env
    ':v 5  num-val cons-env
    ':i 1  num-val cons-env)

  (+jojo program-eval (-> :program -- expval)
    :program init-env eval)
  #+end_src

* eval

  #+begin_src jojo
  (+jojo eval (-> :exp :env -- expval)
    (case :exp
      <const-exp> [:exp .num  num-val]
      <zero?-exp> [:exp .exp1 :env recur .num 0 equal? bool-val]
      <if-exp>    (if :exp .exp1 :env recur .bool
                      then :exp .exp2 :env recur
                      else :exp .exp3 :env recur)
      <diff-exp>  [:exp .exp1 :env recur .num
                   :exp .exp2 :env recur .num sub num-val]
      <var-exp>   [:exp .var :env env-apply]
      <let-exp>   [:env
                   :exp .var
                   :exp .exp1 :env recur
                   cons-env :new-env!
                   :exp .body :new-env recur]

      <proc-exp>  [:exp .var :exp .body :env proc proc-val]
      <call-exp>  [:exp .rator :env recur .proc :proc!
                   :exp .rand  :env recur :arg!
                   :arg :proc proc-apply]))
  #+end_src

* parse

  #+begin_src jojo
  (note
    123 -- <const-exp>
    (diff ... ...) -- <diff-exp>
    (if ... ... ...) -- <if-exp>
    (zero? ...) -- <zero?-exp>
    :var -- <var-exp>
    (let :var ... ...) -- <let-exp>

    (proc :var ...) -- <proc-exp>
    (call :rator :rand) -- <call-exp>)

  (+jojo parse (-> :sexp -- exp)
    (cond
      [:sexp int-jo?]   [:sexp jo->int const-exp]
      [:sexp local-jo?] [:sexp var-exp]
      [:sexp cons? not] ["- parse fail" w nl
                         "  can not parse sexp : " w
                         :sexp sexp-write nl
                         debug]
      else [:sexp parse/cons]))

  (+jojo parse/cons (-> :sexp -- exp)
    :sexp .car :key!
    :sexp .cdr :body!
    (cond [:key 'zero? eq?] [:body parse/spread zero?-exp]
          [:key 'if eq?]    [:body parse/spread if-exp]
          [:key 'diff eq?]  [:body parse/spread diff-exp]
          [:key 'let eq?]   [:body .car :body
                             .cdr parse/spread let-exp]

          [:key 'proc eq?]  [:body .car :body
                             .cdr parse/spread proc-exp]
          [:key 'call eq?]  [:body parse/spread call-exp]))

  (+jojo parse/spread {parse} list-map list-spread)
  #+end_src

* interface

  #+begin_src jojo
  (+jojo PROC (-> :body --)
    :body {parse program-eval expval-write nl} list-for-each)

  (+jojo expval-write (-> :expval)
    (case :expval
      <num-val>  [:expval .num w]
      <bool-val> [:expval .bool w]))
  #+end_src

* [test]

  #+begin_src jojo
  (note
    (PROC
     1 2 3
     (diff 2 1)
     (diff 3 1)
     (let :y 5 (diff :x :y))
     (zero? 1)
     (zero? 0)
     (let :y (diff :x 3)
       (if (zero? :y) 0 666))

     (let :x 200
       (let :f (proc :z (diff :z :x) )
         (let :x 100
           (let :g (proc :z (diff :z :x))
             (diff (call :f 1)
               (call :g 1))))))))
  #+end_src

* exercise

  #+begin_src jojo
  (note What is the value of the following PROC program?

    (PROC
     (let :makemult
       (proc :maker
         (proc :x (if (zero? :x) 0
                    (diff (call (call :maker :maker)
                            (diff :x 1))
                      -4))))
       (let :times4
         (proc :x
           (call (call :makemult :makemult) :x))
         (call :times4 3)))))
  #+end_src
