#+title: programming in agda

- by ulf norell

* [todo-stack]

  - fix naming about all-u

* intro

*** >< an interpreter

*** a well typed interpreter

***** type-u

      #+begin_src cicada
      (+union type-u
        nat-type-t
        bool-type-t)

      (+data nat-type-t)
      (+data bool-type-t)
      #+end_src

***** exp-u

      #+begin_src cicada
      (+union exp-u
        : (-> type : type-u -- type-tt)
        (-> n : nat-u -- nat-type-c lit-exp-t)
        (-> -- bool-type-c true-exp-t)
        (-> -- bool-type-c false-exp-t)
        (-> [a b] : nat-type-c exp-u -- bool-type-c less-exp-t)
        (-> [a b] : nat-type-c exp-u -- bool-type-c plus-exp-t)
        (-> a : bool-type-c exp-u
            [b c] : type exp-u
         -- type if-exp-t))
      #+end_src

***** to-value-type

      #+begin_src cicada
      (+fun to-value-type
        : (-> type : type-u -- type-tt)
        (case type
          (nat-type-t nat-u)
          (bool-type-t bool-u)))
      #+end_src

***** eval

      #+begin_src cicada
      (+fun eval
        : (-> exp : :type exp-u
           -- :type to-value-type)
        (case exp
          (lit-exp-t exp.n)
          (true-exp-t true-c)
          (false-exp-t false-c)
          (less-exp-t exp.a exp.b lt-p)
          (plus-exp-t exp.a exp.b add)
          (if-exp-t (case [exp.a recur]
                      (true-t exp.b recur)
                      (false-t exp.c recur)))))
      #+end_src

*** with variables

***** type-u

      #+begin_src cicada
      (+union type-u
        nat-type-t
        bool-type-t)

      (+data nat-type-t)
      (+data bool-type-t)
      #+end_src

***** index-u

      #+begin_src cicada
      (+union index-u
        : (-> element : :type
              list : :type list-u
           -- type-tt)
        (-> -- element element rest cons-c zero-index-t)
        (-> prev : element list index-u
         -- element :next list cons-c succ-index-t))
      #+end_src

***** exp-u

      #+begin_src cicada
      (+union exp-u
        : (-> context : type-u list-u, type : type-u -- type-tt)
        (-> index : type context index-u -- context type var-exp-t)
        (-> n : nat-u -- context nat-type-c lit-exp-t)
        (-> -- context bool-type-c true-exp-t)
        (-> -- context bool-type-c false-exp-t)
        (-> [a b] : nat-type-c exp-u -- context bool-type-c less-exp-t)
        (-> [a b] : nat-type-c exp-u -- context bool-type-c plus-exp-t)
        (-> a : bool-type-c exp-u
            [b c] : type exp-u
         -- context type if-exp-t))
      #+end_src

***** to-value-type

      #+begin_src cicada
      (+fun to-value-type
        : (-> type : type-u -- type-tt)
        (case type
          (nat-type-t nat-u)
          (bool-type-t bool-u)))
      #+end_src

***** all-u

      #+begin_src cicada
      (+union all-u
        : (-> judgment : (-> :type -- type-tt)
              list : :type list-u
           -- type-tt)
        (-> -- judgment null-c null-all-t)
        (-> car : element judgment
            cdr : {judgment} list all-u
         -- {judgment} element list cons-c cons-all-t))
      #+end_src

***** all-of-value-type

      #+begin_src cicada
      (+fun all-of-value-type
        : (-> context : type-u list-u
           -- type-tt)
        {to-value-type} context all-u)
      #+end_src

***** index-lookup

      #+begin_src cicada
      (+fun index-lookup
        : (-> judgment :: (-> :type -- type-tt)
              list :: :type list-u
              element :: :type
              all : judgment list all-u
              index : element list index-u
           -- element judgment)
        (case index
          (zero-index-t all.car)
          (succ-index-t all.cdr index.prev recur)))
      #+end_src

***** eval

      #+begin_src cicada
      (+fun eval
        : (-> env : :context all-of-value-type
              exp : :context :type exp-u
           -- :type to-value-type)
        (case exp
          (var-exp-t ><><><)
          (lit-exp-t exp.n)
          (true-exp-t true-c)
          (false-exp-t false-c)
          (less-exp-t exp.a exp.b lt-p)
          (plus-exp-t exp.a exp.b add)
          (if-exp-t (case [env exp.a recur]
                      (true-t env exp.b recur)
                      (false-t env exp.c recur)))))
      #+end_src
