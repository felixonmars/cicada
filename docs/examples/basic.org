#+title: basic

* [todo-list]

*** use number theory -- to test type-checker as prover

* [note]

*** naming convention

    - type

      | -t  | type         |
      | -u  | union        |
      | -q  | quotype      |
      | -tc | type-class   |
      | -tt | type of type |

    - function

      | -p  | predicate   |
      | -c  | constructor |
      | -cr | create      |
      | -cl | clone       |

*** level of types

    | 0 | object               |
    | 1 | type, union, quotype |
    | 2 | type-class, type-tt |

* bool

*** bool-u

    #+begin_src jojo
    (+union bool-u : type-tt
      (-> -- true-t)
      (-> -- false-t))
    #+end_src

* nat

*** nat-u

    #+begin_src jojo
    (+union nat-u : type-tt
      (-> -- zero-t)
      (-> .prev : nat-u -- succ-t))

    (+fun add : (-> [m n] : nat-u -- nat-u)
      (case n
        (zero-t m)
        (succ-t m n.prev recur succ-c)))

    (+fun mul : (-> [m n] : nat-u -- nat-u)
      (case n
        (zero-t n)
        (succ-t m n.prev recur n add)))

    (+fun factorial : (-> n : nat-u -- nat-u)
      (case n
        (zero-t n succ-c)
        (succ-t n.prev recur n mul)))
    #+end_src

*** even-u

    #+begin_src jojo
    (+union is-even-u : (-> nat-u -- type-tt)
      (-> -- zero-c zero-is-even-t)
      (-> .prev : [:m is-even-u]
       -- :m succ-c succ-c even-plus-two-is-even-t))

    (+proof two-is-even
      : (-> -- zero-c succ-c succ-c is-even-u)
      zero-is-even-c
      even-plus-two-is-even-c)
    #+end_src

* eq

*** eq-t -- an interface to the internal unification

    #+begin_src jojo
    (+type eq-t
      : (-> :t :t -- type-tt)
      (-> -- :z :z eq-t))

    (+proof eq-apply
      : (-> :x :y eq-t fun : (-> :t1 -- :t2)
         -- :x fun :y fun eq-t)
      eq-c)

    (+proof eq-swap
      : (-> :x :y eq-t -- :y :x eq-t)
      eq-c)

    (+proof eq-compose
      : (-> :x :y eq-t :y :z eq-t -- :x :z eq-t)
      eq-c)
    #+end_src

*** add-associative

    #+begin_src jojo
    (+proof add-associative
      : (-> [x y z] : nat-u
         -- x y add z add
            x y z add add eq-t)
      (case z
        (zero-t eq-c)
        (succ-t x y z.prev recur {succ-c} eq-apply)))
    #+end_src

*** add-commutative

    #+begin_src jojo
    (+proof add-commutative
      : (-> [m n] : nat-u
         -- m n add, n m add eq-t)
      (case n
        (zero-t m add-zero-commutative)
        (succ-t m n.prev recur {succ-c} eq-apply
                n.prev m add-succ-commutative eq-compose)))

    (+proof add-zero-commutative
      : (-> m : nat-u
         -- m zero-c add, zero-c m add eq-t)
      (case m
        (zero-t eq-c)
        (succ-t m.prev recur {succ-c} eq-apply)))

    (+proof add-succ-commutative
      : (-> [m n] : nat-u
         -- m succ-c n add, m n add succ-c eq-t)
      (case n
        (zero-t eq-c)
        (succ-t m n.prev recur {succ-c} eq-apply)))
    #+end_src

* ==

*** ==

    #+begin_src jojo
    (+type ==
      : (-> :t :t -- type-tt)
      (-> -- :z == :z))

    (+proof ==-apply
      : (-> :x == :y, fun : (-> :t1 -- :t2)
         -- [:x fun] == [:y fun])
      ==-c)

    (+proof ==-swap
      : (-> :x == :y -- :y == :x)
      ==-c)

    (+proof ==-compose
      : (-> :x == :y, :y == :z -- :x == :z)
      ==-c)
    #+end_src

*** add-associative

    #+begin_src jojo
    (+proof add-associative
      : (-> [x y z] : nat-u
         -- [x y add z add] == [x y z add add])
      (case z
        (zero-t eq-c)
        (succ-t x y z.prev recur {succ-c} ==-apply)))
    #+end_src

*** add-commutative

    #+begin_src jojo
    (+proof add-commutative
      : (-> [m n] : nat-u
         -- [m n add] == [n m add])
      (case n
        (zero-t m add-zero-commutative)
        (succ-t m n.prev recur {succ-c} ==-apply
                n.prev m add-succ-commutative ==-compose)))

    (+proof add-zero-commutative
      : (-> m : nat-u
         -- [m zero-c add] == [zero-c m add])
      (case m
        (zero-t ==-c)
        (succ-t m.prev recur {succ-c} ==-apply)))

    (+proof add-succ-commutative
      : (-> [m n] : nat-u
         -- [m succ-c n add] == [m n add succ-c])
      (case n
        (zero-t ==-c)
        (succ-t m n.prev recur {succ-c} ==-apply)))
    #+end_src

* list

*** list-u

    #+begin_src jojo
    (+union list-u : (-> type-tt -- type-tt)
      (-> -- :t null-t)
      (-> .car : :t
          .cdr : [:t list-u]
       -- :t list-u))
    #+end_src

*** list-u -- not inline

    #+begin_src jojo
    (+union list-u : (-> type-tt -- type-tt)
      null-t
      cons-t)

    (+type null-t : (-> type-tt -- type-tt)
      (-> -- :t null-t))

    (+type cons-t : (-> type-tt -- type-tt)
      (-> .car : :t
          .cdr : [:t cons-t]
       -- :t cons-t))
    #+end_src

*** length

    #+begin_src jojo
    (+fun length : (-> l : [:t list-u] -- nat-u)
      (case l
        (null-t zero-c)
        (cons-t l.cdr recur succ-c)))
    #+end_src

*** map

    #+begin_src jojo
    (+fun map
      : (-> l : [:t1 list-u]
            fun : (-> :t1 -- :t2)
         -- :t2 list-u)
      (case l
        (null-t null-c)
        (cons-t l.car fun l.cdr {fun} recur cons-c)))
    #+end_src

*** ref -- will not pass type check

    #+begin_src jojo
    ;; this function will not pass type check
    ;;   because we can not use .car .cdr on list-u
    ;;   we can only use them on cons-t
    (+fun ref
      : (-> l : [:t list-u], index : nat-u -- :t)
      (case index
        (zero-t l.car)
        (succ-t l.cdr index.prev recur)))
    #+end_src

*** remove-first

    #+begin_src jojo
    (+fun remove-first
      : (-> x : :t, l : [:t list-u]
         -- :t list-u)
      (case l
        (null-t null-c)
        (cons-t (case [l.car x equal-p]
                   (true-t  l.cdr)
                   (false-t l.car l.cdr x recur cons)))))
    #+end_src

*** has-length-u

***** has-length-u

      #+begin_src jojo
      (+union has-length-u : (-> :t list-u nat-u -- type-tt)
        (-> -- null-c zero-c null-has-length-t)
        (-> .cdr : [:l :n has-length-u]
         -- :a :l cons-c :n succ-c cons-has-length-t))
      #+end_src

***** map-has-length

      #+begin_src jojo
      (+fun map-has-length
        : (-> fun :: (-> :t1 -- :t2)
              has-length : [:l :n has-length-u]
           -- :l {fun} map :n has-length-u)
        (case has-length
          (null-has-length-t null-has-length-c)
          (cons-has-length-t has-length.cdr recur cons-has-length-c)))
      #+end_src
