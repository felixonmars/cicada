#+title: basic

* [todo-stack]

*** use number theory -- to test type-checker as prover

* [note]

*** naming convention

    - type

      | -t  | type constructor          |
      | -u  | union-type constructor    |
      | -q  | quotient-type constructor |
      | -tc | type-class                |
      | -tt | type of type              |

    - function

      | -p  | predicate        |
      | -c  | data constructor |

*** level of types

    | 0 | object                          |
    | 1 | type, union-type, quotient-type |
    | 2 | type-class, type-tt             |

* bool

*** bool-u

    #+begin_src cicada
    (+union bool-u : type-tt
      (-> -- true-t)
      (-> -- false-t))
    #+end_src

* nat

*** nat-u

    #+begin_src cicada
    (+union nat-u : type-tt
      (-> -- zero-t)
      (-> prev : nat-u -- succ-t))

    (+fun add : (-> [m n] : nat-u -- nat-u)
      (case n
        (zero-t m)
        (succ-t m n.prev recur succ-c)))

    (+fun mul : (-> [m n] : nat-u -- nat-u)
      (case n
        (zero-t n)
        (succ-t m n.prev recur m add)))

    (+fun factorial : (-> n : nat-u -- nat-u)
      (case n
        (zero-t n succ-c)
        (succ-t n.prev recur n mul)))
    #+end_src

*** even-u

    #+begin_src cicada
    (+union is-even-u : (-> nat-u -- type-tt)
      (-> -- zero-c zero-is-even-t)
      (-> prev : [:m is-even-u]
       -- :m succ-c succ-c even-plus-two-is-even-t))

    (+proof two-is-even
      : (-> -- zero-c succ-c succ-c is-even-u)
      zero-is-even-c
      even-plus-two-is-even-c)
    #+end_src

* eqv

*** eqv

    #+begin_src cicada
    (+type eqv-t
      : (-> :t :t -- type-tt)
      (-> -- :z :z eqv-t))

    (+proof eqv-apply
      : (-> :x :y eqv-t, fun : (-> :t1 -- :t2)
         -- :x fun, :y fun eqv-t)
      eqv-c)

    (+proof eqv-apply
      : (-> :x :y eqv-t, fun : (-> :t1 -- :t2)
         -- :x fun, :y fun eqv-t)
      eqv-c)

    (+proof eqv-swap
      : (-> :x :y eqv-t -- :y :x eqv-t)
      eqv-c)

    (+proof eqv-compose
      : (-> :x :y eqv-t, :y :z eqv-t -- :x :z eqv-t)
      eqv-c)
    #+end_src

*** add-associative

    #+begin_src cicada
    (+proof add-associative
      : (-> [x y z] : nat-u
         -- x y add z add, x y z add add eqv-t)
      (case z
        (zero-t eqv-c)
        (succ-t x y z.prev recur {succ-c} eqv-apply)))
    #+end_src

*** add-commutative

    #+begin_src cicada
    (+proof add-commutative
      : (-> [m n] : nat-u
         -- m n add, n m add eqv-t)
      (case n
        (zero-t m add-zero-commutative)
        (succ-t m n.prev recur {succ-c} eqv-apply
                n.prev m add-succ-commutative eqv-compose)))

    (+proof add-zero-commutative
      : (-> m : nat-u
         -- m zero-c add, zero-c m add eqv-t)
      (case m
        (zero-t eqv-c)
        (succ-t m.prev recur {succ-c} eqv-apply)))

    (+proof add-succ-commutative
      : (-> [m n] : nat-u
         -- m succ-c n add, m n add succ-c eqv-t)
      (case n
        (zero-t eqv-c)
        (succ-t m n.prev recur {succ-c} eqv-apply)))
    #+end_src

* list

*** list-u

    #+begin_src cicada
    (+union list-u : (-> type : type-tt -- type-tt)
      (-> -- type null-t)
      (-> car : type
          cdr : [type list-u]
       -- type cons-t))
    #+end_src

*** list-u -- not inline

    #+begin_src cicada
    (+union list-u : (-> type-tt -- type-tt)
      null-t
      cons-t)

    (+type null-t : (-> type : type-tt -- type-tt)
      (-> -- type null-t))

    (+type cons-t : (-> type : type-tt -- type-tt)
      (-> car : type
          cdr : [type cons-t]
       -- type cons-t))
    #+end_src

*** length

    #+begin_src cicada
    (+fun length : (-> l : [:t list-u] -- nat-u)
      (case l
        (null-t zero-c)
        (cons-t l.cdr recur succ-c)))
    #+end_src

*** map

    #+begin_src cicada
    (+fun map
      : (-> l : [:t1 list-u]
            fun : (-> :t1 -- :t2)
         -- :t2 list-u)
      (case l
        (null-t null-c)
        (cons-t l.car fun l.cdr {fun} recur cons-c)))
    #+end_src

*** ref -- will not pass type check

    #+begin_src cicada
    ;; this function will not pass type check
    ;;   because we can not use car cdr on list-u
    ;;   we can only use them on cons-t
    (+fun ref
      : (-> l : [:t list-u], index : nat-u -- :t)
      (case index
        (zero-t l.car)
        (succ-t l.cdr index.prev recur)))
    #+end_src

*** remove-first

    #+begin_src cicada
    (+fun remove-first
      : (-> x : :t, l : [:t list-u]
         -- :t list-u)
      (case l
        (null-t null-c)
        (cons-t (case [l.car x eq-p]
                   (true-t  l.cdr)
                   (false-t l.car l.cdr x recur cons)))))
    #+end_src

*** has-length-u

***** has-length-u

      #+begin_src cicada
      (+union has-length-u : (-> :t list-u nat-u -- type-tt)
        (-> -- null-c zero-c null-has-length-t)
        (-> cdr : [:l :n has-length-u]
         -- :a :l cons-c :n succ-c cons-has-length-t))

      (+union has-length-u
        : (-> type :: type-tt
              list : [type list-u]
              length : nat-u
           -- type-tt)
        (-> -- null-c zero-c null-has-length-t)
        (-> cdr : [list length has-length-u]
         -- element :: type
            element list cons-c
            length succ-c cons-has-length-t))
      #+end_src

***** map-has-length

      #+begin_src cicada
      (+fun map-has-length
        : (-> fun :: (-> :t1 -- :t2)
              has-length : [:l :n has-length-u]
           -- :l {fun} map :n has-length-u)
        (case has-length
          (null-has-length-t null-has-length-c)
          (cons-has-length-t has-length.cdr recur cons-has-length-c)))
      #+end_src
